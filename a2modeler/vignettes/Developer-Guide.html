<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Haarstick" />

<meta name="date" content="2018-12-10" />

<title>a2modeler Developer Guide</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">a2modeler Developer Guide</h1>
<h4 class="author"><em>Haarstick</em></h4>
<h4 class="date"><em>2018-12-10</em></h4>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#background">Background</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#workflow">Workflow</a><ul>
<li><a href="#modeler-constructor">Modeler Constructor</a></li>
<li><a href="#add-samples">Add Samples</a></li>
<li><a href="#set-measures">Set Measures</a></li>
<li><a href="#add-model">Add Model</a></li>
<li><a href="#train-models">Train Models</a></li>
</ul></li>
<li><a href="#predictions">Predictions</a></li>
<li><a href="#helper-functions">Helper Functions</a></li>
</ul>
</div>

<div id="overview" class="section level2">
<h2>Overview</h2>
<p>a2modeler is an R package that provides a framework for efficiently and reliably building statistical models. a2modeler currently supports the following use cases:</p>
<ul>
<li><strong>Forecasting</strong>: Statistical models to make forward looking predicts of sequential or time series data</li>
<li><strong>Segmentation</strong>: Statistical models to derive sub-groups withing a dataset based on measurable patterns</li>
<li><strong>Regression</strong>: Statistical models to fit and make prediction for continuous numerical targets</li>
<li><strong>Classification</strong>: Statistical models to fit and make prediction for binary targets such as Yes/No, 0/1, Hot Dog/Not Hog Dog</li>
<li><strong>Multi-Classification</strong>: Statistical models to fit and make prediction for discrete targets with more than two unique values</li>
</ul>
<p>This developer guide is designed to give some details and context on package design.</p>
</div>
<div id="background" class="section level2">
<h2>Background</h2>
<p>This guide assumes a working knowledge of R, the tidyverse and sparklyr R packages, R S3 object oriented programming, and R package development. Relevant links:</p>
<ul>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf">R</a><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
<li><a href="https://www.tidyverse.org/">tidyverse</a><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></li>
<li><a href="https://r4ds.had.co.nz/">R for Data Science</a><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></li>
<li><a href="http://adv-r.had.co.nz/S3.html">S3 OOP</a><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></li>
<li><a href="http://r-pkgs.had.co.nz/">R Packages</a><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a></li>
</ul>
<p>This guide also assumes knowledge of how a2modeler is applied. Check out the User-Guide Vignette for details on how a2modeler is used.</p>
<p>The a2modeler package functionality relies on several derived classes using R’s <a href="http://adv-r.had.co.nz/S3.html">R S3 Object System</a>. In the following sections each of the important classes are discussed. The most important class is the modeler class and it’s inherited sub-classes. These classes are the main object created in a a2modeler work flow.</p>
</div>
<div id="requirements" class="section level2">
<h2>Requirements</h2>
<ul>
<li><strong>R</strong>: version &gt;= 3.5</li>
<li><strong>Spark</strong>: version &gt;= 2.3.0</li>
</ul>
</div>
<div id="workflow" class="section level2">
<h2>Workflow</h2>
<p>A key deisgn principle of a2modeler is the set of high level functions common to multiple use cases seen in the image below:</p>
<div class="figure">
<img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4RD6RXhpZgAATU0AKgAAAAgABAE7AAIAAAAQAAAISodpAAQAAAABAAAIWpydAAEAAAAgAAAQ0uocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAENocmlzIEhhYXJzdGljawAABZADAAIAAAAUAAAQqJAEAAIAAAAUAAAQvJKRAAIAAAADNzkAAJKSAAIAAAADNzkAAOocAAcAAAgMAAAInAAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIwMTg6MTI6MDMgMTM6Mjk6MzYAMjAxODoxMjowMyAxMzoyOTozNgAAAEMAaAByAGkAcwAgAEgAYQBhAHIAcwB0AGkAYwBrAAAA/+ELImh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iLz48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdGVEYXRlPjIwMTgtMTItMDNUMTM6Mjk6MzYuNzkxPC94bXA6Q3JlYXRlRGF0ZT48L3JkZjpEZXNjcmlwdGlvbj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+PGRjOmNyZWF0b3I+PHJkZjpTZXEgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOmxpPkNocmlzIEhhYXJzdGljazwvcmRmOmxpPjwvcmRmOlNlcT4NCgkJCTwvZGM6Y3JlYXRvcj48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAg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f9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQAfb7z+9B/36P8A8VR9vvP70H/fo/8AxVFFAB9vvP70H/fo/wDxVH2+8/vQf9+j/wDFUUUAH2+8/vQf9+j/APFUfb7z+9B/36P/AMVRRQBDdy3N5avBK8QV8ZKxnPBz/e9qKKKAP//Z" alt="a2modeler Workflow" />
<p class="caption">a2modeler Workflow</p>
</div>
<p>Below is an example of simple but standard a2modeler regression workflow</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">

<span class="co"># # Create Spark Connection</span>
sc &lt;-<span class="st"> </span><span class="kw">spark_connect</span>(<span class="dt">master =</span> <span class="st">&quot;local&quot;</span>)

<span class="co"># Copy data to spark</span>
df &lt;-<span class="st"> </span><span class="kw">copy_to</span>(sc, mtcars, <span class="dt">name =</span> <span class="st">&quot;df&quot;</span>, <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)


<span class="co"># Create Spark datasets </span>
df1 &lt;-<span class="st"> </span>iris <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">sample_frac</span>(<span class="dt">size =</span> .<span class="dv">5</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">copy_to</span>(sc, ., <span class="dt">name =</span> <span class="st">&quot;df1&quot;</span>, <span class="dt">overwrite =</span> <span class="ot">TRUE</span>)

<span class="co"># Simple A2 Regressor Workflow</span>
r1 &lt;-<span class="st"> </span><span class="kw">regressor</span>(<span class="dt">df =</span> df1, <span class="dt">target =</span> <span class="st">&quot;Petal_Width&quot;</span>, <span class="dt">name =</span> <span class="st">&quot;test&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">set_measure</span>(<span class="dt">measure =</span> RMSE) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_holdout_samples</span>(<span class="dt">splits =</span> <span class="kw">c</span>(.<span class="dv">5</span>, .<span class="dv">5</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">add_model</span>(<span class="dt">pipe =</span> test_pipe,
            <span class="dt">method =</span> <span class="st">&quot;ml_linear_regression&quot;</span>,
            <span class="dt">uid =</span> <span class="st">&quot;lm&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">add_model</span>(<span class="dt">pipe =</span> test_pipe,
            <span class="dt">method =</span> <span class="st">&quot;ml_decision_tree_regressor&quot;</span>,
            <span class="dt">uid =</span> <span class="st">&quot;tree&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">train_models</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">set_final_model</span>(., <span class="dt">method =</span> <span class="st">&quot;best&quot;</span>, <span class="dt">reevaluate =</span> <span class="ot">FALSE</span>, <span class="dt">refit =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>In the following sections each step is discussed in depth</p>
<div id="modeler-constructor" class="section level3">
<h3>Modeler Constructor</h3>
<p>The a2modeler workflow starts with a use-case specific function with creates a modeler class object (discussed below). Each of use-case constructor function creates a seperate child class object that inherits from the parent modeler class. The actual <code>modeler</code> constructor is only used internally by the use case specific constructors. The use of class inheritence allows for general code to be shared across sub-classes but specific constraints, parameters, and methods to be implemented for each use case.</p>
<div id="modeler-class" class="section level4">
<h4>Modeler Class</h4>
<p>The main class in the a2modeler package is the modeler class. Modeler class objects provide the framework for developing models by storing information on the input dataset, target variable, sampling strategy, measurement, data transformation and models. The class enforces standards and some limits on the model development but creates consistency and allows for a consistent high level API for users (see User Guide).</p>
<p>The modeler object is model algorithm and package agnostic but requires that the proper hooks are in place to produce the right outputs. In practice that means while the modeler backend is modular, only the Spark-ML<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> backend is implemented for all but the forecaster child class which uses the forecast R package<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
</div>
<div id="modeler-inputs" class="section level4">
<h4>Modeler Inputs</h4>
<p>In addition to the required inputs of the dataframe, target and index variables if required, the following inputs can be provided for meta-data purposes:</p>
<ul>
<li><strong>name</strong>: optional name for use case. Used in reporting and deployment pathing</li>
<li><strong>uid</strong>: optional input for unique identifier</li>
<li><strong>version</strong>: optional input for use case version. Used in report and pathing</li>
<li><strong>desc</strong>: optional input for use case description</li>
<li><strong>scientist</strong>: optional input for data science developer</li>
<li><strong>execution_strategy</strong>: input for parallel backend execution. Default is sequential. Leverages the future<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> for parallel execution.</li>
<li><strong>refit</strong>: Logical option to refit model to entire training dataset sample and validation fitting. If grid parameters supplied, the best param set determined by validation sample performance will be used. Default is TRUE.</li>
<li><strong>save_submodels</strong>: logical flag to save sub model fits. Default is TRUE.</li>
<li><strong>dir</strong>: optional directory path for saving reports, data, and models</li>
<li><strong>seed</strong>: seed number for random computations. Seed should be set to ensure repeatability of results.</li>
</ul>
</div>
<div id="regresser" class="section level4">
<h4>Regresser</h4>
<p>In the following chunk the <code>regresser</code> constructor function can be see creating a modeler object internally with the <code>modeler</code> constructor, adding a default RMSE measure, and updated the class with the <code>structure</code> function. Note - <code>regressor</code> currently asserts a tbl_spark class data input due to the spark-ml backend and will error if a R data.frame is provided. The spark constraint is true for <code>classifier</code>, <code>multi-classifier</code>, and <code>segmenter</code> as well. Also note that a check is made to ensure that there isn’t an existing ‘index’ column name. The data sampling partitioning functionality use the variable ‘index’ to create a row index and filter.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># regressor constructor</span>
regressor
<span class="co">#&gt; function(df,</span>
<span class="co">#&gt;                       target,</span>
<span class="co">#&gt;                       name = NULL,</span>
<span class="co">#&gt;                       uid = NULL,</span>
<span class="co">#&gt;                       version = NULL,</span>
<span class="co">#&gt;                       desc = NULL,</span>
<span class="co">#&gt;                       scientist = NULL,</span>
<span class="co">#&gt;                       execution_strategy = &quot;sequential&quot;,</span>
<span class="co">#&gt;                       refit = TRUE,</span>
<span class="co">#&gt;                       save_submodels = TRUE,</span>
<span class="co">#&gt;                       dir = NULL,</span>
<span class="co">#&gt;                       seed = 319,</span>
<span class="co">#&gt;                       ...){</span>
<span class="co">#&gt;   checkmate::assert_subset(&quot;tbl_spark&quot;, class(df))</span>
<span class="co">#&gt;   checkmate::assert_false(&quot;index&quot; %in% colnames(df))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj &lt;- modeler(df,</span>
<span class="co">#&gt;                   target = target,</span>
<span class="co">#&gt;                   type = &quot;regressor&quot;,</span>
<span class="co">#&gt;                   name,</span>
<span class="co">#&gt;                   uid,</span>
<span class="co">#&gt;                   version,</span>
<span class="co">#&gt;                   desc,</span>
<span class="co">#&gt;                   scientist,</span>
<span class="co">#&gt;                   execution_strategy,</span>
<span class="co">#&gt;                   refit,</span>
<span class="co">#&gt;                   save_submodels,</span>
<span class="co">#&gt;                   dir)</span>
<span class="co">#&gt;   mobj &lt;- structure(mobj, class = c(&quot;regressor&quot;, class(mobj)))</span>
<span class="co">#&gt;   mobj &lt;- set_measure(mobj, RMSE)</span>
<span class="co">#&gt;   mobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="classifier" class="section level4">
<h4>Classifier</h4>
<p>Next is the <code>classifier</code> constructor. The function is very similiar to the <code>regressor</code> except now there are checks for a binary distribution of the target variable and AUC default measure.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Classifier Constructor</span>
classifier
<span class="co">#&gt; function(df,</span>
<span class="co">#&gt;                        target,</span>
<span class="co">#&gt;                        name = NULL,</span>
<span class="co">#&gt;                        uid = NULL,</span>
<span class="co">#&gt;                        version = NULL,</span>
<span class="co">#&gt;                        desc = NULL,</span>
<span class="co">#&gt;                        scientist = NULL,</span>
<span class="co">#&gt;                        execution_strategy = &quot;sequential&quot;,</span>
<span class="co">#&gt;                        refit = TRUE,</span>
<span class="co">#&gt;                        save_submodels = TRUE,</span>
<span class="co">#&gt;                        dir = NULL,</span>
<span class="co">#&gt;                        seed = 319,</span>
<span class="co">#&gt;                        ...){</span>
<span class="co">#&gt;   checkmate::assert_subset(&quot;tbl_spark&quot;, class(df))</span>
<span class="co">#&gt;   checkmate::assert_false(&quot;index&quot; %in% colnames(df))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Target Check</span>
<span class="co">#&gt;   target_dims &lt;- df %&gt;%</span>
<span class="co">#&gt;     dplyr::distinct(!!rlang::sym(target)) %&gt;%</span>
<span class="co">#&gt;     dplyr::collect() %&gt;%</span>
<span class="co">#&gt;     pull(!!rlang::sym(target))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(length(target_dims) != 2) {</span>
<span class="co">#&gt;     stop(paste(&quot;target not a binary distribution.\n  Has&quot;, target_dims, &quot;unique values&quot;))</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(! all(c(0,1) %in% target_dims)) {</span>
<span class="co">#&gt;     stop(&quot;binary target distribution not encoded as 0-1.\nPlease update to numeric with 0/1 values&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj &lt;- modeler(df,</span>
<span class="co">#&gt;                   target = target,</span>
<span class="co">#&gt;                   type = &quot;classifier&quot;,</span>
<span class="co">#&gt;                   name,</span>
<span class="co">#&gt;                   uid,</span>
<span class="co">#&gt;                   version,</span>
<span class="co">#&gt;                   desc,</span>
<span class="co">#&gt;                   scientist,</span>
<span class="co">#&gt;                   execution_strategy,</span>
<span class="co">#&gt;                   refit,</span>
<span class="co">#&gt;                   save_submodels,</span>
<span class="co">#&gt;                   dir,</span>
<span class="co">#&gt;                   seed)</span>
<span class="co">#&gt;   mobj &lt;- structure(mobj, class = c(&quot;classifier&quot;, class(mobj)))</span>
<span class="co">#&gt;   mobj &lt;- set_measure(mobj, AUC)</span>
<span class="co">#&gt;   mobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="multiclasifier" class="section level4">
<h4>Multiclasifier</h4>
<p>The <code>multiclassifier</code> constructor function is very similar to the <code>classifier</code> function. Now the checks are for a target variable with more than 2 unique values, and a F1 default measure.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Multiclassifier Constructor</span>
multiclassifier
<span class="co">#&gt; function(df,</span>
<span class="co">#&gt;                             target,</span>
<span class="co">#&gt;                             name = NULL,</span>
<span class="co">#&gt;                             uid = NULL,</span>
<span class="co">#&gt;                             version = NULL,</span>
<span class="co">#&gt;                             desc = NULL,</span>
<span class="co">#&gt;                             scientist = NULL,</span>
<span class="co">#&gt;                             execution_strategy = &quot;sequential&quot;,</span>
<span class="co">#&gt;                             refit = TRUE,</span>
<span class="co">#&gt;                             save_submodels = TRUE,</span>
<span class="co">#&gt;                             dir = NULL,</span>
<span class="co">#&gt;                             seed = 319,</span>
<span class="co">#&gt;                             ...){</span>
<span class="co">#&gt;   checkmate::assert_subset(&quot;tbl_spark&quot;, class(df))</span>
<span class="co">#&gt;   checkmate::assert_false(&quot;index&quot; %in% colnames(df))</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   # Target Check</span>
<span class="co">#&gt;   target_dims &lt;- df %&gt;%</span>
<span class="co">#&gt;     dplyr::distinct_(target) %&gt;%</span>
<span class="co">#&gt;     sparklyr::sdf_nrow()</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   if(target_dims == 2) {</span>
<span class="co">#&gt;     stop(paste(&quot;target is a binary distribution. Use a classifier instead&quot;))</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   if(target_dims &gt; 100) {</span>
<span class="co">#&gt;     warnings(&quot;target has over 100 unique values&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   mobj &lt;- modeler(df,</span>
<span class="co">#&gt;                   target = target,</span>
<span class="co">#&gt;                   type = &quot;multiclassifier&quot;,</span>
<span class="co">#&gt;                   name,</span>
<span class="co">#&gt;                   uid,</span>
<span class="co">#&gt;                   version,</span>
<span class="co">#&gt;                   desc,</span>
<span class="co">#&gt;                   scientist,</span>
<span class="co">#&gt;                   execution_strategy,</span>
<span class="co">#&gt;                   refit,</span>
<span class="co">#&gt;                   save_submodels,</span>
<span class="co">#&gt;                   dir,</span>
<span class="co">#&gt;                   seed)</span>
<span class="co">#&gt;   mobj &lt;- structure(mobj, class = c(&quot;multiclassifier&quot;, class(mobj)))</span>
<span class="co">#&gt;   mobj &lt;- set_measure(mobj, F1)</span>
<span class="co">#&gt;   mobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="segmenter" class="section level4">
<h4>Segmenter</h4>
<p>The <code>segmenter</code> function differs slightly in that there is no target variable (set as NULL) and with a Silhouette default measure.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Segmenter Constructor</span>
segmenter
<span class="co">#&gt; function(df,</span>
<span class="co">#&gt;                       name = NULL,</span>
<span class="co">#&gt;                       uid = NULL,</span>
<span class="co">#&gt;                       version = NULL,</span>
<span class="co">#&gt;                       desc = NULL,</span>
<span class="co">#&gt;                       scientist = NULL,</span>
<span class="co">#&gt;                       execution_strategy = &quot;sequential&quot;,</span>
<span class="co">#&gt;                       refit = TRUE,</span>
<span class="co">#&gt;                       save_submodels = TRUE,</span>
<span class="co">#&gt;                       dir = NULL,</span>
<span class="co">#&gt;                       seed = 319,</span>
<span class="co">#&gt;                       ...){</span>
<span class="co">#&gt;   checkmate::assert_subset(&quot;tbl_spark&quot;, class(df))</span>
<span class="co">#&gt;   checkmate::assert_false(&quot;index&quot; %in% colnames(df))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj &lt;- modeler(df,</span>
<span class="co">#&gt;                   target = NULL,</span>
<span class="co">#&gt;                   type = &quot;segmenter&quot;,</span>
<span class="co">#&gt;                   name,</span>
<span class="co">#&gt;                   uid,</span>
<span class="co">#&gt;                   version,</span>
<span class="co">#&gt;                   desc,</span>
<span class="co">#&gt;                   scientist,</span>
<span class="co">#&gt;                   execution_strategy,</span>
<span class="co">#&gt;                   refit,</span>
<span class="co">#&gt;                   save_submodels,</span>
<span class="co">#&gt;                   dir)</span>
<span class="co">#&gt;   sobj &lt;- structure(mobj, class = c(&quot;segmenter&quot;, class(mobj)))</span>
<span class="co">#&gt;   sobj &lt;- set_measure(sobj, Silhouette)</span>
<span class="co">#&gt;   sobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="forecaster" class="section level4">
<h4>Forecaster</h4>
<p>As can be seen below the <code>forecaster</code> constructor is the most different from the others. <code>Forecaster</code> is R data.frame based, and requries an explict index_var input. The index plays an important role - the data input to forecaster should have a sequential nature. This can either be date, datetime, or numerical based. If the index_var is either date or datetime an additional argument for the unit and frequency should be provided. These values are used to create an index object explained below. The index class allows for sequences to be extended for forecasting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Forecaster Constructor</span>
forecaster
<span class="co">#&gt; function(df,</span>
<span class="co">#&gt;                        target,</span>
<span class="co">#&gt;                        index_var,</span>
<span class="co">#&gt;                        unit = NULL,</span>
<span class="co">#&gt;                        frequency = NULL,</span>
<span class="co">#&gt;                        prediction_conf_levels = c(80, 95),</span>
<span class="co">#&gt;                        name = NULL,</span>
<span class="co">#&gt;                        uid = NULL,</span>
<span class="co">#&gt;                        version = NULL,</span>
<span class="co">#&gt;                        desc = NULL,</span>
<span class="co">#&gt;                        scientist = NULL,</span>
<span class="co">#&gt;                        execution_strategy = &quot;sequential&quot;,</span>
<span class="co">#&gt;                        refit = TRUE,</span>
<span class="co">#&gt;                        save_submodels = TRUE,</span>
<span class="co">#&gt;                        dir = NULL,</span>
<span class="co">#&gt;                        ...){</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   checkmate::assert_choice(index_var, colnames(df))</span>
<span class="co">#&gt;   checkmate::assert_numeric(frequency, lower = 1, null.ok = TRUE)</span>
<span class="co">#&gt;   checkmate::assert_numeric(prediction_conf_levels, lower = 50, upper = 100,</span>
<span class="co">#&gt;                             min.len = 1, max.len = 2)</span>
<span class="co">#&gt;   checkmate::assert_character(unit, null.ok = TRUE)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj &lt;- modeler(df,</span>
<span class="co">#&gt;                   target,</span>
<span class="co">#&gt;                   type = &quot;forecaster&quot;,</span>
<span class="co">#&gt;                   name,</span>
<span class="co">#&gt;                   uid,</span>
<span class="co">#&gt;                   version,</span>
<span class="co">#&gt;                   desc,</span>
<span class="co">#&gt;                   scientist,</span>
<span class="co">#&gt;                   execution_strategy,</span>
<span class="co">#&gt;                   refit,</span>
<span class="co">#&gt;                   save_submodels,</span>
<span class="co">#&gt;                   dir)</span>
<span class="co">#&gt;   mobj$index_var &lt;- index_var</span>
<span class="co">#&gt;   mobj$index &lt;- index(df[[index_var]], unit = unit)</span>
<span class="co">#&gt;   mobj$frequency &lt;- frequency</span>
<span class="co">#&gt;   mobj$conf_levels &lt;- prediction_conf_levels</span>
<span class="co">#&gt;   fobj &lt;- structure(mobj, class = c(&quot;forecaster&quot;, class(mobj)))</span>
<span class="co">#&gt;   fobj &lt;- set_measure(fobj, RMSE)</span>
<span class="co">#&gt;   fobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
</div>
<div id="add-samples" class="section level3">
<h3>Add Samples</h3>
<p>The <code>add_*_samples</code> functions add samples to the modeler object and have class specific methods. The <code>add_default_samples</code> modeler class method shown below does the following:</p>
<ul>
<li>creates a sample object with the data stored on the modeler object</li>
<li>adds the sample object to the sample slot</li>
<li>returns updated modeler object</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Add Default Sample to modeler object</span>
add_default_samples.modeler
<span class="co">#&gt; function(x){</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   default &lt;- add_default_samples(x$data)</span>
<span class="co">#&gt;   x$samples &lt;- default</span>
<span class="co">#&gt;   x</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The other <code>add_*_samples</code> modeler methods behave similarily. The numeric methods is where the sampling logic is located.</p>
<div id="samples-class" class="section level4">
<h4>Samples Class</h4>
<p>The samples class supports the creation of data samples for the purpose of model fitting and validating. There are several different types of sampling strategies - see the User-Guide for more details. For each of the a2modeler sampling strategies, a samples object is created with the <code>samples</code> constructor function with the following attributes:</p>
<ul>
<li><strong>validation_method</strong>: name of validation method. examples are holdout, cross-validation, etc…</li>
<li><strong>validation_args</strong>: list of arguments to pass to validation method</li>
<li><strong>test_holdout_prct</strong>: percent of total data records to use for test dataset</li>
<li><strong>downsample_prct</strong>: percent of total data to downsample and use for analysis</li>
<li><strong>train_indicies</strong>: list of numeric train indicies. each index contains numeric vector pertaining to row numbers to use for model fitting</li>
<li><strong>validation_indicies</strong>: list of numeric validation indicies. each index contains numeric vector pertaining to row numbers to use for model validation</li>
<li><strong>indicies_names</strong>: character vector of indicies names</li>
<li><strong>test_index</strong>: numeric index with records to use for model testing</li>
</ul>
<p>In the following chunk code for <code>add_default_samples</code> methods are shown. The data.frame and tbl_spark methods use the numeric method internally to reduce code duplication. The default sample is the simplest strategy and only a single row based indicie is saved in the train_indicies list.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># add_default_samples.numeric code</span>
add_default_samples.numeric
<span class="co">#&gt; function(x){</span>
<span class="co">#&gt;   samples(</span>
<span class="co">#&gt;     validation_method = &quot;none&quot;,</span>
<span class="co">#&gt;     validation_args = list(),</span>
<span class="co">#&gt;     test_holdout_prct = NULL,</span>
<span class="co">#&gt;     test_holdout_method = &quot;none&quot;,</span>
<span class="co">#&gt;     downsample_prct = NULL,</span>
<span class="co">#&gt;     train_indicies = list(default = x),</span>
<span class="co">#&gt;     validation_indicies = NULL,</span>
<span class="co">#&gt;     indicies_names = &quot;train&quot;,</span>
<span class="co">#&gt;     test_index = NULL</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># add_default_samples.data.frame code</span>
add_default_samples.data.frame
<span class="co">#&gt; function(x){</span>
<span class="co">#&gt;   z &lt;- 1:nrow(x)</span>
<span class="co">#&gt;   add_default_samples(z)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># add_default_samples.tbl_spk</span>
add_default_samples.tbl_spark
<span class="co">#&gt; function(x){</span>
<span class="co">#&gt;   z &lt;- 1:sparklyr::sdf_nrow(x)</span>
<span class="co">#&gt;   add_default_samples(z)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>Next is a set of methods for creating holdout samples. The numeric method creates train and validation row indicies based on the splits argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># add_holdout_samples.numeric code</span>
add_holdout_samples.numeric
<span class="co">#&gt; function(x, splits){</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   checkmate::assert_numeric(splits, lower = 0, upper = 1, min.len = 2, max.len = 3)</span>
<span class="co">#&gt;   if(sum(splits) != 1){</span>
<span class="co">#&gt;     stop(&quot;splits don't sum to 1. Recommend either an 80-20 or 60-20-20 split&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   if(length(splits) == 3){</span>
<span class="co">#&gt;     tv_total &lt;- sum(splits[-3])</span>
<span class="co">#&gt;     s1 &lt;- holdout(x, tv_total)</span>
<span class="co">#&gt;     test_index &lt;- s1$tail</span>
<span class="co">#&gt;     test_holdout_prct &lt;- splits[3]</span>
<span class="co">#&gt;   }else{</span>
<span class="co">#&gt;     test_index &lt;- NULL</span>
<span class="co">#&gt;     test_holdout_prct &lt;- NULL</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   s2 &lt;- holdout(x, splits[1])</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   train_indicies &lt;- list(holdout = s2$head)</span>
<span class="co">#&gt;   val_indicies &lt;- list(holdout = setdiff(s2$tail, test_index))</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   samples(</span>
<span class="co">#&gt;     validation_method = &quot;holdout&quot;,</span>
<span class="co">#&gt;     validation_args = list(split = splits[1]),</span>
<span class="co">#&gt;     test_holdout_prct = test_holdout_prct,</span>
<span class="co">#&gt;     test_holdout_method = &quot;holdout&quot;,</span>
<span class="co">#&gt;     downsample_prct = NULL,</span>
<span class="co">#&gt;     train_indicies = train_indicies,</span>
<span class="co">#&gt;     validation_indicies = val_indicies,</span>
<span class="co">#&gt;     indicies_names = &quot;holdout&quot;,</span>
<span class="co">#&gt;     test_index = test_index</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># add_holdout_samples.data.frame code</span>
add_holdout_samples.tbl_spark
<span class="co">#&gt; function(x, splits){</span>
<span class="co">#&gt;   z &lt;- 1:sparklyr::sdf_nrow(x)</span>
<span class="co">#&gt;   add_holdout_samples(z, splits)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># add_holdout_samples.data.frame code</span>
add_holdout_samples.tbl_spark
<span class="co">#&gt; function(x, splits){</span>
<span class="co">#&gt;   z &lt;- 1:sparklyr::sdf_nrow(x)</span>
<span class="co">#&gt;   add_holdout_samples(z, splits)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The concept here is that the sampling strategy is set once, creating indicies that control the data partitions for all down stream modeling fitting and evaluating. The samples object is saved in the modeler object and referenced internally for data partitioning. More on its implementation later on.</p>
<p>Each of the sampling strategies follows the same pattern shown above where the sampling logic is contained in the numeric method and the data.frame and tbl_spark methods simply create a row sequence and pass to internal numeric method.</p>
<div id="methods" class="section level5">
<h5>Methods</h5>
<p>The samples class has a few methods to extract specific attributes of a sample object:</p>
<ul>
<li><strong>get_train_samples</strong>: returns training indicies</li>
<li><strong>get_validation_samples</strong>: returns the validation indicies</li>
<li><strong>get_indicies</strong>: returns a list with an element for each train and validation indicies pairs</li>
</ul>
</div>
</div>
</div>
<div id="set-measures" class="section level3">
<h3>Set Measures</h3>
<p>The next step in the a2modeler workflow is to set the measure used to measure model performance on validation samples. The <code>set_measure</code> function does the following</p>
<ul>
<li>asserts proper classes</li>
<li>asserts measure is appropriate for use-case by checking measure properties</li>
<li>adds measure to modeler object</li>
<li>returns updated modeler object</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Set Measure</span>
set_measure
<span class="co">#&gt; function(obj, measure) {</span>
<span class="co">#&gt;   checkmate::assert_class(obj, &quot;modeler&quot;)</span>
<span class="co">#&gt;   checkmate::assert_class(measure, &quot;measure&quot;)</span>
<span class="co">#&gt;   checkmate::assert_subset(class(obj), measure$properties)</span>
<span class="co">#&gt;   obj$measure &lt;- measure</span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>As seen in the use case constructors, a default measure is set for each.</p>
<div id="measure-class" class="section level4">
<h4>Measure Class</h4>
<p>The measure class stores information on model measurement metrics. The a2modeler measure class was designed after similar named class in <a href="https://github.com/mlr-org/mlr/blob/master/R/Measure.R">mlr R package</a>. The measure class constructor stores the following attributes:</p>
<ul>
<li><strong>id</strong> name of measure ex - rmse</li>
<li><strong>name</strong> full name of measure. ex - mean squared error</li>
<li><strong>method</strong> name of measure method. method function differ based on class of input. Designed to be accommodate spark dataframes</li>
<li><strong>method_args</strong> list of additional arguments to pass to method</li>
<li><strong>properties</strong> measure’s applicable modeler classes</li>
<li><strong>minimize</strong> logical flag that minimizing the measure is optimal</li>
<li><strong>best</strong> best possible value for measure</li>
<li><strong>worst</strong> worst possible value for measure</li>
<li><strong>note</strong> additional notes for measure</li>
</ul>
<p>Several measure objects are created and shipped in the a2modeler package. Here are a few examples</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># RMSE Object</span>
<span class="kw">class</span>(RMSE)
<span class="co">#&gt; [1] &quot;measure&quot;</span>
<span class="kw">str</span>(RMSE)
<span class="co">#&gt; List of 9</span>
<span class="co">#&gt;  $ id         : chr &quot;RMSE&quot;</span>
<span class="co">#&gt;  $ method     : chr &quot;rmse&quot;</span>
<span class="co">#&gt;  $ method_args:List of 3</span>
<span class="co">#&gt;   ..$ : chr &quot;x&quot;</span>
<span class="co">#&gt;   ..$ : chr &quot;predicted&quot;</span>
<span class="co">#&gt;   ..$ : chr &quot;actual&quot;</span>
<span class="co">#&gt;  $ properties : chr [1:3] &quot;modeler&quot; &quot;regressor&quot; &quot;forecaster&quot;</span>
<span class="co">#&gt;  $ name       : chr &quot;Root mean squared error&quot;</span>
<span class="co">#&gt;  $ minimize   : logi TRUE</span>
<span class="co">#&gt;  $ best       : num 0</span>
<span class="co">#&gt;  $ worst      : num Inf</span>
<span class="co">#&gt;  $ note       : chr &quot;The RMSE is aggregated as sqrt(mean((predicted - actual)^2))&quot;</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr &quot;measure&quot;</span>


<span class="co"># AUC Object</span>
<span class="kw">class</span>(AUC)
<span class="co">#&gt; [1] &quot;measure&quot;</span>
<span class="kw">str</span>(AUC)
<span class="co">#&gt; List of 9</span>
<span class="co">#&gt;  $ id         : chr &quot;AUC&quot;</span>
<span class="co">#&gt;  $ method     : chr &quot;auc&quot;</span>
<span class="co">#&gt;  $ method_args:List of 3</span>
<span class="co">#&gt;   ..$ : chr &quot;x&quot;</span>
<span class="co">#&gt;   ..$ : chr &quot;predicted&quot;</span>
<span class="co">#&gt;   ..$ : chr &quot;actual&quot;</span>
<span class="co">#&gt;  $ properties : chr [1:2] &quot;modeler&quot; &quot;classifier&quot;</span>
<span class="co">#&gt;  $ name       : chr &quot;Area under the curve&quot;</span>
<span class="co">#&gt;  $ minimize   : logi FALSE</span>
<span class="co">#&gt;  $ best       : num 1</span>
<span class="co">#&gt;  $ worst      : num 0</span>
<span class="co">#&gt;  $ note       : chr &quot;Integral over the graph that results from computing false and true positive rates for many different thresholds.&quot;</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr &quot;measure&quot;</span></code></pre></div>
<p>Similar to the samples class, a measure class object is created and stored internally to the modeler object. All downstream model evaluation in modeler objects reference the measure object stored internally. The measure object does not store the function directly. It stores the function generic name which is can be used to get the function from the namespace environment and execute.</p>
<p>Adding a new method requires that the measure function (such as <code>rmse</code>) is either developed or supported in a2modeler. There are meaningful differences in implementation for R vs Spark objects as seen below for the <code>rmse</code> methods. The spark method leverages the sparklyr, spark-ml evaluator. The evaluator function approach is used to intregrate with the rest of the spark-ml functionality.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># R rmse method</span>
rmse.data.frame
<span class="co">#&gt; function(x, predicted, actual){</span>
<span class="co">#&gt;   checkmate::assert_choice(predicted, colnames(x))</span>
<span class="co">#&gt;   checkmate::assert_choice(actual, colnames(x))</span>
<span class="co">#&gt;   c(&quot;rmse&quot; = sqrt(mean((x[[predicted]] - x[[actual]])^2)))</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># Spark rmse method</span>
rmse.tbl_spark
<span class="co">#&gt; function(x, predicted, actual) {</span>
<span class="co">#&gt;   checkmate::assert_choice(predicted, colnames(x))</span>
<span class="co">#&gt;   checkmate::assert_choice(actual, colnames(x))</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   sparklyr::ml_regression_evaluator(</span>
<span class="co">#&gt;     x,</span>
<span class="co">#&gt;     label_col = actual,</span>
<span class="co">#&gt;     prediction_col = predicted,</span>
<span class="co">#&gt;     metric_name = &quot;rmse&quot;</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<div id="methods-1" class="section level5">
<h5>Methods</h5>
<p>There are only minor measure methods such as <code>print</code>, <code>set_measure</code>, and <code>get_measure</code></p>
</div>
</div>
</div>
<div id="add-model" class="section level3">
<h3>Add Model</h3>
<p>The <code>add_model</code> function creates a model object, and appends meta-data to the modeler object. It does not execute and model or pipeline code. As seen below the function does the following:</p>
<ul>
<li>asserts the method provided is one supported</li>
<li>creates default pipeline if not provided</li>
<li>adds the model pipeline to the modeler object pipeline list</li>
<li>creates new model object with ‘added’ status add adds to modeler object</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Add Model Function</span>
add_model
<span class="co">#&gt; function(obj,</span>
<span class="co">#&gt;                      pipe = NULL,</span>
<span class="co">#&gt;                      method,</span>
<span class="co">#&gt;                      param_map = list(),</span>
<span class="co">#&gt;                      ...,</span>
<span class="co">#&gt;                      desc = NULL,</span>
<span class="co">#&gt;                      uid = sparklyr::random_string(&quot;model&quot;)) {</span>
<span class="co">#&gt;   checkmate::assert_class(obj, &quot;modeler&quot;)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Check Method</span>
<span class="co">#&gt;   type_methods &lt;- model_methods %&gt;%</span>
<span class="co">#&gt;     dplyr::filter(type == obj$type) %&gt;%</span>
<span class="co">#&gt;     dplyr::pull(method) %&gt;%</span>
<span class="co">#&gt;     as.character()</span>
<span class="co">#&gt;   checkmate::assert_choice(method, type_methods)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Define pipeline</span>
<span class="co">#&gt;   if(is.null(pipe))</span>
<span class="co">#&gt;     pipe &lt;- pipeline()</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(! pipe$uid %in% names(obj$pipelines))</span>
<span class="co">#&gt;     obj$pipelines[[pipe$uid]] &lt;- pipe</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Create model object</span>
<span class="co">#&gt;   m &lt;- model(pipe = pipe$uid,</span>
<span class="co">#&gt;              target = obj$target,</span>
<span class="co">#&gt;              method = method,</span>
<span class="co">#&gt;              method_args = list(...),</span>
<span class="co">#&gt;              param_map = param_map,</span>
<span class="co">#&gt;              desc = desc,</span>
<span class="co">#&gt;              uid = uid)</span>
<span class="co">#&gt;   m$status &lt;- &quot;added&quot;</span>
<span class="co">#&gt;   m$index_var &lt;- obj$index_var</span>
<span class="co">#&gt;   obj$models[[m$uid]] &lt;- m</span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<table>
<caption>a2modeler Supported Model Methods</caption>
<thead>
<tr class="header">
<th align="left">type</th>
<th align="left">method</th>
<th align="left">name</th>
<th align="left">package</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">forecaster</td>
<td align="left">Arima</td>
<td align="left">Arima</td>
<td align="left">forecast</td>
</tr>
<tr class="even">
<td align="left">forecaster</td>
<td align="left">arfima</td>
<td align="left">Fractionally Differenced Arima</td>
<td align="left">forecast</td>
</tr>
<tr class="odd">
<td align="left">forecaster</td>
<td align="left">auto.arima</td>
<td align="left">Auto Arima</td>
<td align="left">forecast</td>
</tr>
<tr class="even">
<td align="left">forecaster</td>
<td align="left">bats</td>
<td align="left">ETS with boxcox, ARIMA errors, Trend and Seasonal</td>
<td align="left">forecast</td>
</tr>
<tr class="odd">
<td align="left">forecaster</td>
<td align="left">ets</td>
<td align="left">Exponentially Smoothing State Space</td>
<td align="left">forecast</td>
</tr>
<tr class="even">
<td align="left">forecaster</td>
<td align="left">nnetar</td>
<td align="left">Neural Network Time Series</td>
<td align="left">forecast</td>
</tr>
<tr class="odd">
<td align="left">forecaster</td>
<td align="left">tbats</td>
<td align="left">BATS with Trigonometric Seasonal</td>
<td align="left">forecast</td>
</tr>
<tr class="even">
<td align="left">forecaster</td>
<td align="left">auto_fourier</td>
<td align="left">Auto Fourier</td>
<td align="left">a2modeler</td>
</tr>
<tr class="odd">
<td align="left">segmenter</td>
<td align="left">ml_kmeans</td>
<td align="left">Spark ML K-Means</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">segmenter</td>
<td align="left">ml_bisecting_kmeans</td>
<td align="left">Spark ML Bisecting K-Means</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">segmenter</td>
<td align="left">ml_gaussian_mixture</td>
<td align="left">Spark ML Gaussian Mixture clustering</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">classifier</td>
<td align="left">ml_logistic_regression</td>
<td align="left">Spark ML Logistic Regression Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">classifier</td>
<td align="left">ml_naive_bayes</td>
<td align="left">Spark ML Naive Bayes Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">classifier</td>
<td align="left">ml_decision_tree_classifier</td>
<td align="left">Spark ML Decision Tree Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">classifier</td>
<td align="left">ml_gbt_classifier</td>
<td align="left">Spark ML Gradient Boosted Trees Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">classifier</td>
<td align="left">ml_random_forest_classifier</td>
<td align="left">Spark ML Random Forest Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">classifier</td>
<td align="left">ml_multilayer_perceptron_classifier</td>
<td align="left">Spark ML Multilayer Perceptron Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">multiclassifier</td>
<td align="left">ml_naive_bayes</td>
<td align="left">Spark ML Naive Bayes Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">multiclassifier</td>
<td align="left">ml_decision_tree_classifier</td>
<td align="left">Spark ML Decision Tree Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">multiclassifier</td>
<td align="left">ml_random_forest_classifier</td>
<td align="left">Spark ML Random Forest Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">multiclassifier</td>
<td align="left">ml_multilayer_perceptron_classifier</td>
<td align="left">Spark ML Multilayer Perceptron Classifier</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">regressor</td>
<td align="left">ml_linear_regression</td>
<td align="left">Spark ML Linear Regression</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">regressor</td>
<td align="left">ml_survial_regression</td>
<td align="left">Spark ML Survial Regression</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">regressor</td>
<td align="left">ml_generalized_linear_regression</td>
<td align="left">Spark ML Genalized Linear Regression</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">regressor</td>
<td align="left">ml_decision_tree_regressor</td>
<td align="left">Spark ML Decision Tree Regressor</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">regressor</td>
<td align="left">ml_gbt_regressor</td>
<td align="left">Spark ML Gradient Boosted Trees Regressor</td>
<td align="left">sparklyr</td>
</tr>
<tr class="odd">
<td align="left">regressor</td>
<td align="left">ml_random_forest_regressor</td>
<td align="left">Spark ML Random ForestRegressor</td>
<td align="left">sparklyr</td>
</tr>
<tr class="even">
<td align="left">regressor</td>
<td align="left">ml_multilayer_perceptron_regressor</td>
<td align="left">Spark ML Multilayer Perceptron Regressor</td>
<td align="left">sparklyr</td>
</tr>
</tbody>
</table>
<div id="pipeline-class" class="section level4">
<h4>Pipeline Class</h4>
<p>The pipeline class encapsulates data transformation logic to support repeatable feature generation in a2model developement. The pipeline object stores the transformation logic, some meta-data, and potentially pipeline output. Appending transformation output to the pipeline is useful for cases when that output is used more than once.</p>
<p>The pipeline class is created with the pipeline constructor</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Pipeline object</span>
pipeline
<span class="co">#&gt; function(expr = identity,</span>
<span class="co">#&gt;                      desc = NULL,</span>
<span class="co">#&gt;                      uid = sparklyr::random_string(&quot;pipe&quot;)) {</span>
<span class="co">#&gt;   if (is.null(desc))</span>
<span class="co">#&gt;     desc &lt;- &quot;&quot;</span>
<span class="co">#&gt;   a1 &lt;- Sys.time()</span>
<span class="co">#&gt;   new_pipeline(</span>
<span class="co">#&gt;     expr,</span>
<span class="co">#&gt;     output = NULL,</span>
<span class="co">#&gt;     desc,</span>
<span class="co">#&gt;     uid,</span>
<span class="co">#&gt;     created_on = a1,</span>
<span class="co">#&gt;     runtime = NULL</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>
p &lt;-<span class="st"> </span><span class="kw">pipeline</span>()
<span class="kw">str</span>(p)
<span class="co">#&gt; List of 6</span>
<span class="co">#&gt;  $ expr      :function (x)  </span>
<span class="co">#&gt;  $ output    : NULL</span>
<span class="co">#&gt;  $ desc      : chr &quot;&quot;</span>
<span class="co">#&gt;  $ uid       : chr &quot;pipe2ebce6070c1&quot;</span>
<span class="co">#&gt;  $ created_on: POSIXct[1:1], format: &quot;2018-12-10 11:50:16&quot;</span>
<span class="co">#&gt;  $ runtime   : NULL</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr &quot;pipeline&quot;</span></code></pre></div>
<p>The pipeline object stores the transformation logic as a function in the expr slot. This allows for the pipeline to be reused on different datasets.</p>
<p>One or more pipelines can be created and stored in a modeler object. They are stored as a named list of pipelines in the pipelines slot. The name is the pipeline uid. The reusability concept is useful internally to the modeler object so that models can share pipeline output (and not require duplicate execution and storage).</p>
<div id="methods-2" class="section level5">
<h5>Methods</h5>
<ul>
<li><strong>flow</strong>: apply pipeline expression on dataset. output not saved to pipeline</li>
<li><strong>execute</strong>: apply pipeline expression on dataset. output saved to pipeline</li>
<li><strong>test</strong>: apply pipeline expression on subset of data records</li>
<li><strong>clean</strong>: removes stored output from pipeline</li>
</ul>
</div>
</div>
<div id="model-class" class="section level4">
<h4>Model Class</h4>
<p>The model class is designed to be able to support different model backends. The model object stores information on the model’s pipeline (uid only), the target variable, model method, method arguments, parameter map, and some meta data. Model child classes are created to support specific model backend (package) behavior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Model Helpler</span>
model
<span class="co">#&gt; function(pipe,</span>
<span class="co">#&gt;                   target,</span>
<span class="co">#&gt;                   method,</span>
<span class="co">#&gt;                   method_args,</span>
<span class="co">#&gt;                   param_map,</span>
<span class="co">#&gt;                   desc = NULL,</span>
<span class="co">#&gt;                   uid = NULL) {</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if (is.null(desc)) desc &lt;- &quot;&quot;</span>
<span class="co">#&gt;   if (is.null(uid)) sparklyr::random_string(&quot;model&quot;)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   new_model(</span>
<span class="co">#&gt;     pipe = pipe,</span>
<span class="co">#&gt;     target = target,</span>
<span class="co">#&gt;     method = method,</span>
<span class="co">#&gt;     method_args = method_args,</span>
<span class="co">#&gt;     param_map = param_map,</span>
<span class="co">#&gt;     desc = desc,</span>
<span class="co">#&gt;     uid = uid,</span>
<span class="co">#&gt;     status = &quot;created&quot;,</span>
<span class="co">#&gt;     created_on = Sys.time()</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The model child class is assigned in the constructor below. A look up to the model_method dataset is made, the class extracted and assigned in the <code>structure</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Model Constructor</span>
new_model
<span class="co">#&gt; function(pipe,</span>
<span class="co">#&gt;                       target,</span>
<span class="co">#&gt;                       method,</span>
<span class="co">#&gt;                       method_args, </span>
<span class="co">#&gt;                       param_map,</span>
<span class="co">#&gt;                       desc,</span>
<span class="co">#&gt;                       uid,</span>
<span class="co">#&gt;                       status,</span>
<span class="co">#&gt;                       created_on</span>
<span class="co">#&gt; ) {</span>
<span class="co">#&gt;   checkmate::assert_character(pipe)</span>
<span class="co">#&gt;   checkmate::assert_character(target, null.ok = TRUE)</span>
<span class="co">#&gt;   checkmate::assert_choice(method, choices = model_methods$method)</span>
<span class="co">#&gt;   checkmate::assert_list(method_args, null.ok = TRUE)</span>
<span class="co">#&gt;   checkmate::assert_list(param_map)</span>
<span class="co">#&gt;   checkmate::assert_character(desc)</span>
<span class="co">#&gt;   checkmate::assert_character(uid)</span>
<span class="co">#&gt;   checkmate::assert_character(status)</span>
<span class="co">#&gt;   checkmate::assert_posixct(created_on)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   .method &lt;- method</span>
<span class="co">#&gt;   method_fun &lt;- model_methods %&gt;%</span>
<span class="co">#&gt;     dplyr::filter(method == .method) %&gt;%</span>
<span class="co">#&gt;     dplyr::pull(package) %&gt;%</span>
<span class="co">#&gt;     asNamespace() %&gt;%</span>
<span class="co">#&gt;     get(.method, .)</span>
<span class="co">#&gt;   method_params &lt;- setdiff(c(names(method_args), names(param_map)), &quot;uid&quot;)</span>
<span class="co">#&gt;   if(length(method_params) == 0) method_params &lt;- NULL</span>
<span class="co">#&gt;   checkmate::assert_function(method_fun, args = method_params)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   method_class &lt;- model_methods %&gt;%</span>
<span class="co">#&gt;     dplyr::filter(method == .method) %&gt;%</span>
<span class="co">#&gt;     tidyr::unnest(class) %&gt;%</span>
<span class="co">#&gt;     dplyr::pull(class) %&gt;%</span>
<span class="co">#&gt;     as.character()</span>
<span class="co">#&gt;   method_package &lt;- model_methods %&gt;%</span>
<span class="co">#&gt;     dplyr::filter(method == .method) %&gt;%</span>
<span class="co">#&gt;     dplyr::pull(package)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   structure(</span>
<span class="co">#&gt;     list(</span>
<span class="co">#&gt;       pipe = pipe,</span>
<span class="co">#&gt;       target = target,</span>
<span class="co">#&gt;       method = method,</span>
<span class="co">#&gt;       method_args = method_args,</span>
<span class="co">#&gt;       param_map = param_map,</span>
<span class="co">#&gt;       package = method_package,</span>
<span class="co">#&gt;       desc = desc,</span>
<span class="co">#&gt;       uid = uid,</span>
<span class="co">#&gt;       created_on = created_on,</span>
<span class="co">#&gt;       status = status</span>
<span class="co">#&gt;     ),</span>
<span class="co">#&gt;     class = c(method_class, &quot;model&quot;)</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
</div>
<div id="train-models" class="section level3">
<h3>Train Models</h3>
<p>The <code>train_models</code> function does most of the heavy lifting in the workflow. The <code>train_models</code> function is responsible for:</p>
<ul>
<li>executing all of the pipelines</li>
<li>partitioning the samples</li>
<li>fitting all models to the training samples</li>
<li>measuring model performance on validation samples</li>
</ul>
<p>Full modeler class method</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Parent Modeler class method</span>
train_models.modeler
<span class="co">#&gt; function(obj, uids = NULL, ...) {</span>
<span class="co">#&gt;   checkmate::assert_character(uids, null.ok = TRUE)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Execute pipes</span>
<span class="co">#&gt;   obj &lt;- execute_pipelines(obj)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if (is.null(uids)) {</span>
<span class="co">#&gt;     # Get Added only Models</span>
<span class="co">#&gt;     uids &lt;- obj$models %&gt;%</span>
<span class="co">#&gt;       purrr::map_df(., magrittr::extract, c(&quot;uid&quot;, &quot;status&quot;)) %&gt;%</span>
<span class="co">#&gt;       dplyr::filter(status == &quot;added&quot;) %&gt;%</span>
<span class="co">#&gt;       dplyr::pull(uid)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   for (uid in uids) {</span>
<span class="co">#&gt;     </span>
<span class="co">#&gt;     # Get Training Sample</span>
<span class="co">#&gt;     train_data &lt;- obj$pipelines[[obj$models[[uid]]$pipe]]$output</span>
<span class="co">#&gt;     </span>
<span class="co">#&gt;     # Check for holdout</span>
<span class="co">#&gt;     if (!is.null(obj$samples$test_holdout_prct)) {</span>
<span class="co">#&gt;       train_data &lt;- train_data %&gt;%</span>
<span class="co">#&gt;         dplyr::mutate(rn = 1) %&gt;% </span>
<span class="co">#&gt;         dplyr::mutate(rn = row_number(rn)) %&gt;% </span>
<span class="co">#&gt;         dplyr::filter(! rn %in% obj$samples$test_index) %&gt;%</span>
<span class="co">#&gt;         dplyr::select(-rn)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     </span>
<span class="co">#&gt;     obj$models[[uid]] &lt;- train_model(mobj = obj$models[[uid]],</span>
<span class="co">#&gt;                                      data = train_data,</span>
<span class="co">#&gt;                                      measure = obj$measure,</span>
<span class="co">#&gt;                                      samples = obj$samples,</span>
<span class="co">#&gt;                                      save_submodels = obj$save_submodels,</span>
<span class="co">#&gt;                                      execution_strategy = obj$execution_strategy,</span>
<span class="co">#&gt;                                      level = obj$conf_levels,</span>
<span class="co">#&gt;                                      seed = obj$seed)</span>
<span class="co">#&gt;     obj$models[[uid]]$features &lt;- setdiff(colnames(train_data), c(obj$target, obj$index_var))</span>
<span class="co">#&gt;     obj$models[[uid]]$status &lt;- &quot;trained&quot;</span>
<span class="co">#&gt;     obj$models[[uid]]$last_updated &lt;- Sys.time()</span>
<span class="co">#&gt;     obj$performance &lt;- dplyr::bind_rows(</span>
<span class="co">#&gt;       obj$performance,</span>
<span class="co">#&gt;       obj$models[[uid]]$performance %&gt;% </span>
<span class="co">#&gt;         dplyr::mutate(model_uid = uid,</span>
<span class="co">#&gt;                       pipeline_uid = obj$models[[uid]]$pipe,</span>
<span class="co">#&gt;                       method = obj$models[[uid]]$method) %&gt;% </span>
<span class="co">#&gt;         dplyr::select(model_uid, pipeline_uid, submodel_uid, sample, method, param_grid, !!obj$measure$method)</span>
<span class="co">#&gt;     )</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The first step is execute all the pipelines</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
train_models.modeler &lt;-<span class="st"> </span><span class="cf">function</span>(obj, <span class="dt">uids =</span> <span class="ot">NULL</span>, ...) {
  checkmate<span class="op">::</span><span class="kw">assert_character</span>(uids, <span class="dt">null.ok =</span> <span class="ot">TRUE</span>)
  
  <span class="co"># Execute pipes</span>
  obj &lt;-<span class="st"> </span><span class="kw">execute_pipelines</span>(obj)</code></pre></div>
<p>The <code>execute_pipelines</code> function is descriptive - it calls the <code>execute</code> function on all un-excuted pipelines saved in the modeler object. Recall execute will save the pipeline output to the output slot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">execute_pipelines.modeler
<span class="co">#&gt; function(obj, uids = NULL, ...) {</span>
<span class="co">#&gt;   checkmate::assert_character(uids, null.ok = TRUE)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if (is.null(uids))</span>
<span class="co">#&gt;     uids &lt;- names(obj$pipelines)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   for(uid in uids) {</span>
<span class="co">#&gt;     pipe &lt;- obj$pipelines[[uid]]</span>
<span class="co">#&gt;     if(is.null(pipe$output))</span>
<span class="co">#&gt;       obj$pipelines[[uid]] &lt;- execute(obj$data, obj$pipelines[[uid]])</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The next step is to get the model uids to be trained by extracting the status and filtering to only models with “added” status.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="cf">if</span> (<span class="kw">is.null</span>(uids)) {
    <span class="co"># Get Added only Models</span>
    uids &lt;-<span class="st"> </span>obj<span class="op">$</span>models <span class="op">%&gt;%</span>
<span class="st">      </span>purrr<span class="op">::</span><span class="kw">map_df</span>(., magrittr<span class="op">::</span>extract, <span class="kw">c</span>(<span class="st">&quot;uid&quot;</span>, <span class="st">&quot;status&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">      </span>dplyr<span class="op">::</span><span class="kw">filter</span>(status <span class="op">==</span><span class="st"> &quot;added&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">      </span>dplyr<span class="op">::</span><span class="kw">pull</span>(uid)
  }</code></pre></div>
<p>Next for each model uid the training sample is generated. To clarify this training samples has yet to be split into specific train and validation partitions. The code below illustrates the data is filtered based on sample indices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">

 <span class="cf">for</span> (uid <span class="cf">in</span> uids) {
    
    <span class="co"># Get Training Sample</span>
    train_data &lt;-<span class="st"> </span>obj<span class="op">$</span>pipelines[[obj<span class="op">$</span>models[[uid]]<span class="op">$</span>pipe]]<span class="op">$</span>output
    
    <span class="co"># Check for holdout</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(obj<span class="op">$</span>samples<span class="op">$</span>test_holdout_prct)) {
      train_data &lt;-<span class="st"> </span>train_data <span class="op">%&gt;%</span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">rn =</span> <span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">rn =</span> <span class="kw">row_number</span>(rn)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">filter</span>(<span class="op">!</span><span class="st"> </span>rn <span class="op">%in%</span><span class="st"> </span>obj<span class="op">$</span>samples<span class="op">$</span>test_index) <span class="op">%&gt;%</span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">select</span>(<span class="op">-</span>rn)
    }</code></pre></div>
<p>The next step is the train a single model uid with the <code>train_model</code> function. The <code>train_model</code> has methods for specific modeling backends and discussed indepth in the following sections. The model output from the train_model function is stored on the modeler model list and the model performance is added to the consolidated modeler performance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
    obj<span class="op">$</span>models[[uid]] &lt;-<span class="st"> </span><span class="kw">train_model</span>(<span class="dt">mobj =</span> obj<span class="op">$</span>models[[uid]],
                                     <span class="dt">data =</span> train_data,
                                     <span class="dt">measure =</span> obj<span class="op">$</span>measure,
                                     <span class="dt">samples =</span> obj<span class="op">$</span>samples,
                                     <span class="dt">save_submodels =</span> obj<span class="op">$</span>save_submodels,
                                     <span class="dt">execution_strategy =</span> obj<span class="op">$</span>execution_strategy,
                                     <span class="dt">level =</span> obj<span class="op">$</span>conf_levels,
                                     <span class="dt">seed =</span> obj<span class="op">$</span>seed)
    obj<span class="op">$</span>models[[uid]]<span class="op">$</span>features &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">colnames</span>(train_data), <span class="kw">c</span>(obj<span class="op">$</span>target, obj<span class="op">$</span>index_var))
    obj<span class="op">$</span>models[[uid]]<span class="op">$</span>status &lt;-<span class="st"> &quot;trained&quot;</span>
    obj<span class="op">$</span>models[[uid]]<span class="op">$</span>last_updated &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
    obj<span class="op">$</span>performance &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw">bind_rows</span>(
      obj<span class="op">$</span>performance,
      obj<span class="op">$</span>models[[uid]]<span class="op">$</span>performance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">model_uid =</span> uid,
                      <span class="dt">pipeline_uid =</span> obj<span class="op">$</span>models[[uid]]<span class="op">$</span>pipe,
                      <span class="dt">method =</span> obj<span class="op">$</span>models[[uid]]<span class="op">$</span>method) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">        </span>dplyr<span class="op">::</span><span class="kw">select</span>(model_uid, pipeline_uid, submodel_uid, sample, method, param_grid, <span class="op">!!</span>obj<span class="op">$</span>measure<span class="op">$</span>method)
    )</code></pre></div>
<div id="train-model" class="section level4">
<h4>Train Model</h4>
<p>The <code>train_model</code> function has class specific methods that correspond to the model backend. The <code>train_model.spark_model</code> method for spark_model class (spark-ml) leverages the functionality provided in spark version 2.3.0.</p>
<div id="spark-train-model" class="section level5">
<h5>Spark Train Model</h5>
<p>The following is the spark_model based method. We breakdown each section next</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># train_model.spark_model</span>
train_model.spark_model
<span class="co">#&gt; function(mobj,</span>
<span class="co">#&gt;                                     data,</span>
<span class="co">#&gt;                                     measure,</span>
<span class="co">#&gt;                                     samples,</span>
<span class="co">#&gt;                                     save_submodels,</span>
<span class="co">#&gt;                                     execution_strategy,</span>
<span class="co">#&gt;                                     seed,</span>
<span class="co">#&gt;                                     ...) {</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   checkmate::assert_class(data, &quot;tbl_spark&quot;)</span>
<span class="co">#&gt;   checkmate::assert_class(measure, &quot;measure&quot;)</span>
<span class="co">#&gt;   checkmate::assert_class(samples, &quot;samples&quot;)</span>
<span class="co">#&gt;   checkmate::assert_logical(save_submodels)</span>
<span class="co">#&gt;   checkmate::assert_choice(execution_strategy,</span>
<span class="co">#&gt;                            c(&quot;sequential&quot;, &quot;transparent&quot;, &quot;multisession&quot;, &quot;multicore&quot;,</span>
<span class="co">#&gt;                              &quot;multiprocess&quot;, &quot;cluster&quot;, &quot;remote&quot;))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Get Spark connection</span>
<span class="co">#&gt;   sc &lt;- sparklyr::spark_connection(data)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set method fun</span>
<span class="co">#&gt;   method_fun &lt;- get(mobj$method, asNamespace(mobj$package))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Perceptron Check</span>
<span class="co">#&gt;   if(grepl(&quot;ml_multilayer_perceptron&quot;, mobj$method)) {</span>
<span class="co">#&gt;     if(is.null(mobj$method_args$layers)) {</span>
<span class="co">#&gt;       stop(&quot;method arguments missing layers&quot;)</span>
<span class="co">#&gt;     } else {</span>
<span class="co">#&gt;       layers &lt;- mobj$method_args$layers</span>
<span class="co">#&gt;       nfeatures &lt;- sparklyr::sdf_ncol(data) - 1</span>
<span class="co">#&gt;       if(layers[1] != nfeatures) {</span>
<span class="co">#&gt;         stop(paste(&quot;input layer size&quot;, layers[1],</span>
<span class="co">#&gt;                    &quot;doesn't equal feature size&quot;, nfeatures))</span>
<span class="co">#&gt;       }</span>
<span class="co">#&gt;       if(&quot;spark_model_classification&quot; %in% class(mobj) &amp;</span>
<span class="co">#&gt;          layers[length(layers)] != 2) {</span>
<span class="co">#&gt;         stop(paste(&quot;output layer size&quot;, layers[length(layers)],</span>
<span class="co">#&gt;                    &quot;should be 2 for classifaction models&quot;))</span>
<span class="co">#&gt;       }</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Create validator pipeline</span>
<span class="co">#&gt;   val_pipe &lt;- sparklyr::ml_pipeline(sc) %&gt;%</span>
<span class="co">#&gt;     sparklyr::ft_r_formula(paste(mobj$target, &quot;~.&quot;)) %&gt;%</span>
<span class="co">#&gt;     method_fun(uid = mobj$uid, layers = mobj$method_args$layers)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set Validator</span>
<span class="co">#&gt;   if (samples$validation_method == &quot;cross_validation&quot;) {</span>
<span class="co">#&gt;     validator_fun &lt;- get(&quot;ml_cross_validator&quot;, asNamespace(&quot;sparklyr&quot;))</span>
<span class="co">#&gt;     validator_args &lt;- list(num_folds = samples$validation_args$folds)</span>
<span class="co">#&gt;   } else{</span>
<span class="co">#&gt;     validator_fun &lt;- get(&quot;ml_train_validation_split&quot;, asNamespace(&quot;sparklyr&quot;))</span>
<span class="co">#&gt;     if (samples$validation_method == &quot;holdout&quot;) {</span>
<span class="co">#&gt;       validator_args &lt;- list(train_ratio = samples$validation_args$split)</span>
<span class="co">#&gt;     } else {</span>
<span class="co">#&gt;       validator_args &lt;- list(train_ratio = 0.99)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set Evaluator</span>
<span class="co">#&gt;   measure_fun &lt;- match.fun(measure$method)</span>
<span class="co">#&gt;   evaluator &lt;- measure_fun(sc)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set param_map</span>
<span class="co">#&gt;   if (length(mobj$param_map) == 0) {</span>
<span class="co">#&gt;     method_args &lt;- formals(method_fun)</span>
<span class="co">#&gt;     param_map &lt;- method_args[setdiff(names(method_args),  c(&quot;x&quot;, &quot;formula&quot;, &quot;layers&quot;))][1]</span>
<span class="co">#&gt;   } else{</span>
<span class="co">#&gt;     param_map &lt;- mobj$param_map</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   param_map &lt;- list(param_map)</span>
<span class="co">#&gt;   names(param_map) &lt;- mobj$uid</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set parallelism</span>
<span class="co">#&gt;   if (execution_strategy == &quot;sequential&quot;) {</span>
<span class="co">#&gt;     cores = 1L</span>
<span class="co">#&gt;   } else {</span>
<span class="co">#&gt;     cores = future::availableCores() %&gt;%</span>
<span class="co">#&gt;       as.integer()</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set Validator args</span>
<span class="co">#&gt;   validator_args &lt;- c(</span>
<span class="co">#&gt;     validator_args,</span>
<span class="co">#&gt;     list(</span>
<span class="co">#&gt;       x = data,</span>
<span class="co">#&gt;       estimator = val_pipe,</span>
<span class="co">#&gt;       estimator_param_maps = param_map,</span>
<span class="co">#&gt;       evaluator = evaluator,</span>
<span class="co">#&gt;       collect_sub_models = save_submodels,</span>
<span class="co">#&gt;       parallelism = cores,</span>
<span class="co">#&gt;       uid = &quot;validator&quot;,</span>
<span class="co">#&gt;       seed = seed</span>
<span class="co">#&gt;     )</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Execute Validator</span>
<span class="co">#&gt;   validator &lt;- do.call(validator_fun, validator_args)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Extract Objects</span>
<span class="co">#&gt;   n_sub_models &lt;- length(validator$param_map$estimatorParamMaps)</span>
<span class="co">#&gt;   sub_model_uids &lt;- purrr::map_chr(1:n_sub_models, ~ sparklyr::random_string(&quot;submodel&quot;))</span>
<span class="co">#&gt;   if (save_submodels) {</span>
<span class="co">#&gt;     sub_models &lt;- sparklyr::ml_sub_models(validator)</span>
<span class="co">#&gt;     if (samples$validation_method == &quot;cross_validation&quot;) {</span>
<span class="co">#&gt;       sub_models &lt;- purrr::transpose(sub_models)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     names(sub_models) &lt;- sub_model_uids</span>
<span class="co">#&gt;     mobj$sub_models &lt;- sub_models</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj$performance &lt;- sparklyr::ml_validation_metrics(validator) %&gt;%</span>
<span class="co">#&gt;     tibble::as.tibble() %&gt;%</span>
<span class="co">#&gt;     dplyr::mutate(rn = 1:n()) %&gt;% </span>
<span class="co">#&gt;     tidyr::nest(!!names(.)[-c(1, length(names(.)))], .key = &quot;param_grid&quot;) %&gt;% </span>
<span class="co">#&gt;     dplyr::rename(!!measure$method := !!names(.)[1]) %&gt;% </span>
<span class="co">#&gt;     dplyr::mutate(submodel_uid = sub_model_uids, sample = &quot;validation&quot;) %&gt;%</span>
<span class="co">#&gt;     dplyr::select(submodel_uid, sample, !!measure$method,  param_grid)</span>
<span class="co">#&gt;   mobj$fit &lt;- validator$best_model</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>In the first part of the method, basic assertions are made about the inputs, a spark connection is extracted from the data input, and the model method is extracted and assigned.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">train_model.spark_model &lt;-<span class="st"> </span><span class="cf">function</span>(mobj,
                                    data,
                                    measure,
                                    samples,
                                    save_submodels,
                                    execution_strategy,
                                    seed,
                                    ...) {
  
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(data, <span class="st">&quot;tbl_spark&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(measure, <span class="st">&quot;measure&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(samples, <span class="st">&quot;samples&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_logical</span>(save_submodels)
  checkmate<span class="op">::</span><span class="kw">assert_choice</span>(execution_strategy,
                           <span class="kw">c</span>(<span class="st">&quot;sequential&quot;</span>, <span class="st">&quot;transparent&quot;</span>, <span class="st">&quot;multisession&quot;</span>, <span class="st">&quot;multicore&quot;</span>,
                             <span class="st">&quot;multiprocess&quot;</span>, <span class="st">&quot;cluster&quot;</span>, <span class="st">&quot;remote&quot;</span>))
  
  <span class="co"># Get Spark connection</span>
  sc &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">spark_connection</span>(data)
  
  <span class="co"># Set method fun</span>
  method_fun &lt;-<span class="st"> </span><span class="kw">get</span>(mobj<span class="op">$</span>method, <span class="kw">asNamespace</span>(mobj<span class="op">$</span>package))</code></pre></div>
<p>In the next section, a hack is made for using the spark-ml neural net functions. They require a valid layers input that is made seperately from the param_map</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Perceptron Check</span>
  <span class="cf">if</span>(<span class="kw">grepl</span>(<span class="st">&quot;ml_multilayer_perceptron&quot;</span>, mobj<span class="op">$</span>method)) {
    <span class="cf">if</span>(<span class="kw">is.null</span>(mobj<span class="op">$</span>method_args<span class="op">$</span>layers)) {
      <span class="kw">stop</span>(<span class="st">&quot;method arguments missing layers&quot;</span>)
    } <span class="cf">else</span> {
      layers &lt;-<span class="st"> </span>mobj<span class="op">$</span>method_args<span class="op">$</span>layers
      nfeatures &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">sdf_ncol</span>(data) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
      <span class="cf">if</span>(layers[<span class="dv">1</span>] <span class="op">!=</span><span class="st"> </span>nfeatures) {
        <span class="kw">stop</span>(<span class="kw">paste</span>(<span class="st">&quot;input layer size&quot;</span>, layers[<span class="dv">1</span>],
                   <span class="st">&quot;doesn't equal feature size&quot;</span>, nfeatures))
      }
      <span class="cf">if</span>(<span class="st">&quot;spark_model_classification&quot;</span> <span class="op">%in%</span><span class="st"> </span><span class="kw">class</span>(mobj) <span class="op">&amp;</span>
<span class="st">         </span>layers[<span class="kw">length</span>(layers)] <span class="op">!=</span><span class="st"> </span><span class="dv">2</span>) {
        <span class="kw">stop</span>(<span class="kw">paste</span>(<span class="st">&quot;output layer size&quot;</span>, layers[<span class="kw">length</span>(layers)],
                   <span class="st">&quot;should be 2 for classifaction models&quot;</span>))
      }
    }
  }
  </code></pre></div>
<p>Next, a simple <a href="https://spark.rstudio.com/guides/pipelines/">validator pipeline</a> is created which amounts to the model formula. Note - the formula uses all variables in the data provided. Selecting variables to a subset needs to be done in the model pipeline. The model takes what’s given to it by the pipeline.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create validator pipeline</span>
  val_pipe &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">ml_pipeline</span>(sc) <span class="op">%&gt;%</span>
<span class="st">    </span>sparklyr<span class="op">::</span><span class="kw">ft_r_formula</span>(<span class="kw">paste</span>(mobj<span class="op">$</span>target, <span class="st">&quot;~.&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">method_fun</span>(<span class="dt">uid =</span> mobj<span class="op">$</span>uid, <span class="dt">layers =</span> mobj<span class="op">$</span>method_args<span class="op">$</span>layers)</code></pre></div>
<p>In the next step the validator function and arguments are configured. The options are holdout or cross validation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># Set Validator</span>
  <span class="cf">if</span> (samples<span class="op">$</span>validation_method <span class="op">==</span><span class="st"> &quot;cross_validation&quot;</span>) {
    validator_fun &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="st">&quot;ml_cross_validator&quot;</span>, <span class="kw">asNamespace</span>(<span class="st">&quot;sparklyr&quot;</span>))
    validator_args &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">num_folds =</span> samples<span class="op">$</span>validation_args<span class="op">$</span>folds)
  } <span class="cf">else</span>{
    validator_fun &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="st">&quot;ml_train_validation_split&quot;</span>, <span class="kw">asNamespace</span>(<span class="st">&quot;sparklyr&quot;</span>))
    <span class="cf">if</span> (samples<span class="op">$</span>validation_method <span class="op">==</span><span class="st"> &quot;holdout&quot;</span>) {
      validator_args &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">train_ratio =</span> samples<span class="op">$</span>validation_args<span class="op">$</span>split)
    } <span class="cf">else</span> {
      validator_args &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">train_ratio =</span> <span class="fl">0.99</span>)
    }
  }
  </code></pre></div>
<p>Next the <a href="https://spark.apache.org/docs/1.6.1/api/java/org/apache/spark/ml/evaluation/RegressionEvaluator.html">evaluator</a> is set by extracting the measurement method from the measure object. The method arguments are extracted from the param_map and formatted for the validator input. Then the parallel options are set based on the modeler execution strategy</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Set Evaluator</span>
  measure_fun &lt;-<span class="st"> </span><span class="kw">match.fun</span>(measure<span class="op">$</span>method)
  evaluator &lt;-<span class="st"> </span><span class="kw">measure_fun</span>(sc)
  
  
  <span class="co"># Set param_map</span>
  <span class="cf">if</span> (<span class="kw">length</span>(mobj<span class="op">$</span>param_map) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    method_args &lt;-<span class="st"> </span><span class="kw">formals</span>(method_fun)
    param_map &lt;-<span class="st"> </span>method_args[<span class="kw">setdiff</span>(<span class="kw">names</span>(method_args),  <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;formula&quot;</span>, <span class="st">&quot;layers&quot;</span>))][<span class="dv">1</span>]
  } <span class="cf">else</span>{
    param_map &lt;-<span class="st"> </span>mobj<span class="op">$</span>param_map
  }
  param_map &lt;-<span class="st"> </span><span class="kw">list</span>(param_map)
  <span class="kw">names</span>(param_map) &lt;-<span class="st"> </span>mobj<span class="op">$</span>uid
  
  
  <span class="co"># Set parallelism</span>
  <span class="cf">if</span> (execution_strategy <span class="op">==</span><span class="st"> &quot;sequential&quot;</span>) {
    cores =<span class="st"> </span>1L
  } <span class="cf">else</span> {
    cores =<span class="st"> </span>future<span class="op">::</span><span class="kw">availableCores</span>() <span class="op">%&gt;%</span>
<span class="st">      </span><span class="kw">as.integer</span>()
  }
  </code></pre></div>
<p>Next the validator args are consolidated and passed to the validator function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Set Validator args</span>
  validator_args &lt;-<span class="st"> </span><span class="kw">c</span>(
    validator_args,
    <span class="kw">list</span>(
      <span class="dt">x =</span> data,
      <span class="dt">estimator =</span> val_pipe,
      <span class="dt">estimator_param_maps =</span> param_map,
      <span class="dt">evaluator =</span> evaluator,
      <span class="dt">collect_sub_models =</span> save_submodels,
      <span class="dt">parallelism =</span> cores,
      <span class="dt">uid =</span> <span class="st">&quot;validator&quot;</span>,
      <span class="dt">seed =</span> seed
    )
  )
  
  
  <span class="co"># Execute Validator</span>
  validator &lt;-<span class="st"> </span><span class="kw">do.call</span>(validator_fun, validator_args)</code></pre></div>
<p>Lastly the key objects are extracted from the validator and stored in the modeler object including the validation measurement. The best model is saved at the fit slot where the submodels are stored in a nested list within the model object at the sub_models slot. The model performance is extracted, formatted, and stored on the model object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Extract Objects</span>
  n_sub_models &lt;-<span class="st"> </span><span class="kw">length</span>(validator<span class="op">$</span>param_map<span class="op">$</span>estimatorParamMaps)
  sub_model_uids &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">map_chr</span>(<span class="dv">1</span><span class="op">:</span>n_sub_models, <span class="op">~</span><span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">random_string</span>(<span class="st">&quot;submodel&quot;</span>))
  <span class="cf">if</span> (save_submodels) {
    sub_models &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">ml_sub_models</span>(validator)
    <span class="cf">if</span> (samples<span class="op">$</span>validation_method <span class="op">==</span><span class="st"> &quot;cross_validation&quot;</span>) {
      sub_models &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">transpose</span>(sub_models)
    }
    <span class="kw">names</span>(sub_models) &lt;-<span class="st"> </span>sub_model_uids
    mobj<span class="op">$</span>sub_models &lt;-<span class="st"> </span>sub_models
  }
  
  mobj<span class="op">$</span>performance &lt;-<span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">ml_validation_metrics</span>(validator) <span class="op">%&gt;%</span>
<span class="st">    </span>tibble<span class="op">::</span><span class="kw">as.tibble</span>() <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">rn =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">n</span>()) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>tidyr<span class="op">::</span><span class="kw">nest</span>(<span class="op">!!</span><span class="kw">names</span>(.)[<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="kw">length</span>(<span class="kw">names</span>(.)))], <span class="dt">.key =</span> <span class="st">&quot;param_grid&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">rename</span>(<span class="op">!!</span>measure<span class="op">$</span>method <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="op">!!</span><span class="kw">names</span>(.)[<span class="dv">1</span>]) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">submodel_uid =</span> sub_model_uids, <span class="dt">sample =</span> <span class="st">&quot;validation&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">select</span>(submodel_uid, sample, <span class="op">!!</span>measure<span class="op">$</span>method,  param_grid)
  mobj<span class="op">$</span>fit &lt;-<span class="st"> </span>validator<span class="op">$</span>best_model
  
  mobj</code></pre></div>
</div>
<div id="forecast-r-train-model" class="section level5">
<h5>Forecast R Train Model</h5>
<p>In this section the Forecast Model <code>train_model</code> method is described. Here the logic is much more explicit.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># train_model.forecaster_model</span>
train_model.forecast_model
<span class="co">#&gt; function(mobj, </span>
<span class="co">#&gt;                                        data,</span>
<span class="co">#&gt;                                        measure,</span>
<span class="co">#&gt;                                        samples,</span>
<span class="co">#&gt;                                        save_submodels,</span>
<span class="co">#&gt;                                        execution_strategy,</span>
<span class="co">#&gt;                                        level,</span>
<span class="co">#&gt;                                        ...){</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   checkmate::assert_class(data, &quot;data.frame&quot;)</span>
<span class="co">#&gt;   checkmate::assert_class(measure, &quot;measure&quot;)</span>
<span class="co">#&gt;   checkmate::assert_class(samples, &quot;samples&quot;)</span>
<span class="co">#&gt;   checkmate::assert_logical(save_submodels)</span>
<span class="co">#&gt;   checkmate::assert_numeric(level, max.len = 2, upper = 100)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set Execution Strategy</span>
<span class="co">#&gt;   future::plan(execution_strategy)</span>
<span class="co">#&gt;   doFuture::registerDoFuture()</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Set model function</span>
<span class="co">#&gt;   model_fun &lt;- get(mobj$method, asNamespace(mobj$package))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Get Indicies</span>
<span class="co">#&gt;   indicies &lt;- get_indicies(samples)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Submodel grid</span>
<span class="co">#&gt;   submodel_grid &lt;- data.frame(expand.grid(c(mobj$method_args,</span>
<span class="co">#&gt;                                             mobj$param_map,</span>
<span class="co">#&gt;                                             list(method = mobj$method)))) %&gt;%</span>
<span class="co">#&gt;     dplyr::mutate(submodel_uid = purrr::map_chr(1:n(), ~ sparklyr::random_string(&quot;submodel&quot;)),</span>
<span class="co">#&gt;                   method = as.character(method))</span>
<span class="co">#&gt;   grid_vars &lt;- setdiff(colnames(submodel_grid), c(&quot;submodel_uid&quot;))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Define param_grid including samples</span>
<span class="co">#&gt;   param_grid &lt;- data.frame(expand.grid(c(</span>
<span class="co">#&gt;     mobj$method_args,</span>
<span class="co">#&gt;     mobj$param_map,</span>
<span class="co">#&gt;     list(index = samples$indicies_names)</span>
<span class="co">#&gt;   )))</span>
<span class="co">#&gt;   param_vars &lt;- colnames(param_grid)[-ncol(param_grid)]</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Define packages for parallel computation</span>
<span class="co">#&gt;   packs &lt;- model_methods %&gt;%</span>
<span class="co">#&gt;     dplyr::filter(type == &quot;forecaster&quot;) %&gt;%</span>
<span class="co">#&gt;     dplyr::pull(package) %&gt;%</span>
<span class="co">#&gt;     c(&quot;a2modeler&quot;, &quot;dplyr&quot;) %&gt;%</span>
<span class="co">#&gt;     unique()</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Covariates</span>
<span class="co">#&gt;   x_vars &lt;- setdiff(colnames(data), c(mobj$target, mobj$index_var))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Measurement Function:</span>
<span class="co">#&gt;   measure_fun &lt;- match.fun(measure$method)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Fit submodel to train data for each sample</span>
<span class="co">#&gt;   fits &lt;- foreach(</span>
<span class="co">#&gt;     rn = 1:nrow(param_grid),</span>
<span class="co">#&gt;     .packages = packs,</span>
<span class="co">#&gt;     .export = c(&quot;mobj&quot;, &quot;data&quot;, &quot;x_vars&quot;, &quot;param_grid&quot;, &quot;param_vars&quot;, </span>
<span class="co">#&gt;                 &quot;indicies&quot;, &quot;model_fun&quot;, &quot;measure_fun&quot;, &quot;level&quot;),</span>
<span class="co">#&gt;     .errorhandling = &quot;pass&quot;) %dopar% {</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Params</span>
<span class="co">#&gt;       params &lt;- as.list(param_grid[rn, param_vars, drop=FALSE])</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Get Training Sample</span>
<span class="co">#&gt;       index &lt;- as.character(param_grid[[&quot;index&quot;]][rn])</span>
<span class="co">#&gt;       train_index &lt;- indicies[[index]]$train</span>
<span class="co">#&gt;       train_smpl &lt;- data[train_index, , drop=FALSE]</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Set Method Args</span>
<span class="co">#&gt;       y &lt;- as.numeric(train_smpl[[mobj$target]])</span>
<span class="co">#&gt;      </span>
<span class="co">#&gt;       if (length(x_vars) &gt; 0) {</span>
<span class="co">#&gt;         train_xreg &lt;- train_smpl[, x_vars, drop = FALSE]</span>
<span class="co">#&gt;       } else {</span>
<span class="co">#&gt;         train_xreg &lt;- NULL</span>
<span class="co">#&gt;       }</span>
<span class="co">#&gt;       args &lt;- modifyList(params, c(list(y = y, xreg = train_xreg)))</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Fit submodel to training sample</span>
<span class="co">#&gt;       fit &lt;- do.call(model_fun, args)</span>
<span class="co">#&gt;       fit$method_args &lt;- params</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Make Predictions</span>
<span class="co">#&gt;       if(! is.null(indicies[[index]]$validation)) {</span>
<span class="co">#&gt;         # Predict each validation sample</span>
<span class="co">#&gt;         val_index &lt;- indicies[[index]]$validation</span>
<span class="co">#&gt;         val_smpl &lt;- data[val_index, , drop = FALSE]</span>
<span class="co">#&gt;         </span>
<span class="co">#&gt;         # Set Forecast Args</span>
<span class="co">#&gt;         if (length(x_vars) &gt; 0) {</span>
<span class="co">#&gt;           val_xreg &lt;- val_smpl[, x_vars, drop = FALSE]</span>
<span class="co">#&gt;         } else{</span>
<span class="co">#&gt;           val_xreg &lt;- NULL</span>
<span class="co">#&gt;         }</span>
<span class="co">#&gt;         args &lt;- c(list(</span>
<span class="co">#&gt;           object = fit,</span>
<span class="co">#&gt;           xreg = val_xreg,</span>
<span class="co">#&gt;           h = length(val_index),</span>
<span class="co">#&gt;           level = level</span>
<span class="co">#&gt;         ),</span>
<span class="co">#&gt;         params)</span>
<span class="co">#&gt;         fun &lt;- get(&quot;forecast&quot;, asNamespace(&quot;forecast&quot;))</span>
<span class="co">#&gt;         fcast &lt;- get_forecasts(do.call(fun, args))</span>
<span class="co">#&gt;         fit$predictions &lt;- fcast</span>
<span class="co">#&gt;         perf_smpl &lt;-</span>
<span class="co">#&gt;           cbind(fcast, val_smpl[, mobj$target, drop = FALSE])</span>
<span class="co">#&gt;         </span>
<span class="co">#&gt;       } else {</span>
<span class="co">#&gt;         perf_smpl &lt;- cbind(data.frame(mean = as.numeric(fit$fitted)),</span>
<span class="co">#&gt;                            train_smpl[, mobj$target, drop = FALSE])</span>
<span class="co">#&gt;       }</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       # Evalulate Performance</span>
<span class="co">#&gt;       perf &lt;- data.frame(</span>
<span class="co">#&gt;         measure = measure_fun(perf_smpl,</span>
<span class="co">#&gt;                               predicted = &quot;mean&quot;,</span>
<span class="co">#&gt;                               actual = mobj$target),</span>
<span class="co">#&gt;         index = index,</span>
<span class="co">#&gt;         sample = &quot;validation&quot;</span>
<span class="co">#&gt;       )</span>
<span class="co">#&gt;       perf$index &lt;- as.character(perf$index)</span>
<span class="co">#&gt;       perf$sample &lt;- as.character(perf$sample)</span>
<span class="co">#&gt;       fit$performance &lt;- perf</span>
<span class="co">#&gt;       fit</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Calculate Final Performance</span>
<span class="co">#&gt;   fit_grid &lt;- purrr::map_df(fits, &quot;performance&quot;) %&gt;%</span>
<span class="co">#&gt;     dplyr::rename(!!measure$method := !!names(.)[1]) %&gt;% </span>
<span class="co">#&gt;     dplyr::bind_cols(purrr::map_df(fits, &quot;method_args&quot;)) %&gt;% </span>
<span class="co">#&gt;     dplyr::mutate(method = mobj$method) %&gt;% </span>
<span class="co">#&gt;     dplyr::inner_join(submodel_grid, by = grid_vars) %&gt;% </span>
<span class="co">#&gt;     dplyr::select(-method)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   performance &lt;- fit_grid %&gt;% </span>
<span class="co">#&gt;     dplyr::group_by_at(setdiff(colnames(fit_grid), c(measure$method, &quot;index&quot;))) %&gt;%</span>
<span class="co">#&gt;     dplyr::summarise_at(measure$method, mean) %&gt;% </span>
<span class="co">#&gt;     dplyr::ungroup() </span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(any(colnames(performance) %in% grid_vars)) {</span>
<span class="co">#&gt;     performance &lt;- performance %&gt;% </span>
<span class="co">#&gt;       tidyr::nest(-submodel_uid, -sample, -!!measure$method, .key = &quot;param_grid&quot;) </span>
<span class="co">#&gt;   }else {</span>
<span class="co">#&gt;     performance &lt;- performance %&gt;% </span>
<span class="co">#&gt;       dplyr::mutate(param_grid = vector(&quot;list&quot;, 1))</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   mobj$performance &lt;- performance %&gt;% </span>
<span class="co">#&gt;     dplyr::select(submodel_uid, sample, !!measure$method, param_grid)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # select best model</span>
<span class="co">#&gt;   best_submodel &lt;- mobj$performance %&gt;%</span>
<span class="co">#&gt;     dplyr::arrange_at(measure$method,</span>
<span class="co">#&gt;                       .funs = ifelse(measure$minimize, identity, dplyr::desc)) %&gt;%</span>
<span class="co">#&gt;     head(1)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Refit on full sample</span>
<span class="co">#&gt;   if (samples$validation_method == &quot;none&quot;) {</span>
<span class="co">#&gt;     mobj$fit &lt;- fits[[1]]</span>
<span class="co">#&gt;   } else {</span>
<span class="co">#&gt;     params &lt;- best_submodel$param_grid[[1]] %&gt;% as.list()</span>
<span class="co">#&gt;     y &lt;- as.numeric(data[[mobj$target]])</span>
<span class="co">#&gt;     if (length(x_vars) &gt; 0) {</span>
<span class="co">#&gt;       xreg &lt;- data[, x_vars, drop = FALSE]</span>
<span class="co">#&gt;     } else{</span>
<span class="co">#&gt;       xreg &lt;- NULL</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     args &lt;- modifyList(params, list(y = y, xreg = xreg))</span>
<span class="co">#&gt;     mobj$fit &lt;- do.call(model_fun, args)</span>
<span class="co">#&gt;     </span>
<span class="co">#&gt;     # save submodels option</span>
<span class="co">#&gt;     if (save_submodels) {</span>
<span class="co">#&gt;       sub_models &lt;- list()</span>
<span class="co">#&gt;       for (uid in submodel_grid$submodel_uid) {</span>
<span class="co">#&gt;         sub_model &lt;- purrr::keep(fits, fit_grid$submodel_uid == uid)</span>
<span class="co">#&gt;         names(sub_model) &lt;- samples$indicies_names</span>
<span class="co">#&gt;         sub_models[[uid]] &lt;- sub_model</span>
<span class="co">#&gt;       }</span>
<span class="co">#&gt;       </span>
<span class="co">#&gt;       mobj$sub_models &lt;- sub_models</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;  </span>
<span class="co">#&gt;   mobj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>In the first section, assertions are made on the inputs, a potential parallel backend with doFuture<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> is created, the model method function is defined and the indices are extracted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">train_model.forecast_model &lt;-<span class="st"> </span><span class="cf">function</span>(mobj, 
                                       data,
                                       measure,
                                       samples,
                                       save_submodels,
                                       execution_strategy,
                                       level,
                                       ...){
  
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(data, <span class="st">&quot;data.frame&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(measure, <span class="st">&quot;measure&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_class</span>(samples, <span class="st">&quot;samples&quot;</span>)
  checkmate<span class="op">::</span><span class="kw">assert_logical</span>(save_submodels)
  checkmate<span class="op">::</span><span class="kw">assert_numeric</span>(level, <span class="dt">max.len =</span> <span class="dv">2</span>, <span class="dt">upper =</span> <span class="dv">100</span>)
  
  <span class="co"># Set Execution Strategy</span>
  future<span class="op">::</span><span class="kw">plan</span>(execution_strategy)
  doFuture<span class="op">::</span><span class="kw">registerDoFuture</span>()
  
  <span class="co"># Set model function</span>
  model_fun &lt;-<span class="st"> </span><span class="kw">get</span>(mobj<span class="op">$</span>method, <span class="kw">asNamespace</span>(mobj<span class="op">$</span>package))
  
  <span class="co"># Get Indicies</span>
  indicies &lt;-<span class="st"> </span><span class="kw">get_indicies</span>(samples)</code></pre></div>
<p>The next section a submodel grid is created as a combination of the method_args, the param_map, and the model method arguments. A unique model is fit for each unique row in the submodel_grid.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Submodel grid</span>
  submodel_grid &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">expand.grid</span>(<span class="kw">c</span>(mobj<span class="op">$</span>method_args,
                                            mobj<span class="op">$</span>param_map,
                                            <span class="kw">list</span>(<span class="dt">method =</span> mobj<span class="op">$</span>method)))) <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">submodel_uid =</span> purrr<span class="op">::</span><span class="kw">map_chr</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">n</span>(), <span class="op">~</span><span class="st"> </span>sparklyr<span class="op">::</span><span class="kw">random_string</span>(<span class="st">&quot;submodel&quot;</span>)),
                  <span class="dt">method =</span> <span class="kw">as.character</span>(method))
  grid_vars &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">colnames</span>(submodel_grid), <span class="kw">c</span>(<span class="st">&quot;submodel_uid&quot;</span>))
  </code></pre></div>
<p>In this section a parameter grid is created including the index samples. A unique model fit is made for each row in the grid. The foreach loop iterates through each rows in the grid.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Define param_grid including samples</span>
  param_grid &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">expand.grid</span>(<span class="kw">c</span>(
    mobj<span class="op">$</span>method_args,
    mobj<span class="op">$</span>param_map,
    <span class="kw">list</span>(<span class="dt">index =</span> samples<span class="op">$</span>indicies_names)
  )))
  param_vars &lt;-<span class="st"> </span><span class="kw">colnames</span>(param_grid)[<span class="op">-</span><span class="kw">ncol</span>(param_grid)]</code></pre></div>
<p>In the next section the packages are extracted for parallel computation, and the covariates and measure function are set.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Define packages for parallel computation</span>
  packs &lt;-<span class="st"> </span>model_methods <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">filter</span>(type <span class="op">==</span><span class="st"> &quot;forecaster&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">pull</span>(package) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">c</span>(<span class="st">&quot;a2modeler&quot;</span>, <span class="st">&quot;dplyr&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">unique</span>()
  
  <span class="co"># Covariates</span>
  x_vars &lt;-<span class="st"> </span><span class="kw">setdiff</span>(<span class="kw">colnames</span>(data), <span class="kw">c</span>(mobj<span class="op">$</span>target, mobj<span class="op">$</span>index_var))
  
  <span class="co"># Measurement Function:</span>
  measure_fun &lt;-<span class="st"> </span><span class="kw">match.fun</span>(measure<span class="op">$</span>method)
  </code></pre></div>
<p>In the next section, the foreach loop is set defined. The benefit of using foreach and doFuture is the loop can be parallelized by changing the execution strategy only. The following code does not have to change for sequential execution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Fit submodel to train data for each sample</span>
  fits &lt;-<span class="st"> </span><span class="kw">foreach</span>(
    <span class="dt">rn =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(param_grid),
    <span class="dt">.packages =</span> packs,
    <span class="dt">.export =</span> <span class="kw">c</span>(<span class="st">&quot;mobj&quot;</span>, <span class="st">&quot;data&quot;</span>, <span class="st">&quot;x_vars&quot;</span>, <span class="st">&quot;param_grid&quot;</span>, <span class="st">&quot;param_vars&quot;</span>, 
                <span class="st">&quot;indicies&quot;</span>, <span class="st">&quot;model_fun&quot;</span>, <span class="st">&quot;measure_fun&quot;</span>, <span class="st">&quot;level&quot;</span>),
    <span class="dt">.errorhandling =</span> <span class="st">&quot;pass&quot;</span>) <span class="op">%dopar%</span><span class="st"> </span>{</code></pre></div>
<p>In the following section the unique model parameters and index are extracted, the training dataset is created, and a model is fit.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="co"># Params</span>
      params &lt;-<span class="st"> </span><span class="kw">as.list</span>(param_grid[rn, param_vars, <span class="dt">drop=</span><span class="ot">FALSE</span>])
      
      <span class="co"># Get Training Sample</span>
      index &lt;-<span class="st"> </span><span class="kw">as.character</span>(param_grid[[<span class="st">&quot;index&quot;</span>]][rn])
      train_index &lt;-<span class="st"> </span>indicies[[index]]<span class="op">$</span>train
      train_smpl &lt;-<span class="st"> </span>data[train_index, , drop=<span class="ot">FALSE</span>]
      
      <span class="co"># Set Method Args</span>
      y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(train_smpl[[mobj<span class="op">$</span>target]])
     
      <span class="cf">if</span> (<span class="kw">length</span>(x_vars) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
        train_xreg &lt;-<span class="st"> </span>train_smpl[, x_vars, drop =<span class="st"> </span><span class="ot">FALSE</span>]
      } <span class="cf">else</span> {
        train_xreg &lt;-<span class="st"> </span><span class="ot">NULL</span>
      }
      args &lt;-<span class="st"> </span><span class="kw">modifyList</span>(params, <span class="kw">c</span>(<span class="kw">list</span>(<span class="dt">y =</span> y, <span class="dt">xreg =</span> train_xreg)))
      
      <span class="co"># Fit submodel to training sample</span>
      fit &lt;-<span class="st"> </span><span class="kw">do.call</span>(model_fun, args)
      fit<span class="op">$</span>method_args &lt;-<span class="st"> </span>params</code></pre></div>
<p>Next the rest of the foreach loop is shown. First the validation index is created and the model fit from the previous section is applied to create predictions. The predictions are measured, stored and the model fit is return to the foreach loop output</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Make Predictions</span>
      <span class="cf">if</span>(<span class="op">!</span><span class="st"> </span><span class="kw">is.null</span>(indicies[[index]]<span class="op">$</span>validation)) {
        <span class="co"># Predict each validation sample</span>
        val_index &lt;-<span class="st"> </span>indicies[[index]]<span class="op">$</span>validation
        val_smpl &lt;-<span class="st"> </span>data[val_index, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
        
        <span class="co"># Set Forecast Args</span>
        <span class="cf">if</span> (<span class="kw">length</span>(x_vars) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
          val_xreg &lt;-<span class="st"> </span>val_smpl[, x_vars, drop =<span class="st"> </span><span class="ot">FALSE</span>]
        } <span class="cf">else</span>{
          val_xreg &lt;-<span class="st"> </span><span class="ot">NULL</span>
        }
        args &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(
          <span class="dt">object =</span> fit,
          <span class="dt">xreg =</span> val_xreg,
          <span class="dt">h =</span> <span class="kw">length</span>(val_index),
          <span class="dt">level =</span> level
        ),
        params)
        fun &lt;-<span class="st"> </span><span class="kw">get</span>(<span class="st">&quot;forecast&quot;</span>, <span class="kw">asNamespace</span>(<span class="st">&quot;forecast&quot;</span>))
        fcast &lt;-<span class="st"> </span><span class="kw">get_forecasts</span>(<span class="kw">do.call</span>(fun, args))
        fit<span class="op">$</span>predictions &lt;-<span class="st"> </span>fcast
        perf_smpl &lt;-
<span class="st">          </span><span class="kw">cbind</span>(fcast, val_smpl[, mobj<span class="op">$</span>target, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
        
      } <span class="cf">else</span> {
        perf_smpl &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">data.frame</span>(<span class="dt">mean =</span> <span class="kw">as.numeric</span>(fit<span class="op">$</span>fitted)),
                           train_smpl[, mobj<span class="op">$</span>target, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
      }

      <span class="co"># Evalulate Performance</span>
      perf &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
        <span class="dt">measure =</span> <span class="kw">measure_fun</span>(perf_smpl,
                              <span class="dt">predicted =</span> <span class="st">&quot;mean&quot;</span>,
                              <span class="dt">actual =</span> mobj<span class="op">$</span>target),
        <span class="dt">index =</span> index,
        <span class="dt">sample =</span> <span class="st">&quot;validation&quot;</span>
      )
      perf<span class="op">$</span>index &lt;-<span class="st"> </span><span class="kw">as.character</span>(perf<span class="op">$</span>index)
      perf<span class="op">$</span>sample &lt;-<span class="st"> </span><span class="kw">as.character</span>(perf<span class="op">$</span>sample)
      fit<span class="op">$</span>performance &lt;-<span class="st"> </span>perf
      fit</code></pre></div>
<p>Once all the model fits are completed, the model performance is made for each unique model, formatted and stored.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Calculate Final Performance</span>
  fit_grid &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">map_df</span>(fits, <span class="st">&quot;performance&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">rename</span>(<span class="op">!!</span>measure<span class="op">$</span>method <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="op">!!</span><span class="kw">names</span>(.)[<span class="dv">1</span>]) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">bind_cols</span>(purrr<span class="op">::</span><span class="kw">map_df</span>(fits, <span class="st">&quot;method_args&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">method =</span> mobj<span class="op">$</span>method) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">inner_join</span>(submodel_grid, <span class="dt">by =</span> grid_vars) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">select</span>(<span class="op">-</span>method)
  
  performance &lt;-<span class="st"> </span>fit_grid <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">group_by_at</span>(<span class="kw">setdiff</span>(<span class="kw">colnames</span>(fit_grid), <span class="kw">c</span>(measure<span class="op">$</span>method, <span class="st">&quot;index&quot;</span>))) <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">summarise_at</span>(measure<span class="op">$</span>method, mean) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">ungroup</span>() 
  
  <span class="cf">if</span>(<span class="kw">any</span>(<span class="kw">colnames</span>(performance) <span class="op">%in%</span><span class="st"> </span>grid_vars)) {
    performance &lt;-<span class="st"> </span>performance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">      </span>tidyr<span class="op">::</span><span class="kw">nest</span>(<span class="op">-</span>submodel_uid, <span class="op">-</span>sample, <span class="op">-!!</span>measure<span class="op">$</span>method, <span class="dt">.key =</span> <span class="st">&quot;param_grid&quot;</span>) 
  }<span class="cf">else</span> {
    performance &lt;-<span class="st"> </span>performance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">      </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">param_grid =</span> <span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="dv">1</span>))
  }
  
  mobj<span class="op">$</span>performance &lt;-<span class="st"> </span>performance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">select</span>(submodel_uid, sample, <span class="op">!!</span>measure<span class="op">$</span>method, param_grid)
  </code></pre></div>
<p>In the next section, the best sub model is selected based on the model performance</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># select best model</span>
  best_submodel &lt;-<span class="st"> </span>mobj<span class="op">$</span>performance <span class="op">%&gt;%</span>
<span class="st">    </span>dplyr<span class="op">::</span><span class="kw">arrange_at</span>(measure<span class="op">$</span>method,
                      <span class="dt">.funs =</span> <span class="kw">ifelse</span>(measure<span class="op">$</span>minimize, identity, dplyr<span class="op">::</span>desc)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">head</span>(<span class="dv">1</span>)</code></pre></div>
<p>In the last section of the function the model is refit on the full data sample and the submodels are stored on the model object if the save_submodels option is made.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
  <span class="co"># Refit on full sample</span>
  <span class="cf">if</span> (samples<span class="op">$</span>validation_method <span class="op">==</span><span class="st"> &quot;none&quot;</span>) {
    mobj<span class="op">$</span>fit &lt;-<span class="st"> </span>fits[[<span class="dv">1</span>]]
  } <span class="cf">else</span> {
    params &lt;-<span class="st"> </span>best_submodel<span class="op">$</span>param_grid[[<span class="dv">1</span>]] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.list</span>()
    y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(data[[mobj<span class="op">$</span>target]])
    <span class="cf">if</span> (<span class="kw">length</span>(x_vars) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
      xreg &lt;-<span class="st"> </span>data[, x_vars, drop =<span class="st"> </span><span class="ot">FALSE</span>]
    } <span class="cf">else</span>{
      xreg &lt;-<span class="st"> </span><span class="ot">NULL</span>
    }
    args &lt;-<span class="st"> </span><span class="kw">modifyList</span>(params, <span class="kw">list</span>(<span class="dt">y =</span> y, <span class="dt">xreg =</span> xreg))
    mobj<span class="op">$</span>fit &lt;-<span class="st"> </span><span class="kw">do.call</span>(model_fun, args)
    
    <span class="co"># save submodels option</span>
    <span class="cf">if</span> (save_submodels) {
      sub_models &lt;-<span class="st"> </span><span class="kw">list</span>()
      <span class="cf">for</span> (uid <span class="cf">in</span> submodel_grid<span class="op">$</span>submodel_uid) {
        sub_model &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">keep</span>(fits, fit_grid<span class="op">$</span>submodel_uid <span class="op">==</span><span class="st"> </span>uid)
        <span class="kw">names</span>(sub_model) &lt;-<span class="st"> </span>samples<span class="op">$</span>indicies_names
        sub_models[[uid]] &lt;-<span class="st"> </span>sub_model
      }
      
      mobj<span class="op">$</span>sub_models &lt;-<span class="st"> </span>sub_models
    }
  }
 
  mobj</code></pre></div>
</div>
</div>
</div>
</div>
<div id="predictions" class="section level2">
<h2>Predictions</h2>
<p>Once a modeler workflow is completed predictions can be made on new datasets similar to the input data. In the a2modeler package the prediction class supports prediction mangement. Below is the constructor function for creating a predictions object. The class stores information on the predictions, the model used to make the predictions, the modeler type (class), and some meta-data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">new_predictions
<span class="co">#&gt; function(predictions,</span>
<span class="co">#&gt;                             model,</span>
<span class="co">#&gt;                             type,</span>
<span class="co">#&gt;                             uid,</span>
<span class="co">#&gt;                             desc) {</span>
<span class="co">#&gt;   checkmate::assert_true(any(class(predictions) %in% c(&quot;data.frame&quot;, &quot;tbl_spark&quot;)))</span>
<span class="co">#&gt;   checkmate::assert_class(model, &quot;model&quot;)</span>
<span class="co">#&gt;   checkmate::assert_character(uid)</span>
<span class="co">#&gt;   checkmate::assert_character(desc)</span>
<span class="co">#&gt;   checkmate::assert_choice(type,</span>
<span class="co">#&gt;                            c(&quot;forecaster&quot;, &quot;segmenter&quot;, &quot;regressor&quot;,</span>
<span class="co">#&gt;                              &quot;classifier&quot;, &quot;multiclassifier&quot;))</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   structure(</span>
<span class="co">#&gt;     list(</span>
<span class="co">#&gt;       predictions = predictions,</span>
<span class="co">#&gt;       model = model,</span>
<span class="co">#&gt;       type = type,</span>
<span class="co">#&gt;       uid = uid,</span>
<span class="co">#&gt;       desc = desc,</span>
<span class="co">#&gt;       created_on = Sys.time()</span>
<span class="co">#&gt;     ),</span>
<span class="co">#&gt;     class = &quot;predictions&quot;</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<div id="spark-predict-method" class="section level4">
<h4>Spark Predict Method</h4>
<p>The prediction class stores the predictions made with modeler predict methods. Below is the classifier method, which is very similar to the other spark based classes.</p>
<p>The method first checks the new data schema to ensure its similar to the input data schema saved in the modeler object. Next the model pipeline is executed on the new data applying any feature engineering transformations. Lastly the predictions are made with the modeler’s final model on the pipeline output and saved in a predictions object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Classifier Predict Method</span>
predict.classifier
<span class="co">#&gt; function(obj,</span>
<span class="co">#&gt;                                data = NULL,</span>
<span class="co">#&gt;                                desc = &quot;&quot;,</span>
<span class="co">#&gt;                                ...) {</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if (is.null(obj$final_model)) {</span>
<span class="co">#&gt;     stop(&quot;Final model not set&quot;)</span>
<span class="co">#&gt;   } else {</span>
<span class="co">#&gt;     final_model &lt;- obj$final_model</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Schema Check</span>
<span class="co">#&gt;   schema_compare &lt;- obj$schema %&gt;% </span>
<span class="co">#&gt;     purrr::keep(names(obj$schema) != obj$target) %&gt;% </span>
<span class="co">#&gt;     a2munge::schema_check(., a2munge::get_schema(data))</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   pipe &lt;- obj$pipelines[[final_model$pipe]] %&gt;% </span>
<span class="co">#&gt;     execute(data, .) </span>
<span class="co">#&gt;   predict(final_model, data = pipe$output, ...) %&gt;% </span>
<span class="co">#&gt;     new_predictions(</span>
<span class="co">#&gt;       predictions = .,</span>
<span class="co">#&gt;       model = final_model,</span>
<span class="co">#&gt;       type = &quot;classifier&quot;,</span>
<span class="co">#&gt;       uid = sparklyr::random_string(prefix = &quot;pred&quot;),</span>
<span class="co">#&gt;       desc = desc</span>
<span class="co">#&gt;     )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The predict method used internally is specific to the final model class. In the classifier case, the internal predict method below uses the sparklyr <code>ml_predict</code> function on the sparkl-ml model and then formatted to the expected output schema.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Spark Model Classification predict method</span>
predict.spark_model_classification 
<span class="co">#&gt; function(mobj,</span>
<span class="co">#&gt;                                                data,</span>
<span class="co">#&gt;                                                prediction_col = &quot;predicted&quot;,</span>
<span class="co">#&gt;                                                ...) {</span>
<span class="co">#&gt;   checkmate::assert_class(data, &quot;tbl_spark&quot;)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   sparklyr::ml_predict(mobj$fit, data,  ...) %&gt;%</span>
<span class="co">#&gt;     sparklyr::sdf_separate_column(&quot;probability&quot;, into = c(&quot;prob_0&quot;, &quot;prob_1&quot;)) %&gt;% </span>
<span class="co">#&gt;     dplyr::select(prediction, prob_0, prob_1) %&gt;% </span>
<span class="co">#&gt;     dplyr::rename(!!prediction_col := prediction) %&gt;% </span>
<span class="co">#&gt;     dplyr::select(!!prediction_col, prob_0, prob_1)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="forecaster-predict-methods" class="section level4">
<h4>Forecaster Predict Methods</h4>
<p>The forecaster R predict method works differently. Here the data input is optional. If provided care should be given that it temporally aligns to the intended forecast horizon. The forecaster predictions are forward looking predictions of a sequential variable, which in most cases is a time series. The periods argument sets the prediction horizon length and levels controls the confidence intervals.</p>
<p>Similar to the classifier predict method the forecaster print method below preforms a schema check on the data if provided, executes the final model’s pipeline and creates the predictions using an intenal predict method covered next. Note - the forecaster print method creates a prediction index by using the <code>extend</code> method on the forecaster’s index and combines with the prediction output. The index class is covered in the next section.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Forecaster predict method</span>
predict.forecaster
<span class="co">#&gt; function(obj,</span>
<span class="co">#&gt;                                data = NULL,</span>
<span class="co">#&gt;                                periods,</span>
<span class="co">#&gt;                                uid = sparklyr::random_string(prefix = &quot;pred&quot;),</span>
<span class="co">#&gt;                                desc = &quot;&quot;,</span>
<span class="co">#&gt;                                ...) {</span>
<span class="co">#&gt;   final_model &lt;- obj$final_model</span>
<span class="co">#&gt;   if (is.null(final_model)) {</span>
<span class="co">#&gt;     stop(&quot;Final model not set&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(! is.null(data)) {</span>
<span class="co">#&gt;   # Schema Check</span>
<span class="co">#&gt;   schema_compare &lt;- obj$schema %&gt;% </span>
<span class="co">#&gt;     purrr::keep(! names(obj$schema) %in% c(obj$target, obj$index_var)) %&gt;% </span>
<span class="co">#&gt;     a2munge::schema_check(., a2munge::get_schema(data))</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   pipe &lt;- execute(data, obj$pipelines[[final_model$pipe]])</span>
<span class="co">#&gt;   preds &lt;- predict(final_model, data = pipe$output, periods, obj$level)</span>
<span class="co">#&gt;   index_out &lt;- extend(obj$index, length_out = periods)</span>
<span class="co">#&gt;   predictions &lt;- data.frame(index_out, preds)</span>
<span class="co">#&gt;   colnames(predictions)[1] &lt;- obj$index_var</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   new_predictions(</span>
<span class="co">#&gt;     predictions = predictions,</span>
<span class="co">#&gt;     model = final_model,</span>
<span class="co">#&gt;     type = &quot;forecaster&quot;,</span>
<span class="co">#&gt;     uid = uid,</span>
<span class="co">#&gt;     desc = desc</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
<p>The forecast predict method that creates the prediction output using the <code>forecast</code> function from the forecast package. The <code>get_forecast</code> function is used to format the output.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># forecast model predict method</span>
predict.forecast_model
<span class="co">#&gt; function(mobj,</span>
<span class="co">#&gt;                                    data = NULL,</span>
<span class="co">#&gt;                                    periods,</span>
<span class="co">#&gt;                                    level = c(80, 95),</span>
<span class="co">#&gt;                                    ...) {</span>
<span class="co">#&gt;   if (!is.null(data)) {</span>
<span class="co">#&gt;     if (nrow(data) != periods) {</span>
<span class="co">#&gt;       warning(&quot;number of data rows doesn't match forecast periods&quot;)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     x_vars &lt;- setdiff(colnames(data), c(mobj$target, mobj$index_var))</span>
<span class="co">#&gt;     if (length(x_vars) &gt; 0) {</span>
<span class="co">#&gt;       xreg &lt;- data[, x_vars, drop = FALSE]</span>
<span class="co">#&gt;     } else {</span>
<span class="co">#&gt;       xreg &lt;- NULL</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   } else{</span>
<span class="co">#&gt;     xreg &lt;- NULL</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   fun &lt;- get(&quot;forecast&quot;, asNamespace(&quot;forecast&quot;))</span>
<span class="co">#&gt;   f &lt;- do.call(fun,</span>
<span class="co">#&gt;                modifyList(</span>
<span class="co">#&gt;                  mobj$method_args,</span>
<span class="co">#&gt;                  list(</span>
<span class="co">#&gt;                    object = mobj$fit,</span>
<span class="co">#&gt;                    xreg = xreg,</span>
<span class="co">#&gt;                    h = periods,</span>
<span class="co">#&gt;                    level = level</span>
<span class="co">#&gt;                  )</span>
<span class="co">#&gt;                ))</span>
<span class="co">#&gt;   get_forecasts(f)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span>

<span class="co"># get_forecasts</span>
get_forecasts.forecast
<span class="co">#&gt; function(mobj){</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;   df &lt;- as.data.frame(mobj)</span>
<span class="co">#&gt;   cns &lt;- tolower(colnames(df))</span>
<span class="co">#&gt;   cns &lt;- gsub(&quot;lo&quot;, &quot;lower&quot;, cns)</span>
<span class="co">#&gt;   cns &lt;- gsub(&quot;hi&quot;, &quot;upper&quot;, cns)</span>
<span class="co">#&gt;   cns &lt;- gsub(&quot; &quot;, &quot;&quot;, cns)</span>
<span class="co">#&gt;   cns[1] &lt;- &quot;mean&quot;</span>
<span class="co">#&gt;   colnames(df) &lt;- cns</span>
<span class="co">#&gt;   df</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="index-class" class="section level4">
<h4>Index Class</h4>
<p>The index class stores information on a sequence so that the sequence can be accurately extended such as the unit, number of periods, start and end values. There is a time_index sub-class for datetime based indices which enables a different extend behavior.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Create Index Object ex</span>
i1 &lt;-<span class="st"> </span><span class="kw">index</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">unit =</span> <span class="ot">NULL</span>)
i1
<span class="co">#&gt; $unit</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $periods</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $start</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $end</span>
<span class="co">#&gt; [1] 10</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;numeric_index&quot; &quot;index&quot;</span>

<span class="co"># Create Date Index</span>
d1 &lt;-<span class="st"> </span><span class="kw">index</span>(<span class="kw">today</span>() <span class="op">-</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">6</span>), <span class="dt">unit =</span> <span class="st">&quot;days&quot;</span>)
d1
<span class="co">#&gt; $unit</span>
<span class="co">#&gt; [1] &quot;days&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $periods</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $start</span>
<span class="co">#&gt; [1] &quot;2018-12-04&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $end</span>
<span class="co">#&gt; [1] &quot;2018-12-10&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;time_index&quot; &quot;index&quot;</span></code></pre></div>
<div id="index-methods" class="section level5">
<h5>Index Methods</h5>
<p>The index class only has one generic function in the a2modeler - <code>extend</code>. It is used to extend a an index by some length out. There are methods for numeric, index, and time_index classes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># Extend index</span>
<span class="kw">extend</span>(i1, <span class="dv">5</span>)
<span class="co">#&gt; [1] 11 12 13 14 15</span>
<span class="kw">extend</span>(d1, <span class="dv">5</span>)
<span class="co">#&gt; [1] &quot;2018-12-11&quot; &quot;2018-12-12&quot; &quot;2018-12-13&quot; &quot;2018-12-14&quot; &quot;2018-12-15&quot;</span></code></pre></div>
</div>
</div>
</div>
<div id="helper-functions" class="section level2">
<h2>Helper Functions</h2>
<p>In this section additional helper functions contained in the a2modeler package are discussed.</p>
<div id="refit" class="section level4">
<h4>Refit</h4>
<p>The refit function can be used to refit a modeler object to a new dataset. The function provides the option to append the new data to the stored data (default) or fit on just the new data. The function returns an updated modeler object. Only the final model is fit. The entire workflow is not executed.</p>
<p>Below is the refit modeler method. Similar to the prediction methods, the refit applies assertions on the new data ensuring its the same class and schema of the orginial modeler input data. The final model pipeline is applied with a single default sample to create the training dataset and passed to the <code>train_model</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Refit Method</span>
refit.modeler
<span class="co">#&gt; function(obj, df, append = TRUE, ...) {</span>
<span class="co">#&gt;   checkmate::assert_class(obj, &quot;modeler&quot;)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(! any(class(df) %in% class(obj$data))) { </span>
<span class="co">#&gt;     stop(c(&quot;new dataframe class not consistent with expected data class\n&quot;,</span>
<span class="co">#&gt;           &quot;expecting class: &quot;, paste(class(obj$data), collapse=&quot;, &quot;), &quot;\n&quot;, </span>
<span class="co">#&gt;           &quot;dataframe class: &quot;, paste(class(df), collapse=&quot;, &quot;), &quot;\n&quot;  ))</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(is.null(obj$final_model)) {</span>
<span class="co">#&gt;     stop(&quot;final model not set&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Schema Check</span>
<span class="co">#&gt;   schema_compare &lt;- a2munge::get_schema(df) %&gt;% </span>
<span class="co">#&gt;     a2munge::schema_check(obj$schema)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Append Option</span>
<span class="co">#&gt;   pipe_uid &lt;- obj$final_model$pipe</span>
<span class="co">#&gt;   if(append) {</span>
<span class="co">#&gt;     bind_fun &lt;- ifelse(&quot;tbl_spark&quot; %in% class(df), </span>
<span class="co">#&gt;                        get(&quot;sdf_bind_rows&quot;, asNamespace(&quot;sparklyr&quot;)),</span>
<span class="co">#&gt;                        get(&quot;bind_rows&quot;, asNamespace(&quot;dplyr&quot;)))</span>
<span class="co">#&gt;     obj$data &lt;- bind_fun(obj$data, df)</span>
<span class="co">#&gt;     obj$pipelines[[pipe_uid]] &lt;- execute(obj$data, obj$pipelines[[pipe_uid]])</span>
<span class="co">#&gt;     data &lt;- obj$pipelines[[pipe_uid]]$output</span>
<span class="co">#&gt;   } else {</span>
<span class="co">#&gt;     data &lt;- flow(df, obj$pipelines[[pipe_uid]])</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Samples</span>
<span class="co">#&gt;   refit_sample &lt;- add_default_samples(data)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   obj$final_model &lt;- train_model(</span>
<span class="co">#&gt;     mobj = obj$final_model,</span>
<span class="co">#&gt;     data = data,</span>
<span class="co">#&gt;     measure = obj$measure,</span>
<span class="co">#&gt;     samples = refit_sample,</span>
<span class="co">#&gt;     save_submodels = FALSE,</span>
<span class="co">#&gt;     execution_strategy = obj$execution_strategy,</span>
<span class="co">#&gt;     level = obj$conf_levels,</span>
<span class="co">#&gt;     seed = obj$seed</span>
<span class="co">#&gt;   )</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="deploy" class="section level4">
<h4>Deploy</h4>
<p>The deploy function can be used to save a modeler object to file for use on a new dataset in a different time and environement.</p>
<p>The function below does the following:</p>
<ul>
<li>Creates a label from the modeler name and version</li>
<li>Creates a model path using the label and model uid</li>
<li>Removes all spark objects from the modeler objects which should be saved seperately</li>
<li>saves the modeler object as a .rds file with the either the <code>ml_save</code> function for spark models or <code>saveRDS</code> function for R based models</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># deploy function</span>
deploy
<span class="co">#&gt; function(obj, path, ...) {</span>
<span class="co">#&gt;   checkmate::assert_class(obj, &quot;modeler&quot;)</span>
<span class="co">#&gt;   checkmate::assert_directory(dirname(path))</span>
<span class="co">#&gt;  </span>
<span class="co">#&gt;   # Check for final model</span>
<span class="co">#&gt;   if(is.null(obj$final_model)) {</span>
<span class="co">#&gt;     stop(&quot;Deployment failed - Final Model not set&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Created model label</span>
<span class="co">#&gt;   label &lt;- paste(obj$name, obj$version, sep=&quot;-&quot;)</span>
<span class="co">#&gt;   modeler_path &lt;- paste(path, label, sep=&quot;/&quot;)</span>
<span class="co">#&gt;   modeler_file &lt;- paste(modeler_path, paste0(label, &quot;.rds&quot;), sep=&quot;/&quot;)</span>
<span class="co">#&gt;   model_path &lt;- paste(modeler_path, obj$final_model$uid, sep=&quot;/&quot;)</span>
<span class="co">#&gt;   obj$final_model$path &lt;- model_path</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Remove Spark objects from obj</span>
<span class="co">#&gt;   if(&quot;tbl_spark&quot; %in% class(obj$data)) obj$data &lt;- NULL</span>
<span class="co">#&gt;   for(i in seq_along(obj$models)) {</span>
<span class="co">#&gt;     if(&quot;spark_model&quot; %in% class(obj$models[[1]])){</span>
<span class="co">#&gt;       obj$models[[i]]$fit &lt;- NULL</span>
<span class="co">#&gt;       obj$models[[i]]$sub_models &lt;- NULL</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   for(i in seq_along(obj$pipelines)) {</span>
<span class="co">#&gt;     if(&quot;tbl_spark&quot; %in% class(obj$pipelines[[i]]$output)) {</span>
<span class="co">#&gt;       obj$pipelines[[i]]$output &lt;- NULL</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Create directory &amp; write modeler and Final Model</span>
<span class="co">#&gt;   dir.create(modeler_path, recursive = TRUE)</span>
<span class="co">#&gt;   if(&quot;spark_model&quot; %in% class(obj$final_model)) {</span>
<span class="co">#&gt;     sparklyr::ml_save(obj$final_model$fit, model_path)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   saveRDS(object = obj, file = modeler_file, ...)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
<div id="a2-load" class="section level4">
<h4>A2 Load</h4>
<p>The <code>a2_load</code> function is used to load a saved modeler object into memory. The function takes a path argument and optional spark connection with modeler objects with a spark based final model. The path argument should be the directory location of the modeler object, not the final .rds file location.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># a2_load function</span>
a2_load
<span class="co">#&gt; function(path, sc = NULL) {</span>
<span class="co">#&gt;   checkmate::assert_directory(dirname(path))</span>
<span class="co">#&gt;   checkmate::assert_class(sc, &quot;spark_connection&quot;, null.ok = TRUE)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Get modeler file</span>
<span class="co">#&gt;   modeler_file &lt;- list.files(path = path, pattern = &quot;.rds&quot;, full.names = TRUE)</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   if(length(modeler_file) == 0) {</span>
<span class="co">#&gt;     stop(&quot;Model Meta-data file not found\nLooking for .rds file&quot;)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   # Load Meta-data and Model</span>
<span class="co">#&gt;   obj &lt;- readRDS(file = modeler_file)</span>
<span class="co">#&gt;   if(! is.null(sc)) {</span>
<span class="co">#&gt;     obj$final_model$fit &lt;- sparklyr::ml_load(sc, path = obj$final_model$path)</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt;   </span>
<span class="co">#&gt;   obj</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: namespace:a2modeler&gt;</span></code></pre></div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>R Intro <a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf">via</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Tidyverse <a href="https://www.tidyverse.org/">via</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>R for Data Science <a href="https://r4ds.had.co.nz/">via</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>R S3 Object System <a href="http://adv-r.had.co.nz/S3.html">via</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>R Packages <a href="http://r-pkgs.had.co.nz/">via</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Spark-ML <a href="https://spark.apache.org/mllib/">via</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>forecast R package <a href="http://pkg.robjhyndman.com/forecast/">via</a><a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>future R package <a href="https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html">via</a><a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Foreach Parallel Adaptor using Futures <a href="https://cran.r-project.org/web/packages/doFuture/vignettes/doFuture.html">via</a><a href="#fnref9">↩</a></p></li>
</ol>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
