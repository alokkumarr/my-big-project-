

# Modeler Class Functions -------------------------------------------------



#' New Modeler Object Constructer function
#' @import sparklyr
#' @import forecast
new_modeler <- function(df,
                        schema,
                        target,
                        type,
                        name,
                        uid,
                        version,
                        desc,
                        scientist,
                        dir,
                        execution_strategy,
                        refit,
                        save_submodels,
                        samples,
                        pipelines,
                        models,
                        measure,
                        performance,
                        final_model,
                        ...){
  
  checkmate::assert_list(schema)
  checkmate::assert_character(target, null.ok = TRUE)
  checkmate::assert_character(type)
  checkmate::assert_character(name)
  checkmate::assert_character(uid)
  checkmate::assert_character(version)
  checkmate::assert_character(desc)
  checkmate::assert_character(scientist)
  checkmate::test_path_for_output(dir)
  checkmate::assert_choice(execution_strategy,
                           c("sequential", "transparent", "multisession", "multicore",
                             "multiprocess", "cluster", "remote"))
  checkmate::assert_flag(refit)
  checkmate::assert_flag(save_submodels)
  checkmate::assert_class(samples, "samples")
  checkmate::assert_list(pipelines)
  checkmate::assert_list(models)
  checkmate::assert_list(measure)
  checkmate::assert_data_frame(performance)
  checkmate::assert_class(final_model, "model", null.ok = TRUE)
  
  structure(
    list(
      type = type,
      name = name,
      uid = uid,
      version = version,
      desc = desc,
      scientist = scientist,
      created_on = Sys.time(),
      data = df,
      schema = schema,
      target = target,
      dir = dir,
      execution_strategy = execution_strategy,
      refit = refit,
      save_submodels = save_submodels,
      samples = samples,
      pipelines = pipelines,
      models = models,
      measure = measure,
      performance = performance,
      final_model = final_model,
      ...
    ),
    class = "modeler")
}


#' Modeler Validation function
valid_modeler <- function(obj){
  
  if (! obj$type %in% c("forecaster", "segmenter", "regressor", "classifier")) {
    stop("modeler type supplied not supported. Please use one of following: ",
         "\n* forecaster",
         "\n* segmenter",
         "\n* regressor",
         "\n* classifier")
  }
  
  if(! any(class(obj$data) %in% c("data.frame", "tbl_spark"))){
    stop("df input class not supported. modeler supports only data.frame and tbl_spark objects")
  }
  
  obj
}


#' Modeler Helper Function
#'
#' Function to create a valid modeler object to support model building use
#' cases. Modeler is the base class from which the other more specific use cases
#' like forecaster, regressor, segmenter, etc... inherit form
#'
#' @param df dataframe with target variable and any potential predictors
#' @param target target variable for supervised use cases such as forecaster,
#'   regressor, and classifier
#' @param type type of use case (forecaster, regressor, classifier, and
#'   segmenter)
#' @param name optional name for use case. Default is to append target with type
#' @param uid optional uid string. A random uid will be generated by default
#' @param version optional version string. will default to '1.0'
#' @param desc optional description of the use case.
#' @param scientist optional input for scientist building model. defaults to
#'   system user
#' @param execution_strategy name of evaluation function to use for resolving a
#'   future. Used for model training execution. default is sequential
#' @param refit logical option to refit model to entire training dataset sample.
#'   If grid parameters supplied, the best param set determined by validation
#'   sample performance will be used. Default is true
#' @param save_submodels logical flag to save sub model fits. Default is TRUE
#' @param dir optional directory path for saving reports, data and models
#' @param ... any addtional parameters
#'
#' @return modeler object
#' @export
#' @family use cases
#' @aliases modeler
#' @importFrom stats coef filter fitted predict setNames ts
#' @importFrom utils head modifyList
modeler <- function(df,
                    target,
                    type,
                    name = NULL,
                    uid = NULL,
                    version = NULL,
                    desc = NULL,
                    scientist = NULL,
                    execution_strategy = "sequential",
                    refit = TRUE,
                    save_submodels = TRUE,
                    dir = NULL,
                    ...){
  
  if(is.null(name)) name <- paste(target, type, sep = "-")
  if(is.null(uid)) uid <- sparklyr::random_string("modeler")
  if(is.null(version)) version <- "1.0"
  if(is.null(desc)) desc <- ""
  if(is.null(scientist)) scientist <- Sys.info()["user"]
  if(is.null(dir)) dir <- "./"
  default_samples <- add_default_samples(df)
  empty_pipes <- list()
  empty_models <- list()
  measure <- list()
  performance <- data.frame()
  final_model <- NULL
  schema <- get_schema(df)
  
  valid_modeler(
    new_modeler(
      df = df,
      schema = schema,
      target = target,
      type = type,
      name = name,
      uid = uid,
      version = version,
      desc = desc,
      scientist = scientist,
      dir = dir,
      execution_strategy = execution_strategy,
      refit = refit,
      save_submodels = save_submodels,
      samples = default_samples,
      pipelines = empty_pipes,
      models = empty_models,
      measure = measure,
      performance = performance,
      final_model = final_model,
      ...)
  )
}



# Modeler Functions -------------------------------------------------------



#' Get Models Status
#'
#' Function to return modeler's model statuses
#'
#' @param obj modeler object
#' @param uid one or more model uid characters
#' @export
get_models_status <- function(obj, uid = NULL){
  purrr::map(obj$models, "status")
}


#' Get All Modeler Models
#'
#' Function to access all modeler models. Subsettable by either uid or status
#'
#' @param obj modeler object
#' @param uids one or more model uid characters
#' @param status model status code. accepts "created", "added", "trained", or
#'   "selected"
#'
#' @return list of model objects
#' @export
get_models <- function(obj, uids = NULL, status = NULL) {
  checkmate::assert_class(obj, "modeler")
  checkmate::assert_character(uids, null.ok = TRUE)
  checkmate::assert_choice(status,
                           choices = c("created", "added", "trained", "selected", "final"),
                           null.ok = TRUE)
  
  models <- obj$models
  if(! is.null(uids))
    models <- purrr::keep(obj$models, names(obj$models) %in% uids)
  
  if(! is.null(status))
    models <- purrr::keep(models, get_models_status(models) == status)
  
  models
}



#' Get the Best Performing Model
#'
#' Function to select the best performing model based on modeler measure
#'
#' @param obj modeler object
#' @export
#' @return returns best model
get_best_model <- function(obj) {
  checkmate::assert_class(obj, "modeler")
  
  uid <- obj$performance %>%
    dplyr::arrange_at(obj$measure$method,
                      .funs = ifelse(obj$measure$minimize, identity, dplyr::desc)) %>%
    head(1) %>%
    dplyr::pull(model_uid)
  obj$models[[uid]]
}



#' Deploy Modeler Object
#'
#' Save Modeler object to file that can be restored later. Deploy uses
#' \code{\link{saveRDS}} function to serialize the R object
#'
#' @param obj modeler object to save
#' @param path file path to save to. Extension should be .rds
#' @param lighten logical flag to lighten the memory footprint of modeler
#'   objects by removing all fit and pipeline output from trained models. Note
#'   the final model fit and pipeline are not impacted
#' @inheritDotParams saveRDS -object -file
#'
#' @export
deploy <- function(obj, path, lighten = FALSE, ...) {
  checkmate::assert_class(obj, "modeler")
  checkmate::assert_directory(dirname(path))
  checkmate::assert_character(path, pattern = ".rds")
  checkmate::assert_flag(lighten)
  
  if(lighten) {
    for(i in seq_along(obj$models)) {
      obj$models[[i]]$fits <- NULL
    }
    for(i in seq_along(obj$pipelines)) {
      obj$pipelines[[i]]$output <- NULL
    }
  }
  
  saveRDS(object = obj, file = path, ...)
}


# Modeler Class Generics --------------------------------------------------



#' Execute Pipelines Generic Function
#'
#' Function executes all pipelines added to modeler object
#'
#' Only executes previous un-executed pipelines
#'
#' @param obj modeler object
#' @param ... additional arguments to pass to execute function
#'
#' @return updated modeler object
#' @export
execute_pipelines <- function(obj, ...) {
  UseMethod("execute_pipelines")
}


#' Train Models Generic Function
#'
#' Train all models added to a modeler object
#'
#' Function looks for all untrained models added to a modeler project. Function
#' fits model based on modeler samples, model method and model method args.
#' Function saves model fit, all fitted predictions to the training sample and
#' any validation predictions
#'
#' @param obj modeler object
#' @param ... additional arguments to pass to train function
#'
#' @export
#' @return updated modeler object
train_models <- function(obj, ...) {
  UseMethod("train_models")
}


#' Set Final Model Generic
#'
#' Function to select the final model. See method argument for options
#'
#' @param obj forecaster object
#' @param method selection method. Choices are 'manual' which requires a valid
#'   uid or 'best' method which selects the best model based on the measure
#' @param uid optional model uid input required for manual method
#' @param reevaluate logical option to re-evaluate the final model. Requires a
#'   test holdout sample
#' @export
set_final_model <- function(obj, method, uid, reevaluate) {
  UseMethod("set_final_model")
}


#' Tidy Model Performance Generic
#'
#' Function to extract model performance on all samples. Converts output to
#' data.frame
tidy_performance <- function(obj) {
  UseMethod("tidy_performance")
}


#' Get Target Data function
#'
#' Returns modeler target data
#'
#' @param obj object to extract target from
#' @export
get_target <- function(obj) {
  UseMethod("get_target", obj)
}


#' Get Dataset Schema
#'
#' Returns named list of column types. Names refer to column names
#'
#' @param df dataset
#'
#' @return named list of column types
#' @export
#'
#' @examples
#' get_schema(mtcars)
get_schema <- function(df){
  UseMethod("get_schema")
}



# Modeler Class Methods ---------------------------------------------------


#' @rdname execute_pipelines
#' @export
execute_pipelines.modeler <- function(obj, uids = NULL) {
  checkmate::assert_character(uids, null.ok = TRUE)
  
  if (is.null(uids))
    uids <- names(obj$pipelines)
  
  for(uid in uids) {
    pipe <- obj$pipelines[[uid]]
    if(is.null(pipe$output))
      obj$pipelines[[uid]] <- execute(obj$data, obj$pipelines[[uid]])
  }
  obj
}


#' @rdname train_models
#' @export
train_models.modeler <- function(obj, uids = NULL) {
  checkmate::assert_character(uids, null.ok = TRUE)
  
  # Execute pipes
  obj <- execute_pipelines(obj)
  
  if (is.null(uids)) {
    # Get Added only Models
    uids <- obj$models %>%
      purrr::map_df(., magrittr::extract, c("uid", "status")) %>%
      dplyr::filter(status == "added") %>%
      dplyr::pull(uid)
  }
  
  for (uid in uids) {
    
    # Get Training Sample
    train_data <- obj$pipelines[[obj$models[[uid]]$pipe]]$output
    
    # Check for holdout
    if (!is.null(obj$samples$test_holdout_prct)) {
      train_data <- train_data %>%
        dplyr::mutate(index = 1, index = row_number(index)) %>%
        dplyr::filter(!index %in% obj$samples$test_index) %>%
        dplyr::select(-index)
    }
    
    obj$models[[uid]] <- train_model(mobj = obj$models[[uid]],
                                     data = train_data,
                                     measure = obj$measure,
                                     samples = obj$samples,
                                     save_submodels = obj$save_submodels,
                                     execution_strategy = obj$execution_strategy)
    obj$models[[uid]]$status <- "trained"
    obj$models[[uid]]$last_updated <- Sys.time()
    obj$performance <- dplyr::bind_rows(
      obj$performance,
      obj$models[[uid]]$performance %>% 
        dplyr::mutate(model_uid = uid,
                      pipeline_uid = obj$models[[uid]]$pipe,
                      method = obj$models[[uid]]$method) %>% 
        dplyr::select(model_uid, pipeline_uid, method, submodel_uid, !!obj$measure$method, param_grid)
    )
  }
  
  obj
}





#' @export
print.modeler <- function(obj) {
  cat("---------------------------- \n")
  cat(obj$name, obj$type, "\n")
  cat("---------------------------- \n\n")
  cat("uid:         ", obj$uid, "\n")
  cat("version:    ", obj$version, "\n")
  cat("created on: ", as.character(obj$created_on), "\n")
  cat("created by: ", obj$scientist, "\n")
  cat("description:", obj$desc, "\n\n")
  cat("data ----------------------------", "\n\n")
  cat("target:", obj$target, "\n")
  cat("sample records:", "\n")
  print(head(obj$data))
  cat("\nsampling ----------------------------", "\n\n")
  cat("validation:", obj$samples$validation_method, "\n")
  cat("test holdout prct:",
      ifelse(is.null(obj$samples$test_holdout_prct), 0, obj$samples$test_holdout_prct),
      "\n")
  cat("\nmeasure ----------------------------", "\n\n")
  cat("measure name:", obj$measure$name, "\n")
  cat("\nmodels ----------------------------", "\n\n")
  print(get_models_status(obj))
  cat("\nperformance ----------------------------", "\n\n")
  print(obj$performance)
  cat("\nfinal model ----------------------------", "\n")
  cat("method:", obj$final_model$method, "\n")
  cat("method args:", unlist(obj$final_model$method_args), "\n")
  cat("desc:", obj$final_model$desc, "\n")
}


#' @export
summary.modeler <- print.modeler


#' @rdname get_target
#' @export
get_target.modeler <- function(obj) {
  obj$data %>%
    dplyr::select_at(c(obj$index_var, obj$target))
}



# Helper Functions --------------------------------------------------------


#' @rdname get_schema
#' @export
get_schema.data.frame <- function(df) {
  purrr::map(df, class)
}


#' @rdname get_schema
#' @export
get_schema.tbl_spark <- function(df) {
  purrr::map(sparklyr::sdf_schema(df), "type")
}
