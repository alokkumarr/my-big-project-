

# Modeler Class Functions -------------------------------------------------



#' New Modeler Object Constructer function
#' @import sparklyr
#' @import forecast
new_modeler <- function(df,
                        schema,
                        target,
                        type,
                        name,
                        id,
                        version,
                        desc,
                        scientist,
                        dir,
                        samples,
                        models,
                        measure,
                        evaluate,
                        final_model,
                        ...){

  checkmate::assert_list(schema)
  checkmate::assert_character(target, null.ok = TRUE)
  checkmate::assert_character(type)
  checkmate::assert_character(name)
  checkmate::assert_character(id)
  checkmate::assert_character(version)
  checkmate::assert_character(desc)
  checkmate::assert_character(scientist)
  checkmate::test_path_for_output(dir)
  checkmate::assert_class(samples, "samples")
  checkmate::assert_list(models)
  checkmate::assert_list(measure)
  checkmate::assert_data_frame(evaluate)
  checkmate::assert_class(final_model, "model", null.ok = TRUE)

  structure(
    list(
      type = type,
      name = name,
      id = id,
      version = version,
      desc = desc,
      scientist = scientist,
      created_on = Sys.time(),
      data = df,
      schema = schema,
      target = target,
      dir = dir,
      samples = samples,
      models = models,
      measure = measure,
      evaluate = evaluate,
      final_model = final_model,
      ...
    ),
    class = "modeler")
}


#' Modeler Validation function
valid_modeler <- function(x){

  if (! x$type %in% c("forecaster", "segmenter", "regressor", "classifier")) {
    stop("modeler type supplied not supported. Please use one of following: ",
         "\n* forecaster",
         "\n* segmenter",
         "\n* regressor",
         "\n* classifier")
  }

  if(! any(class(x$data) %in% c("data.frame", "tbl_spark"))){
    stop("df input class not supported. modeler supports only data.frame and tbl_spark objects")
  }

  x
}


#' Modeler Helper Function
#'
#' Function to create a valid modeler object to support model building use
#' cases. Modeler is the base class from which the other more specific use cases
#' like forecaster, regressor, segmenter, etc... inherit form
#'
#' @param df dataframe with target variable and any potential predictors
#' @param target target variable for supervised use cases such as forecaster,
#'   regressor, and classifier
#' @param type type of use case (forecaster, regressor, classifier, and
#'   segmenter)
#' @param name optional name for use case. Default is to append target with type
#' @param id optional id string. A random id will be generated by default
#' @param version optional version string. will default to '1.0'
#' @param desc optional description of the use case.
#' @param scientist optional input for scientist building model. defaults to
#'   system user
#' @param dir optional directory path for saving reports, data and models
#' @param ... any addtional parameters
#'
#' @return modeler object
#' @export
#' @family use cases
#' @aliases modeler
#' @importFrom stats coef filter fitted predict setNames ts
#' @importFrom utils head modifyList
modeler <- function(df,
                    target,
                    type,
                    name = NULL,
                    id = NULL,
                    version = NULL,
                    desc = NULL,
                    scientist = NULL,
                    dir = NULL,
                    ...){

  if(is.null(name)) name <- paste(target, type, sep = "-")
  if(is.null(id)) id <- sparklyr::random_string("id")
  if(is.null(version)) version <- "1.0"
  if(is.null(desc)) desc <- ""
  if(is.null(scientist)) scientist <- Sys.info()["user"]
  if(is.null(dir)) dir <- "./"
  default_samples <- add_default_samples(df)
  empty_models <- list()
  measure <- list()
  evaluate <- data.frame()
  final_model <- NULL
  schema <- get_schema(df)

  valid_modeler(
    new_modeler(
      df = df,
      schema = schema,
      target = target,
      type = type,
      name = name,
      id = id,
      version = version,
      desc = desc,
      scientist = scientist,
      dir = dir,
      samples = default_samples,
      models = empty_models,
      measure = measure,
      evaluate = evaluate,
      final_model = final_model,
      ...)
  )
}



# Modeler Functions -------------------------------------------------------



#' Get Models Status
#'
#' Function to return modeler's model statuses
#'
#' @param obj modeler object
#' @param id one or more model id characters
#' @export
get_models_status <- function(obj, id = NULL){

  models <- obj$models
  if(! is.null(id))
    models <- models[models$id  == id]

  sapply(obj$models, function(m) m$status)
}


#' Get All Modeler Models
#'
#' Function to access all modeler models. Subsettable by either id or status
#'
#' @param obj modeler object
#' @param ids one or more model id characters
#' @param status model status code. accepts "created", "added", "trained", "evaluated", or "selected"
#'
#' @return list of model objects
#' @export
get_models <- function(obj, ids = NULL, status = NULL) {
  checkmate::assert_class(obj, "modeler")
  checkmate::assert_character(ids, null.ok = TRUE)
  checkmate::assert_choice(status,
                           choices = c("created", "added", "trained", "evaluated", "selected", "final"),
                           null.ok = TRUE)

  models <- obj$models
  if(! is.null(ids))
    models <- models[names(models) %in% ids]

  if(! is.null(status))
    models <- models[sapply(models, function(m) m$status) == status]

  models
}



#' Get Model Evaluation Summary
#'
#' Returns data.frame with measure calculated on the validation samples
#' @param obj modeler object
#' @export
get_evalutions <- function(obj) {
  checkmate::assert_class(obj, "modeler")
  # mdls <- suppressWarnings(bind_rows(lapply(obj$models, function(m)
  #   data.frame(method = as.character(m$method))),
  #   .id = "model"))
  mdls <-
    suppressWarnings(purrr::map_dfr(obj$models, function(x)
      data.frame(method = x$method), .id = "model"))

  if (nrow(obj$evaluate) == 0) {
    obj$evaluate
  } else {
    dplyr::inner_join(mdls, obj$evaluate, by = "model")
  }
}


#' Get the Best Performing Model
#'
#' Function to select the best performing model based on modeler measure
#'
#' @param obj modeler object
#' @export
#' @return returns best model
get_best_model <- function(obj) {

  evals <- get_evalutions(obj)
  smpl <- ifelse("validation" %in% evals$sample, "validation", "train")
  id <- evals %>%
    dplyr::filter_at("sample", dplyr::any_vars(. == smpl)) %>%
    dplyr::group_by(model) %>%
    dplyr::summarise_at(obj$measure$method, mean) %>%
    dplyr::arrange_at(obj$measure$method,
                      .funs = ifelse(obj$measure$minimize, identity, dplyr::desc)) %>%
    head(1) %>%
    dplyr::pull(model)
  get_models(obj, ids = id)[[1]]
}


# Modeler Class Generics --------------------------------------------------


#' Train Model Generic Function
#'
#' Train all models added to a modeler object
#'
#' Function looks for all untrained models added to a modeler project. Function
#' fits model based on modeler samples, model method and model method args.
#' Function saves model fit, all fitted predictions to the training sample and
#' any validation predictions
#'
#' @export
#' @return updated modeler object
train_models <- function(obj, ...) {
  UseMethod("train_models")
}


#' Evaluate Models Generic Function
#'
#' Evaluate the accuracy of all trained models.
#'
#' Function applies the measure function associated with modeler object to all
#' model sample predictions.
#'
#' @param obj modeler object
#' @param ids optional input for model id. default is NULL and all trained
#'   models evaluated
#'
#' @export
#' @return updated modeler object
evaluate_models <- function(obj, ids, ...) {
  UseMethod("evaluate_models")
}


#' Set Final Model Generic
#'
#' Function to select the final model. See method argument for options
#'
#' @param obj forecaster object
#' @param method selection method. Choices are 'manual' which requires a valid
#'   id or 'best' method which selects the best model based on the measure
#' @param id optional model id input required for manual method
#' @param reevaluate logical option to re-evaluate the final model. Requires a
#'   test holdout sample
#' @param refit logical option to re-fit final model on entire training dataset
#' @export
set_final_model <- function(obj, method, id, reevaluate, refit) {
  UseMethod("set_final_model")
}


#' Get Target Dataframe Generic Method
#'
#' Returns modeler target data
#'
#' @inheritParams modeler
#' @export
get_target_df <- function(df, target) {
  UseMethod("get_target_df")
}


#' Tidy Model Performance Generic
#'
#' Function to extract model performance on all samples. Converts output to
#' data.frame
tidy_performance <- function(obj) {
  UseMethod("tidy_performance")
}


#' Get Target Data function
#'
#' Returns modeler target data
#'
#' @param obj object to extract target from
#' @export
get_target <- function(obj) {
  UseMethod("get_target", obj)
}



#' Get Dataset Schema
#'
#' Returns named list of column types. Names refer to column names
#'
#' @param df dataset
#'
#' @return named list of column types
#' @export
#'
#' @examples
#' get_schema(mtcars)
get_schema <- function(df){
  UseMethod("get_schema")
}


# Modeler Class Methods ---------------------------------------------------


#' @rdname train_models
#' @export
train_models.modeler <- function(obj, ids = NULL) {
  checkmate::assert_character(ids, null.ok = TRUE)

  status <- get_models_status(obj)
  if (!is.null(ids))
    status <- status[names(status) %in% ids]
  ids <- names(status[status == "added"])
  indicies <- get_indicies(obj)

  for (id in ids) {
    model <- get_models(obj, ids = id)[[1]]
    model$pipe <- execute(obj$data, model$pipe)
    model$index_var <- obj$index_var
    model <- train(model, indicies, level = obj$conf_levels)
    obj$models[[id]] <- model
  }
  obj
}


#' @rdname set_final_model
#' @export
set_final_model.modeler <- function(obj,
                                    method,
                                    id = NULL,
                                    reevaluate = TRUE,
                                    refit = TRUE) {
  checkmate::assert_choice(method, c("manual", "best"))
  checkmate::assert_character(id, null.ok = TRUE)
  checkmate::assert_flag(reevaluate)
  checkmate::assert_flag(refit)
  if (!is.null(id))
    checkmate::assert_choice(id, names(get_models(obj)))
  if (method == "manual" & is.null(id))
    stop("final model not selected: id not provided for manual method")

  if (method == "best") {
    model <- get_best_model(obj)
    id <- model$id
  }else{
    model <- get_models(obj, ids = id)[[1]]
  }

  model$status <- "selected"
  obj$models[[id]] <- model
  df_index <- holdout(obj$data, 1)$head

  if (reevaluate) {
    if (is.null(obj$samples$test_holdout_prct)) {
      warning("Missing Test Holdout Sample. Final Model not re-evaluated.")
    } else{
      val_indicie <- list("test_holdout" =
                            list("train" = setdiff(df_index, obj$samples$test_index),
                                 "test"  = obj$samples$test_index))
      remodel <- train(model, val_indicie, obj$conf_levels)
      remodel <- evaluate(remodel, obj$measure)
      obj$evaluate <- rbind(obj$evaluate, remodel$evaluate)
    }
  }

  if (refit) {
    refit_indicie <- list("train" = list("train" = df_index))
    final_model <- train(model, refit_indicie, level = obj$conf_level)
    obj$final_model <- final_model
  }else{
    obj$final_model <- model
  }

  obj
}


#' @rdname evaluate_models
#' @export
evaluate_models.modeler <- function(obj, ids = NULL) {
  checkmate::assert_character(ids, null.ok = TRUE)

  status <- get_models_status(obj)
  if (!is.null(ids))
    status <- status[names(status) %in% ids]
  ids <- names(status == "trained")

  for (id in ids) {
    model <- get_models(obj, ids = id)[[1]]
    model <- evaluate(model, obj$measure)
    obj$models[[id]] <- model
    obj$evaluate <- rbind(obj$evaluate, model$evaluate)
  }
  obj
}


# Tidy Performance Method
#' @export
tidy_performance.modeler <- function(obj) {

  status <- get_models_status(obj)
  ids <- names(status == "trained")
  dplyr::bind_rows(lapply(obj$models, tidy_performance))
}


#' @export
print.modeler <- summary.modeler <- function(obj) {
  cat("---------------------------- \n")
  cat(obj$name, obj$type, "\n")
  cat("---------------------------- \n\n")
  cat("id:         ", obj$id, "\n")
  cat("version:    ", obj$version, "\n")
  cat("created on: ", as.character(obj$created_on), "\n")
  cat("created by: ", obj$scientist, "\n")
  cat("description:", obj$desc, "\n\n")
  cat("data ----------------------------", "\n\n")
  cat("target:", obj$target, "\n")
  cat("sample records:", "\n")
  print(head(obj$data))
  cat("\nsampling ----------------------------", "\n\n")
  cat("validation:", obj$samples$validation_method, "\n")
  cat("test holdout prct:",
      ifelse(is.null(obj$samples$test_holdout_prct), 0, obj$samples$test_holdout_prct),
      "\n")
  cat("\nmeasure ----------------------------", "\n\n")
  cat("measure name:", obj$measure$name, "\n")
  cat("\nmodels ----------------------------", "\n\n")
  print(get_models_status(obj))
  cat("\nevaluation ----------------------------", "\n\n")
  print(get_evalutions(obj))
  cat("\nfinal model ----------------------------", "\n")
  cat("method:", obj$final_model$method, "\n")
  cat("method args:", unlist(obj$final_model$method_args), "\n")
  cat("desc:", obj$final_model$desc, "\n")
}


#' @rdname get_target
#' @export
get_target.modeler <- function(obj) {
  checkmate::assert_subset("modeler", class(obj))
  #get_target_df(obj$data, obj$target)
  obj$data %>%
    dplyr::select_at(c(obj$index_var, obj$target))
}


# Helper Functions --------------------------------------------------------



#' @rdname get_target_df
#' @export
get_target_df.data.frame <- function(df, target) {
  checkmate::assert_subset(target, colnames(df))
  df[, target, drop=FALSE]
}


#' @rdname get_schema
#' @export
get_schema.data.frame <- function(df) {
  purrr::map(df, class)
}

#' @rdname get_schema
#' @export
get_schema.tbl_spark <- function(df) {
  purrr::map(sparklyr::sdf_schema(df), "type")
}
