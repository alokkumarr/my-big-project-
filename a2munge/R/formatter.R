#'Date Period Formatter Function
#'
#'Date Period formatter function which is configurable & can be used in
#'other a2 functions to get required formatted Date value. Return column
#'will be of the class string.
#'
#'@param df DataFrame
#'@param measure_vars Input Date column on which transformation has to be applied
#'@param input_format Input format of Date column. Allowed formats are
#' MM/dd/yyyy HH:mm:ss, MM/dd/yyyy, yyyy/MM/dd HH:mm:ss, yyyy/MM/dd,
#' dd/MM/yyyy HH:mm:ss, dd/MM/yyyy. The forward slash symbol can be interchanged
#' with hifen.
#'@param output_format Required format for the output Date column. Default value
#' is "yyyy-MM-dd HH:mm:ss"
#'@param output_suffix Suffix to be added to the new column generated by the function
#'
#'@return returns DataFrame with formatted string column added with name as
#' {INPUT_COLUMN_NAME}_FMT
#'
#'@export
#'
#'
#'@examples
#'
#'library(dplyr)
#'library(lubridate)
#'
#'date_func_df <- data.frame(TIME_COL = as.POSIXlt(c("2017-01-01 10:15:15", "2017-09-23 14:26:59", "2017-11-15 05:05:05", "2018-05-11 08:15:18", "2018-03-27 23:59:59")), stringsAsFactors = FALSE)
#'
#'formatter(date_func_df, "TIME_COL", "yyyy-MM-dd HH:mm:ss", "MM/dd/yyyy HH:mm:ss")

formatter <-
  function(df,
           measure_vars,
           input_format,
           output_format,
           output_suffix) {
    UseMethod("formatter")
  }


#' @rdname formatter
#' @export
formatter.data.frame <- function(df,
                                 measure_vars,
                                 input_format,
                                 output_format = "yyyy-MM-dd HH:mm:ss",
                                 output_suffix = "FMT") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(
    input_format,
    c(
      "MM/dd/yyyy HH:mm:ss",
      "MM/dd/yyyy",
      "MM-dd-yyyy HH:mm:ss",
      "MM-dd-yyyy",
      "MM/dd/yy HH:mm:ss",
      "MM/dd/yy",
      "MM-dd-yy HH:mm:ss",
      "MM-dd-yy",
      "yyyy-MM-dd HH:mm:ss",
      "yyyy-MM-dd",
      "yyyy/MM/dd HH:mm:ss",
      "yyyy/MM/dd",
      "dd-MM-yyyy HH:mm:ss",
      "dd-MM-yyyy",
      "dd/MM/yyyy HH:mm:ss",
      "dd/MM/yyyy"
    )
  )

  checkmate::assert_choice(
    output_format,
    c(
      "MM/dd/yyyy HH:mm:ss",
      "MM/dd/yyyy",
      "MM-dd-yyyy HH:mm:ss",
      "MM-dd-yyyy",
      "yyyy-MM-dd HH:mm:ss",
      "yyyy-MM-dd",
      "yyyy/MM/dd HH:mm:ss",
      "yyyy/MM/dd",
      "dd-MM-yyyy HH:mm:ss",
      "dd-MM-yyyy",
      "dd/MM/yyyy HH:mm:ss",
      "dd/MM/yyyy"
    )
  )

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  # Get a list of columns to be extracted so that all intermediate columns are removed
  # from final result

  select_vars <- c(colnames(df), output_col_name)

  if(length(measure_vars) == 1) {
    f1_col_name <- "F1"
    f2_col_name <- "F2"
  } else {
    f1_col_name <- paste(measure_vars, "F1", sep = "_")
    f2_col_name <- paste(f1_col_name, "F2", sep = "_")
  }

  # Derive the Input & Output formats required for R data frames in the
  # format required for the lubridate functions

  chk_input_format <- gsub("[^A-z0-9_ ]", "", input_format)
  inp_for_chk <- ""

  inp_for_chk <-
    dplyr::case_when(
      chk_input_format == "MMddyyyy HHmmss" ~ "mdy_hms",
      chk_input_format == "MMddyyyy" ~ "mdy",
      chk_input_format == "MMddyy" ~ "mdy",
      chk_input_format == "yyyyMMdd HHmmss" ~ "ymd_hms",
      chk_input_format == "yyyyMMdd" ~ "ymd",
      chk_input_format == "ddMMyyyy HHmmss" ~ "dmy_hms",
      chk_input_format == "ddMMyyyy" ~ "dmy"
    )

  rdf_output_format <-
    dplyr::case_when(
      output_format == "MM/dd/yyyy HH:mm:ss" ~ "%m/%d/%Y %H:%M:%S",
      output_format == "MM/dd/yyyy" ~ "%m/%d/%Y",
      output_format == "MM-dd-yyyy HH:mm:ss" ~ "%m-%d-%Y %H:%M:%S",
      output_format == "MM-dd-yyyy" ~ "%m-%d-%Y",
      output_format == "MM-dd-yy HH:mm:ss" ~ "%m-%d-%Y %H:%M:%S",
      output_format == "MM-dd-yy" ~ "%m-%d-%Y",
      output_format == "MM/dd/yy HH:mm:ss" ~ "%m-%d-%Y %H:%M:%S",
      output_format == "MM/dd/yy" ~ "%m-%d-%Y",
      output_format == "yyyy-MM-dd HH:mm:ss" ~ "%Y-%m-%d %H:%M:%S",
      output_format == "yyyy-MM-dd" ~ "%Y-%m-%d",
      output_format == "yyyy/MM/dd HH:mm:ss" ~ "%Y/%m/%d %H:%M:%S",
      output_format == "yyyy/MM/dd" ~ "%Y/%m/%d",
      output_format == "dd-MM-yyyy HH:mm:ss" ~ "%d-%m-%Y %H:%M:%S",
      output_format == "dd-MM-yyyy" ~ "%d-%m-%Y",
      output_format == "dd/MM/yyyy HH:mm:ss" ~ "%d/%m/%Y %H:%M:%S",
      output_format == "dd/MM/yyyy" ~ "%d/%m/%Y"
    )

  # Update the DF with the output column which will have required
  # format date value

  dt_chk_fun <- match.fun(inp_for_chk)

  df <- df %>%
    dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 = dt_chk_fun)
    ) %>%
    dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = format, .args = list(rdf_output_format))
    ) %>%
    dplyr::rename_(., .dots = setNames(f2_col_name, output_col_name)) %>%
    select(., select_vars)

  df
}



#' @rdname formatter
#' @export
formatter.tbl_spark <- function(df,
                                measure_vars,
                                input_format,
                                output_format = "yyyy-MM-dd HH:mm:ss",
                                output_suffix = "FMT") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(
    input_format,
    c(
      "MM/dd/yyyy HH:mm:ss",
      "MM/dd/yyyy",
      "MM-dd-yyyy HH:mm:ss",
      "MM-dd-yyyy",
      "MM/dd/yy HH:mm:ss",
      "MM/dd/yy",
      "MM-dd-yy HH:mm:ss",
      "MM-dd-yy",
      "yyyy-MM-dd HH:mm:ss",
      "yyyy-MM-dd",
      "yyyy/MM/dd HH:mm:ss",
      "yyyy/MM/dd",
      "dd-MM-yyyy HH:mm:ss",
      "dd-MM-yyyy",
      "dd/MM/yyyy HH:mm:ss",
      "dd/MM/yyyy"
    )
  )

  checkmate::assert_choice(
    output_format,
    c(
      "MM/dd/yyyy HH:mm:ss",
      "MM/dd/yyyy",
      "MM-dd-yyyy HH:mm:ss",
      "MM-dd-yyyy",
      "yyyy-MM-dd HH:mm:ss",
      "yyyy-MM-dd",
      "yyyy/MM/dd HH:mm:ss",
      "yyyy/MM/dd",
      "dd-MM-yyyy HH:mm:ss",
      "dd-MM-yyyy",
      "dd/MM/yyyy HH:mm:ss",
      "dd/MM/yyyy"
    )
  )

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  select_vars <- c(colnames(df), output_col_name)

  if(length(measure_vars) == 1) {
    f1_col_name <- "F1"
    f2_col_name <- "F2"
  } else {
    f1_col_name <- paste(measure_vars, "F1", sep = "_")
    f2_col_name <- paste(f1_col_name, "F2", sep = "_")
  }

  # If period is Month & Collapse direction is end, Last_Day function has
  # to be used to get last day of the month.
  # Important Note. More testing is required to check if Time zones might be
  # an issue here due to the usage of epoch time for date formatting.

  df <- df %>%
    dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                          unix_timestamp, .args = list(input_format))
    ) %>%
    dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = from_unixtime, .args = list(output_format))
    ) %>%
    dplyr::rename_(., .dots = setNames(f2_col_name, output_col_name)) %>%
    select(., select_vars)

  df
}
