#'Date Interval Ceiling Value function
#'
#'This is a function to extract the maximum possible value for a date column
#'for a given interval
#'
#'For R data frames, the base ceiling date function will be used from the lubridate
#'package with logic to negate the resulting date value by 1 period of the relevant
#'interval Function returns a date value which will be the maximum possible value.
#'For Spark data frames, SQL logic has been coded to get the ceiling date. The output
#'format will be yyyy-MM-dd or yyyy-MM-dd HH:mm:ss only since Spark SQL does not allow
#'formatted Dates
#'
#'@param df Dataframe
#'@param measure_vars Input Date column for which ceiling date has to be derived
#'@param unit Period for which collapsing logic has to be applied
#'@param side Direction in which collapsing logic has to be applied
#'@param time_zone Timezone to be considered for Date manipulation. Default is UTC.
#'@param output_suffix Suffix to be added to the new column generated by the function
#'
#'@return returns DataFrame with ceiling date value derived on column {INPUT_COLUMN_NAME}_CEI
#'
#'
#'@export
#'
#'
#'@examples
#'
#'library(dplyr)
#'library(lubridate)
#'
#'date_func_df <- data.frame(TIME_COL = as.POSIXlt(c("2017-01-01 10:15:15", "2017-09-23 14:26:59", "2017-11-15 05:05:05", "2018-05-11 08:15:18", "2018-03-27 23:59:59")), stringsAsFactors = FALSE)
#'
#'collapser(date_func_df, "TIME_COL", "month", "end")

collapser <- function(df,
                      measure_vars,
                      unit,
                      side,
                      time_zone,
                      output_suffix) {
  UseMethod("collapser")
}

#' @rdname collapser
#' @export
collapser.data.frame <- function(df,
                                 measure_vars,
                                 unit,
                                 side,
                                 time_zone = "UTC",
                                 output_suffix = "CEI") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(unit,
                           c("minute",
                             "hour",
                             "day",
                             "month",
                             "year"))

  checkmate::assert_subset(side,
                           c("start",
                             "end"))

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  select_vars <- c(colnames(df), output_col_name)

  if(length(measure_vars) == 1) {
    f1_col_name <- "F1"
    f2_col_name <- "F2"
    f3_col_name <- "F3"
  } else {
    f1_col_name <- paste(measure_vars, "F1", sep = "_")
    f2_col_name <- paste(f1_col_name, "F2", sep = "_")
    f3_col_name <- paste(f2_col_name, "F3", sep = "_")
  }

  if (unit == "month" || unit == "year") {

    if (side == "start") {
      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              lubridate::floor_date, .args = list(unit))
        ) %>%
        dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = as.Date, .args = list(time_zone))
        ) %>%
        dplyr::rename_(., .dots = setNames(f2_col_name, output_col_name)) %>%
        select(., select_vars)
    } else {
      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              lubridate::ceiling_date, .args = list(unit))
        ) %>%
        dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 =
                                                             . - 1)
        ) %>%
        dplyr::mutate_at(.vars = f2_col_name, .funs = funs(F3 = as.Date, .args = list(time_zone))
        ) %>%
        dplyr::rename_(., .dots = setNames(f3_col_name, output_col_name)) %>%
        select(., select_vars)
    }
  } else {

    if (side == "start") {
      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              lubridate::floor_date, .args = list(unit))
        ) %>%
        dplyr::rename_(., .dots = setNames(f1_col_name, output_col_name)) %>%
        select(., select_vars)
    } else {
      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              lubridate::ceiling_date, .args = list(unit))
        ) %>%
        dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 =
                                                             . - 1)
        ) %>%
        dplyr::rename_(., .dots = setNames(f2_col_name, output_col_name)) %>%
        select(., select_vars)
    }
  }

  df

}


#' @rdname collapser
#' @export
collapser.tbl_spark <- function(df,
                                measure_vars,
                                unit,
                                side,
                                time_zone = "UTC",
                                output_suffix = "CEI") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(unit,
                           c("minute",
                             "hour",
                             "day",
                             "month",
                             "year"))

  checkmate::assert_subset(side,
                           c("start",
                             "end"))

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  # Get a list of columns to be extracted so that all intermediate columns are removed
  # from final result

  select_vars <- c(colnames(df), output_col_name)

  if(length(measure_vars) == 1) {
    f1_col_name <- "F1"
    f2_col_name <- "F2"
    f3_col_name <- "F3"
    f4_col_name <- "F4"
  } else {
    f1_col_name <- paste(measure_vars, "F1", sep = "_")
    f2_col_name <- paste(f1_col_name, "F2", sep = "_")
    f3_col_name <- paste(f2_col_name, "F3", sep = "_")
    f4_col_name <- paste(f3_col_name, "F4", sep = "_")
  }

  d_sub <- ifelse(side == "start", 0, 1)

  if (unit %in% c("year", "month")) {
    m_add <- ifelse(side == "start", 0, ifelse(unit == "month", 1, 12))

    df <- df %>%
      dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                            add_months, .args = list(m_add))
      ) %>%
      dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = trunc, .args = list(unit))
      ) %>%
      dplyr::mutate_at(.vars = f2_col_name, .funs = funs(F3 = date_sub, .args = list(d_sub))
      ) %>%
      dplyr::rename_(., .dots = setNames(f3_col_name, output_col_name)) %>%
      select(., select_vars)

  } else {
    r_num <- ifelse(unit == "minute", 60,
                    ifelse(unit == "hour", 60 ^ 2, 60 ^ 2 * 24))

    if (side == "start") {

      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              unix_timestamp(.)/r_num)
        ) %>%
        dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = floor(.) * r_num - d_sub)
        ) %>%
        dplyr::mutate_at(.vars = f2_col_name, .funs = funs(F3 = from_unixtime)
        ) %>%
        dplyr::mutate_at(.vars = f3_col_name, .funs = funs(F4 = to_utc_timestamp, .args = list(time_zone))
        ) %>%
        dplyr::rename_(., .dots = setNames(f4_col_name, output_col_name)) %>%
        select(., select_vars)

    } else {

      df <- df %>%
        dplyr::mutate_at(.vars = measure_vars, .funs = funs(F1 =
                                                              unix_timestamp(.)/r_num)
        ) %>%
        dplyr::mutate_at(.vars = f1_col_name, .funs = funs(F2 = ceiling(.) * r_num - d_sub)
        ) %>%
        dplyr::mutate_at(.vars = f2_col_name, .funs = funs(F3 = from_unixtime)
        ) %>%
        dplyr::mutate_at(.vars = f3_col_name, .funs = funs(F4 = to_utc_timestamp, .args = list(time_zone))
        ) %>%
        dplyr::rename_(., .dots = setNames(f4_col_name, output_col_name)) %>%
        select(., select_vars)
    }
  }

  df

}
