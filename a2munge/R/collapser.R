#'Date Interval Ceiling Value function
#'
#'This is a function to extract the maximum possible value for a date column
#'for a given interval
#'
#'For R data frames, the base ceiling date function will be used from the lubridate
#'package with logic to negate the resulting date value by 1 period of the relevant
#'interval Function returns a date value which will be the maximum possible value.
#'For Spark data frames, SQL logic has been coded to get the ceiling date. The output
#'format will be yyyy-MM-dd or yyyy-MM-dd HH:mm:ss only since Spark SQL does not allow
#'formatted Dates
#'
#'@param df Dataframe
#'@param measure_vars Input Date column for which ceiling date has to be derived
#'@param unit Period for which collapsing logic has to be applied
#'@param side Direction in which collapsing logic has to be applied
#'@param time_zone Timezone to be considered for Date manipulation. Default is UTC.
#'@param output_suffix Suffix to be added to the new column generated by the function
#'
#'@return returns DataFrame with ceiling date value derived on column {INPUT_COLUMN_NAME}_CEI
#'
#'
#'@export
#'
#'
#'@examples
#'
#'library(dplyr)
#'library(lubridate)
#'
#'date_func_df <- data.frame(TIME_COL = as.POSIXlt(c("2017-01-01 10:15:15", "2017-09-23 14:26:59", "2017-11-15 05:05:05", "2018-05-11 08:15:18", "2018-03-27 23:59:59")), stringsAsFactors = FALSE)
#'
#'collapser(date_func_df, "TIME_COL", "month", "end")

collapser <- function(df,
                      measure_vars,
                      unit,
                      side,
                      time_zone,
                      output_suffix) {
  UseMethod("collapser")
}

#' @rdname collapser
#' @export
collapser.data.frame <- function(df,
                                 measure_vars,
                                 unit,
                                 side,
                                 time_zone = "UTC",
                                 output_suffix = "CEI") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(unit,
                           c("minute",
                             "hour",
                             "day",
                             "month",
                             "year"))

  checkmate::assert_subset(side,
                           c("start",
                             "end"))

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  if (unit == "month" || unit == "year") {
    df <- df %>%
      dplyr::rename(., DT_CEI_1 = !!measure_vars) %>%
      mutate(.,!!output_col_name := case_when((
        (!!side == "start") ~ as.Date(lubridate::floor_date(DT_CEI_1, unit = !!unit), tz = !!time_zone)
      ),
      (
        !!side == "end" ~ as.Date(lubridate::ceiling_date(DT_CEI_1, unit = !!unit) - 1, tz = !!time_zone)
      ))) %>%
      dplyr::rename(.,!!measure_vars := DT_CEI_1)
  } else {
    df <- df %>%
      dplyr::rename(., DT_CEI_1 = !!measure_vars) %>%
      mutate(.,!!output_col_name := case_when(
        (
          (!!side == "start") ~ lubridate::floor_date(DT_CEI_1, unit = !!unit)
        ),
        (
          !!side == "end" ~ lubridate::ceiling_date(DT_CEI_1, unit = !!unit) - 1
        )
      )) %>%
      dplyr::rename(.,!!measure_vars := DT_CEI_1)
  }

  df

}


#' @rdname collapser
#' @export
collapser.tbl_spark <- function(df,
                                measure_vars,
                                unit,
                                side,
                                time_zone = "UTC",
                                output_suffix = "CEI") {
  checkmate::assert_subset(measure_vars, colnames(df), empty.ok = TRUE)

  checkmate::assert_choice(unit,
                           c("minute",
                             "hour",
                             "day",
                             "month",
                             "year"))

  checkmate::assert_subset(side,
                           c("start",
                             "end"))

  # Derive Output colum name by adding a configured suffix

  output_col_name <- paste(measure_vars, output_suffix, sep = "_")

  d_sub <- ifelse(side == "start", 0, 1)

  if (unit %in% c("year", "month")) {
    m_add <- ifelse(side == "start", 0, ifelse(unit == "month", 1, 12))

    df <- df %>%
      rename(., DT_CHK_1 = !!measure_vars) %>%
      mutate(., !!output_col_name := date_sub(trunc(add_months(DT_CHK_1, !!m_add), !!unit), !!d_sub)) %>%
      rename(., !!measure_vars := DT_CHK_1)
  } else {
    r_num <- ifelse(unit == "minute", 60,
                    ifelse(unit == "hour", 60 ^ 2, 60 ^ 2 * 24))

    if (side == "start") {
      df <- df %>%
        rename(., DT_CHK_1 = !!measure_vars) %>%
        mutate(.,
               !!output_col_name := to_utc_timestamp(from_unixtime(floor((unix_timestamp(DT_CHK_1)) / !!r_num
               ) * !!r_num - !!d_sub), !!time_zone)) %>%
        rename(., !!measure_vars := DT_CHK_1)
    } else {
      df <- df %>%
        rename(., DT_CHK_1 = !!measure_vars) %>%
        mutate(.,
               !!output_col_name := to_utc_timestamp(from_unixtime(
                 ceiling((unix_timestamp(
                   DT_CHK_1
                 )) / !!r_num) * !!r_num - !!d_sub
               ), !!time_zone)) %>%
        rename(., !!measure_vars := DT_CHK_1)
    }
  }

  df

}