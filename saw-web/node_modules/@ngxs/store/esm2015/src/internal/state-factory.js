/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injector, Injectable, SkipSelf, Optional } from '@angular/core';
import { Observable, of, forkJoin, from, throwError } from 'rxjs';
import { shareReplay, takeUntil, map, catchError, filter, mergeMap, defaultIfEmpty } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { topologicalSort, buildGraph, findFullParentPath, nameToState, propGetter, isObject } from './internals';
import { getActionTypeFromInstance, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._states = [];
        this._connected = false;
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * Add a new state to the global defs.
     * @param {?} oneOrManyStateClasses
     * @return {?}
     */
    add(oneOrManyStateClasses) {
        /** @type {?} */
        let stateClasses;
        if (!Array.isArray(oneOrManyStateClasses)) {
            stateClasses = [oneOrManyStateClasses];
        }
        else {
            stateClasses = oneOrManyStateClasses;
        }
        /** @type {?} */
        const stateGraph = buildGraph(stateClasses);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(stateClasses);
        /** @type {?} */
        const mappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            const depth = depths[name];
            const { actions } = stateClass[META_KEY];
            let { defaults } = stateClass[META_KEY];
            stateClass[META_KEY].path = depth;
            stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this._config);
            // ensure our store hasn't already been added
            // but dont throw since it could be lazy
            // loaded from different paths
            /** @type {?} */
            const has = this.states.find(s => s.name === name);
            if (!has) {
                // create new instance of defaults
                if (Array.isArray(defaults)) {
                    defaults = [...defaults];
                }
                else if (isObject(defaults)) {
                    defaults = Object.assign({}, defaults);
                }
                else if (defaults === undefined) {
                    defaults = {};
                }
                /** @type {?} */
                const instance = this._injector.get(stateClass);
                mappedStores.push({
                    actions,
                    instance,
                    defaults,
                    name,
                    depth
                });
            }
        }
        this.states.push(...mappedStores);
        return mappedStores;
    }
    /**
     * Add a set of states to the store and return the defaulsts
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        if (stateClasses) {
            /** @type {?} */
            const states = this.add(stateClasses);
            /** @type {?} */
            const defaults = states.reduce((result, meta) => setValue(result, meta.depth, meta.defaults), {});
            return { defaults, states };
        }
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(({ action }) => this.invokeActions(this._actions, action).pipe(map(() => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ }))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError(error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))
            .subscribe(ctx => this._actionResults.next(ctx));
        this._connected = true;
    }
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    invokeInit(stateMetadatas) {
        for (const metadata of stateMetadatas) {
            /** @type {?} */
            const instance = metadata.instance;
            if (instance.ngxsOnInit) {
                /** @type {?} */
                const stateContext = this.createStateContext(metadata);
                instance.ngxsOnInit(stateContext);
            }
        }
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = getActionTypeFromInstance(action);
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            result = result.pipe(actionMeta.options.cancelUncompleted
                                ? takeUntil(actions$.pipe(ofActionDispatched(action)))
                                : map(r => r)); // map acts like a noop
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * Create the state context
     * @private
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        return this._stateContextFactory.createStateContext(metadata);
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekUsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNHLE9BQU8sRUFBRSxRQUFRLEVBQWlCLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNqRSxPQUFPLEVBQ0wsZUFBZSxFQUNmLFVBQVUsRUFDVixrQkFBa0IsRUFDbEIsV0FBVyxFQUNYLFVBQVUsRUFDVixRQUFRLEVBR1QsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxlQUFlLEVBQStCLE1BQU0sbUJBQW1CLENBQUM7QUFDakYsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7Ozs7O0FBT3hFLE1BQU0sT0FBTyxZQUFZOzs7Ozs7Ozs7SUFRdkIsWUFDVSxTQUFtQixFQUNuQixPQUFtQixFQUduQixjQUE0QixFQUM1QixRQUF5QixFQUN6QixjQUErQyxFQUMvQyxvQkFBeUM7UUFQekMsY0FBUyxH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U2tpcFNlbGYsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmb3JrSm9pbiwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzaGFyZVJlcGxheSwgdGFrZVVudGlsLCBtYXAsIGNhdGNoRXJyb3IsIGZpbHRlciwgbWVyZ2VNYXAsIGRlZmF1bHRJZkVtcHR5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNMaWZlQ3ljbGUsIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHtcclxuICB0b3BvbG9naWNhbFNvcnQsXHJcbiAgYnVpbGRHcmFwaCxcclxuICBmaW5kRnVsbFBhcmVudFBhdGgsXHJcbiAgbmFtZVRvU3RhdGUsXHJcbiAgcHJvcEdldHRlcixcclxuICBpc09iamVjdCxcclxuICBTdGF0ZUNsYXNzLFxyXG4gIE1hcHBlZFN0b3JlXHJcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IHtcclxuICBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnlcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXHJcbiAgICovXHJcbiAgYWRkKG9uZU9yTWFueVN0YXRlQ2xhc3NlczogU3RhdGVDbGFzcyB8IFN0YXRlQ2xhc3NbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgbGV0IHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9uZU9yTWFueVN0YXRlQ2xhc3NlcykpIHtcclxuICAgICAgc3RhdGVDbGFzc2VzID0gW29uZU9yTWFueVN0YXRlQ2xhc3Nlc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBvbmVPck1hbnlTdGF0ZUNsYXNzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdGVHcmFwaCA9IGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHNvcnRlZFN0YXRlcyA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IGRlcHRocyA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IG5hbWVHcmFwaCA9IG5hbWVUb1N0YXRlKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3MgPSBuYW1lR3JhcGhbbmFtZV07XHJcblxyXG4gICAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGVwdGggPSBkZXB0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IHsgYWN0aW9ucyB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICAgIGxldCB7IGRlZmF1bHRzIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuXHJcbiAgICAgIHN0YXRlQ2xhc3NbTUVUQV9LRVldLnBhdGggPSBkZXB0aDtcclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0uc2VsZWN0RnJvbUFwcFN0YXRlID0gcHJvcEdldHRlcihkZXB0aC5zcGxpdCgnLicpLCB0aGlzLl9jb25maWcpO1xyXG5cclxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgIC8vIGJ1dCBkb250IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcclxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXHJcbiAgICAgIGNvbnN0IGhhcyA9IHRoaXMuc3RhdGVzLmZpbmQocyA9PiBzLm5hbWUgPT09IG5hbWUpO1xyXG4gICAgICBpZiAoIWhhcykge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgZGVmYXVsdHNcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0gWy4uLmRlZmF1bHRzXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9pbmplY3Rvci5nZXQoc3RhdGVDbGFzcyk7XHJcblxyXG4gICAgICAgIG1hcHBlZFN0b3Jlcy5wdXNoKHtcclxuICAgICAgICAgIGFjdGlvbnMsXHJcbiAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgIGRlZmF1bHRzLFxyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGRlcHRoXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXRlcy5wdXNoKC4uLm1hcHBlZFN0b3Jlcyk7XHJcblxyXG4gICAgcmV0dXJuIG1hcHBlZFN0b3JlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHN0c1xyXG4gICAqL1xyXG4gIGFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlQ2xhc3NlczogYW55W10pOiB7IGRlZmF1bHRzOiBhbnk7IHN0YXRlczogTWFwcGVkU3RvcmVbXSB9IHtcclxuICAgIGlmIChzdGF0ZUNsYXNzZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVzID0gdGhpcy5hZGQoc3RhdGVDbGFzc2VzKTtcclxuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdGF0ZXMucmVkdWNlKFxyXG4gICAgICAgIChyZXN1bHQ6IGFueSwgbWV0YTogTWFwcGVkU3RvcmUpID0+IHNldFZhbHVlKHJlc3VsdCwgbWV0YS5kZXB0aCwgbWV0YS5kZWZhdWx0cyksXHJcbiAgICAgICAge31cclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlcyB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcclxuICAgKi9cclxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSByZXR1cm47XHJcbiAgICB0aGlzLl9hY3Rpb25zXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XHJcbiAgICAgICAgICB0aGlzLmludm9rZUFjdGlvbnModGhpcy5fYWN0aW9ucywgYWN0aW9uKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXHJcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcclxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSkpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcclxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgdGhlIGluaXQgZnVuY3Rpb24gb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VJbml0KHN0YXRlTWV0YWRhdGFzOiBNYXBwZWRTdG9yZVtdKSB7XHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHN0YXRlTWV0YWRhdGFzKSB7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBOZ3hzTGlmZUN5Y2xlID0gbWV0YWRhdGEuaW5zdGFuY2U7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2Uubmd4c09uSW5pdCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICBpbnN0YW5jZS5uZ3hzT25Jbml0KHN0YXRlQ29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlQWN0aW9ucyhhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBhY3Rpb24pIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbik7XHJcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uTWV0YS5vcHRpb25zLmNhbmNlbFVuY29tcGxldGVkXHJcbiAgICAgICAgICAgICAgICAgID8gdGFrZVVudGlsKGFjdGlvbnMkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbikpKVxyXG4gICAgICAgICAgICAgICAgICA6IG1hcChyID0+IHIpXHJcbiAgICAgICAgICAgICAgKTsgLy8gbWFwIGFjdHMgbGlrZSBhIG5vb3BcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgc3RhdGUgY29udGV4dFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhOiBNYXBwZWRTdG9yZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICB9XHJcbn1cclxuIl19