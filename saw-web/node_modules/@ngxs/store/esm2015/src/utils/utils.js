/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance.
 * @ignore
 * @param {?} action
 * @return {?}
 */
export function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
export function actionMatcher(action1) {
    /** @type {?} */
    const type1 = getActionTypeFromInstance(action1);
    return function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    };
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
export const setValue = (obj, prop, val) => {
    obj = Object.assign({}, obj);
    /** @type {?} */
    const split = prop.split('.');
    /** @type {?} */
    const lastIndex = split.length - 1;
    split.reduce((acc, part, index) => {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
export const getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBSUEsTUFBTSxVQUFVLHlCQUF5QixDQUFDLE1BQVc7SUFDbkQsSUFBSSxNQUFNLENBQUMsV0FBVyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFO1FBQ2pELE9BQU8sTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7S0FDaEM7SUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDckIsQ0FBQzs7Ozs7OztBQU1ELE1BQU0sVUFBVSxhQUFhLENBQUMsT0FBWTs7VUFDbEMsS0FBSyxHQUFHLHlCQUF5QixDQUFDLE9BQU8sQ0FBQztJQUVoRCxPQUFPLFVBQVMsT0FBWTtRQUMxQixPQUFPLEtBQUssS0FBSyx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN0RCxDQUFDLENBQUM7QUFDSixDQUFDOzs7Ozs7Ozs7Ozs7QUFZRCxNQUFNLE9BQU8sUUFBUSxHQUFHLENBQUMsR0FBUSxFQUFFLElBQVksRUFBRSxHQUFRLEVBQUUsRUFBRTtJQUMzRCxHQUFHLHFCQUFRLEdBQUcsQ0FBRSxDQUFDOztVQUVYLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQzs7VUFDdkIsU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQztJQUVsQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUNoQyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDdkIsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUNqQjthQUFNO1lBQ0wsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBRSxDQUFDO1NBQzFFO1FBRUQsT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUVSLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQzs7Ozs7Ozs7O0FBU0QsTUFBTSxPQUFPLFFBQVEsR0FBRyxDQUFDLEdBQVEsRUFBRSxJQUFZLEVBQUUsRUFBRSxDQUNqRCxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQVEsRUFBRSxJQUFZLEVBQUUsRUFBRSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJldHVybnMgdGhlIHR5cGUgZnJvbSBhbiBhY3Rpb24gaW5zdGFuY2UuXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbjogYW55KTogc3RyaW5nIHtcclxuICBpZiAoYWN0aW9uLmNvbnN0cnVjdG9yICYmIGFjdGlvbi5jb25zdHJ1Y3Rvci50eXBlKSB7XHJcbiAgICByZXR1cm4gYWN0aW9uLmNvbnN0cnVjdG9yLnR5cGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYWN0aW9uLnR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXRjaGVzIGEgYWN0aW9uXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25NYXRjaGVyKGFjdGlvbjE6IGFueSkge1xyXG4gIGNvbnN0IHR5cGUxID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24xKTtcclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGFjdGlvbjI6IGFueSkge1xyXG4gICAgcmV0dXJuIHR5cGUxID09PSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbjIpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgIHNldFZhbHVlKHsgZm9vOiB7IGJhcjogeyBlYXQ6IGZhbHNlIH0gfSB9LFxyXG4gKiAgICAgICdmb28uYmFyLmVhdCcsIHRydWUpIC8vPT4geyBmb286IHsgYmFyOiB7IGVhdDogdHJ1ZSB9IH0gfVxyXG4gKlxyXG4gKiBXaGlsZSBpdCB0cmF2ZXJzZXMgaXQgYWxzbyBjcmVhdGVzIG5ldyBvYmplY3RzIGZyb20gdG9wIGRvd24uXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCBzZXRWYWx1ZSA9IChvYmo6IGFueSwgcHJvcDogc3RyaW5nLCB2YWw6IGFueSkgPT4ge1xyXG4gIG9iaiA9IHsgLi4ub2JqIH07XHJcblxyXG4gIGNvbnN0IHNwbGl0ID0gcHJvcC5zcGxpdCgnLicpO1xyXG4gIGNvbnN0IGxhc3RJbmRleCA9IHNwbGl0Lmxlbmd0aCAtIDE7XHJcblxyXG4gIHNwbGl0LnJlZHVjZSgoYWNjLCBwYXJ0LCBpbmRleCkgPT4ge1xyXG4gICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcclxuICAgICAgYWNjW3BhcnRdID0gdmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWNjW3BhcnRdID0gQXJyYXkuaXNBcnJheShhY2NbcGFydF0pID8gWy4uLmFjY1twYXJ0XV0gOiB7IC4uLmFjY1twYXJ0XSB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhY2MgJiYgYWNjW3BhcnRdO1xyXG4gIH0sIG9iaik7XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRWYWx1ZSA9IChvYmo6IGFueSwgcHJvcDogc3RyaW5nKSA9PlxyXG4gIHByb3Auc3BsaXQoJy4nKS5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbiJdfQ==