/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ensureSelectorMetadata, getSelectorMetadata, getStoreMetadata } from '../internal/internals';
import { memoize } from '../utils/memoize';
/**
 * Function for creating a selector
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
export function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const wrappedFn = function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn(...args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const fn = state => {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            const metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push(...selectors);
        }
        // Determine arguments from the app state using the selectors
        if (selectorsToApply) {
            results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));
        }
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    };
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
export function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy9zZWxlY3Rvci11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFtQixzQkFBc0IsRUFBRSxtQkFBbUIsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7QUFPM0MsTUFBTSxVQUFVLGNBQWMsQ0FDNUIsU0FBZ0IsRUFDaEIsVUFBZSxFQUNmLGdCQUFnRTs7VUFFMUQsU0FBUyxHQUFHLFNBQVMsaUJBQWlCLENBQUMsR0FBRyxJQUFJOztjQUM1QyxXQUFXLEdBQUcsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ3ZDLElBQUksV0FBVyxZQUFZLFFBQVEsRUFBRTs7a0JBQzdCLGVBQWUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzFELE9BQU8sZUFBZSxDQUFDO1NBQ3hCO1FBQ0QsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQzs7VUFDSyxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7VUFDL0IsY0FBYyxHQUFHLGdCQUFnQixJQUFJLGdCQUFnQixDQUFDLGNBQWM7O1VBRXBFLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRTs7Y0FDWCxPQUFPLEdBQUcsRUFBRTs7Y0FFWixnQkFBZ0IsR0FBRyxFQUFFO1FBRTNCLElBQUksY0FBYyxFQUFFOzs7a0JBRVosUUFBUSxHQUFHLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztZQUNqRCxJQUFJLFFBQVEsRUFBRTtnQkFDWixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDdkM7U0FDRjtRQUNELElBQUksU0FBUyxFQUFFO1lBQ2IsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7U0FDckM7UUFDRCw2REFBNkQ7UUFDN0QsSUFBSSxnQkFBZ0IsRUFBRTtZQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyRTtRQUVELG1EQUFtRDtRQUNuRCx1REFBdUQ7UUFDdkQseUVBQXlFO1FBQ3pFLElBQUk7WUFDRixPQUFPLFVBQVUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO1NBQy9CO1FBQUMsT0FBTyxFQUFFLEVBQUU7WUFDWCxJQUFJLEVBQUUsWUFBWSxTQUFTLEVBQUU7Z0JBQzNCLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1lBQ0QsTUFBTSxFQUFFLENBQUM7U0FDVjtJQUNILENBQUM7O1VBRUssZ0JBQWdCLEdBQUcsc0JBQXNCLENBQUMsVUFBVSxDQUFDO0lBQzNELGdCQUFnQixDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7SUFDekMsZ0JBQWdCLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDO0lBQ3pDLElBQUksZ0JBQWdCLEVBQUU7UUFDcEIsZ0JBQWdCLENBQUMsY0FBYyxHQUFHLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztRQUNsRSxnQkFBZ0IsQ0FBQyxZQUFZLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUFDO0tBQy9EO0lBQ0QsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQzs7Ozs7OztBQU1ELE1BQU0sVUFBVSxhQUFhLENBQUMsUUFBYTs7VUFDbkMsUUFBUSxHQUFHLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztJQUM1RSxPQUFPLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUMvRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VsZWN0RnJvbVN0YXRlLCBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhLCBnZXRTZWxlY3Rvck1ldGFkYXRhLCBnZXRTdG9yZU1ldGFkYXRhIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWxzL21lbW9pemUnO1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHNlbGVjdG9yXHJcbiAqIEBwYXJhbSBzZWxlY3RvcnMgVGhlIHNlbGVjdG9ycyB0byB1c2UgdG8gY3JlYXRlIHRoZSBhcmd1bWVudHMgb2YgdGhpcyBmdW5jdGlvblxyXG4gKiBAcGFyYW0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gYmVpbmcgbWFkZSBpbnRvIGEgc2VsZWN0b3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcihcclxuICBzZWxlY3RvcnM6IGFueVtdLFxyXG4gIG9yaWdpbmFsRm46IGFueSxcclxuICBjcmVhdGlvbk1ldGFkYXRhPzogeyBjb250YWluZXJDbGFzczogYW55OyBzZWxlY3Rvck5hbWU6IHN0cmluZyB9XHJcbikge1xyXG4gIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRTZWxlY3RvckZuKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3JpZ2luYWxGbiguLi5hcmdzKTtcclxuICAgIGlmIChyZXR1cm5WYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGlubmVyTWVtb2l6ZWRGbiA9IG1lbW9pemUuYXBwbHkobnVsbCwgW3JldHVyblZhbHVlXSk7XHJcbiAgICAgIHJldHVybiBpbm5lck1lbW9pemVkRm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgfTtcclxuICBjb25zdCBtZW1vaXplZEZuID0gbWVtb2l6ZSh3cmFwcGVkRm4pO1xyXG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xyXG5cclxuICBjb25zdCBmbiA9IHN0YXRlID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBjb25zdCBzZWxlY3RvcnNUb0FwcGx5ID0gW107XHJcblxyXG4gICAgaWYgKGNvbnRhaW5lckNsYXNzKSB7XHJcbiAgICAgIC8vIElmIHdlIGFyZSBvbiBhIHN0YXRlIGNsYXNzLCBhZGQgaXQgYXMgdGhlIGZpcnN0IHNlbGVjdG9yIHBhcmFtZXRlclxyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGdldFN0b3JlTWV0YWRhdGEoY29udGFpbmVyQ2xhc3MpO1xyXG4gICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goY29udGFpbmVyQ2xhc3MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaCguLi5zZWxlY3RvcnMpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZXJtaW5lIGFyZ3VtZW50cyBmcm9tIHRoZSBhcHAgc3RhdGUgdXNpbmcgdGhlIHNlbGVjdG9yc1xyXG4gICAgaWYgKHNlbGVjdG9yc1RvQXBwbHkpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKC4uLnNlbGVjdG9yc1RvQXBwbHkubWFwKGEgPT4gZ2V0U2VsZWN0b3JGbihhKShzdGF0ZSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGUgbGFtYmRhIHRyaWVzIHRvIGFjY2VzcyBhIHNvbWV0aGluZyBvbiB0aGVcclxuICAgIC8vIHN0YXRlIHRoYXQgZG9lc24ndCBleGlzdCwgaXQgd2lsbCB0aHJvdyBhIFR5cGVFcnJvci5cclxuICAgIC8vIHNpbmNlIHRoaXMgaXMgcXVpdGUgdXN1YWwgYmVoYXZpb3VyLCB3ZSBzaW1wbHkgcmV0dXJuIHVuZGVmaW5lZCBpZiBzby5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBtZW1vaXplZEZuKC4uLnJlc3VsdHMpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBleDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBzZWxlY3Rvck1ldGFEYXRhID0gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YShtZW1vaXplZEZuKTtcclxuICBzZWxlY3Rvck1ldGFEYXRhLm9yaWdpbmFsRm4gPSBvcmlnaW5hbEZuO1xyXG4gIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0RnJvbUFwcFN0YXRlID0gZm47XHJcbiAgaWYgKGNyZWF0aW9uTWV0YWRhdGEpIHtcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuY29udGFpbmVyQ2xhc3MgPSBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xyXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5zZWxlY3Rvck5hbWUgPSBjcmVhdGlvbk1ldGFkYXRhLnNlbGVjdG9yTmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIG1lbW9pemVkRm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gZ2V0IHRoZSBzZWxlY3RlZCBzbGljZSBmcm9tIHRoZSBhcHAgc3RhdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yRm4oc2VsZWN0b3I6IGFueSk6IFNlbGVjdEZyb21TdGF0ZSB7XHJcbiAgY29uc3QgbWV0YWRhdGEgPSBnZXRTZWxlY3Rvck1ldGFkYXRhKHNlbGVjdG9yKSB8fCBnZXRTdG9yZU1ldGFkYXRhKHNlbGVjdG9yKTtcclxuICByZXR1cm4gKG1ldGFkYXRhICYmIG1ldGFkYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSkgfHwgc2VsZWN0b3I7XHJcbn1cclxuIl19