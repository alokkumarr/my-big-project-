(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/operators'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('@ngxs/store', ['exports', '@angular/core', 'rxjs/operators', 'rxjs'], factory) :
    (factory((global.ngxs = global.ngxs || {}, global.ngxs.store = {}),global.ng.core,global.rxjs.operators,global.rxjs));
}(this, (function (exports,core,operators,rxjs) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var ROOT_STATE_TOKEN = new core.InjectionToken('ROOT_STATE_TOKEN');
    /** @type {?} */
    var FEATURE_STATE_TOKEN = new core.InjectionToken('FEATURE_STATE_TOKEN');
    /** @type {?} */
    var META_KEY = 'NGXS_META';
    /** @type {?} */
    var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
    /** @type {?} */
    var NGXS_PLUGINS = new core.InjectionToken('NGXS_PLUGINS');
    /**
     * The NGXS config settings.
     */
    var /**
     * The NGXS config settings.
     */ NgxsConfig = /** @class */ (function () {
        function NgxsConfig() {
            this.compatibility = {
                strictContentSecurityPolicy: false
            };
        }
        return NgxsConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Ensures metadata is attached to the class and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureStoreMetadata(target) {
        if (!target.hasOwnProperty(META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                name: null,
                actions: {},
                defaults: {},
                path: null,
                selectFromAppState: null,
                children: [],
                instance: null
            };
            Object.defineProperty(target, META_KEY, { value: defaultMetadata });
        }
        return getStoreMetadata(target);
    }
    /**
     * Get the metadata attached to the class if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getStoreMetadata(target) {
        return target[META_KEY];
    }
    /**
     * Ensures metadata is attached to the selector and returns it.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function ensureSelectorMetadata(target) {
        if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
            /** @type {?} */
            var defaultMetadata = {
                selectFromAppState: null,
                originalFn: null,
                containerClass: null,
                selectorName: null
            };
            Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
        }
        return getSelectorMetadata(target);
    }
    /**
     * Get the metadata attached to the selector if it exists.
     *
     * @ignore
     * @param {?} target
     * @return {?}
     */
    function getSelectorMetadata(target) {
        return target[SELECTOR_META_KEY];
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
     * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function compliantPropGetter(paths) {
        /** @type {?} */
        var copyOfPaths = __spread(paths);
        return function (obj) { return copyOfPaths.reduce(function (acc, part) { return acc && acc[part]; }, obj); };
    }
    /**
     * The generated function is faster than:
     * - pluck (Observable operator)
     * - memoize
     *
     * @ignore
     * @param {?} paths
     * @return {?}
     */
    function fastPropGetter(paths) {
        /** @type {?} */
        var segments = paths;
        /** @type {?} */
        var seg = 'store.' + segments[0];
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var l = segments.length;
        /** @type {?} */
        var expr = seg;
        while (++i < l) {
            expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
        }
        /** @type {?} */
        var fn = new Function('store', 'return ' + expr + ';');
        return ( /** @type {?} */(fn));
    }
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @param {?} paths
     * @param {?} config
     * @return {?}
     */
    function propGetter(paths, config) {
        if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
            return compliantPropGetter(paths);
        }
        else {
            return fastPropGetter(paths);
        }
    }
    /**
     * Given an array of states, it will return a object graph. Example:
     *    const states = [
     *      Cart,
     *      CartSaved,
     *      CartSavedItems
     *    ]
     *
     * would return:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * @ignore
     * @param {?} stateClasses
     * @return {?}
     */
    function buildGraph(stateClasses) {
        /** @type {?} */
        var findName = function (stateClass) {
            /** @type {?} */
            var meta = stateClasses.find(function (g) { return g === stateClass; });
            if (!meta) {
                throw new Error("Child state not found: " + stateClass);
            }
            if (!meta[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            return meta[META_KEY].name;
        };
        return stateClasses.reduce(function (result, stateClass) {
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            var _a = stateClass[META_KEY], name = _a.name, children = _a.children;
            result[name] = (children || []).map(findName);
            return result;
        }, {});
    }
    /**
     * Given a states array, returns object graph
     * returning the name and state metadata. Example:
     *
     *  const graph = {
     *    cart: { metadata }
     *  };
     *
     * @ignore
     * @param {?} states
     * @return {?}
     */
    function nameToState(states) {
        return states.reduce(function (result, stateClass) {
            if (!stateClass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            /** @type {?} */
            var meta = stateClass[META_KEY];
            result[meta.name] = stateClass;
            return result;
        }, {});
    }
    /**
     * Given a object relationship graph will return the full path
     * for the child items. Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const r = {
     *    cart: 'cart',
     *    saved: 'cart.saved',
     *    items: 'cart.saved.items'
     *  };
     *
     * @ignore
     * @param {?} obj
     * @param {?=} newObj
     * @return {?}
     */
    function findFullParentPath(obj, newObj) {
        if (newObj === void 0) {
            newObj = {};
        }
        /** @type {?} */
        var visit = function (child, keyToFind) {
            for (var key in child) {
                if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                    /** @type {?} */
                    var parent_1 = visit(child, key);
                    return parent_1 !== null ? parent_1 + "." + key : key;
                }
            }
            return null;
        };
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                /** @type {?} */
                var parent_2 = visit(obj, key);
                newObj[key] = parent_2 ? parent_2 + "." + key : key;
            }
        }
        return newObj;
    }
    /**
     * Given a object graph, it will return the items topologically sorted Example:
     *
     *  const graph = {
     *    cart: ['saved'],
     *    saved: ['items'],
     *    items: []
     *  };
     *
     * would return:
     *
     *  const results = [
     *    'items',
     *    'saved',
     *    'cart'
     *  ];
     *
     * @ignore
     * @param {?} graph
     * @return {?}
     */
    function topologicalSort(graph) {
        /** @type {?} */
        var sorted = [];
        /** @type {?} */
        var visited = {};
        /** @type {?} */
        var visit = function (name, ancestors) {
            if (ancestors === void 0) {
                ancestors = [];
            }
            if (!Array.isArray(ancestors)) {
                ancestors = [];
            }
            ancestors.push(name);
            visited[name] = true;
            graph[name].forEach(function (dep) {
                if (ancestors.indexOf(dep) >= 0) {
                    throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
                }
                if (visited[dep]) {
                    return;
                }
                visit(dep, ancestors.slice(0));
            });
            if (sorted.indexOf(name) < 0) {
                sorted.push(name);
            }
        };
        Object.keys(graph).forEach(function (k) { return visit(k); });
        return sorted.reverse();
    }
    /**
     * Returns if the parameter is a object or not.
     *
     * @ignore
     * @param {?} obj
     * @return {?}
     */
    function isObject(obj) {
        return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns the type from an action instance.
     * @ignore
     * @param {?} action
     * @return {?}
     */
    function getActionTypeFromInstance(action) {
        if (action.constructor && action.constructor.type) {
            return action.constructor.type;
        }
        return action.type;
    }
    /**
     * Matches a action
     * @ignore
     * @param {?} action1
     * @return {?}
     */
    function actionMatcher(action1) {
        /** @type {?} */
        var type1 = getActionTypeFromInstance(action1);
        return function (action2) {
            return type1 === getActionTypeFromInstance(action2);
        };
    }
    /**
     * Set a deeply nested value. Example:
     *
     *   setValue({ foo: { bar: { eat: false } } },
     *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
     *
     * While it traverses it also creates new objects from top down.
     *
     * @ignore
     * @type {?}
     */
    var setValue = function (obj, prop, val) {
        obj = __assign({}, obj);
        /** @type {?} */
        var split = prop.split('.');
        /** @type {?} */
        var lastIndex = split.length - 1;
        split.reduce(function (acc, part, index) {
            if (index === lastIndex) {
                acc[part] = val;
            }
            else {
                acc[part] = Array.isArray(acc[part]) ? __spread(acc[part]) : __assign({}, acc[part]);
            }
            return acc && acc[part];
        }, obj);
        return obj;
    };
    /**
     * Get a deeply nested value. Example:
     *
     *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
     *
     * @ignore
     * @type {?}
     */
    var getValue = function (obj, prop) {
        return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj);
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will grab actions that have just been dispatched as well as actions that have completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofAction() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been dispatched
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionDispatched() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "DISPATCHED" /* Dispatched */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been successfully completed
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionSuccessful() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "SUCCESSFUL" /* Successful */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just been canceled
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionCanceled() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "CANCELED" /* Canceled */);
    }
    /**
     * RxJS operator for selecting out specific actions.
     *
     * This will ONLY grab actions that have just thrown an error
     * @param {...?} allowedTypes
     * @return {?}
     */
    function ofActionErrored() {
        var allowedTypes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            allowedTypes[_i] = arguments[_i];
        }
        return ofActionOperator(allowedTypes, "ERRORED" /* Errored */);
    }
    /**
     * @param {?} allowedTypes
     * @param {?=} status
     * @return {?}
     */
    function ofActionOperator(allowedTypes, status) {
        /** @type {?} */
        var allowedMap = createAllowedMap(allowedTypes);
        return function (o) {
            return o.pipe(filterStatus(allowedMap, status), mapAction());
        };
    }
    /**
     * @param {?} allowedTypes
     * @param {?=} status
     * @return {?}
     */
    function filterStatus(allowedTypes, status) {
        return operators.filter(function (ctx) {
            /** @type {?} */
            var actionType = getActionTypeFromInstance(ctx.action);
            /** @type {?} */
            var type = allowedTypes[actionType];
            return status ? type && ctx.status === status : type;
        });
    }
    /**
     * @return {?}
     */
    function mapAction() {
        return operators.map(function (ctx) { return ctx.action; });
    }
    /**
     * @param {?} types
     * @return {?}
     */
    function createAllowedMap(types) {
        return types.reduce(function (acc, klass) {
            acc[getActionTypeFromInstance(klass)] = true;
            return acc;
        }, {});
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Operator to run the `subscribe` in a Angular zone.
     * @template T
     * @param {?} zone
     * @return {?}
     */
    function enterZone(zone) {
        return function (source) {
            return new rxjs.Observable(function (sink) {
                return source.subscribe({
                    next: /**
                     * @param {?} x
                     * @return {?}
                     */ function (x) {
                        zone.run(function () { return sink.next(x); });
                    },
                    error: /**
                     * @param {?} e
                     * @return {?}
                     */ function (e) {
                        zone.run(function () { return sink.error(e); });
                    },
                    complete: /**
                     * @return {?}
                     */ function () {
                        zone.run(function () { return sink.complete(); });
                    }
                });
            });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */
    var /**
     * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
     * A standard Subject does not have this guarantee.
     * For example, given the following code:
     * ```typescript
     *   const subject = new Subject<string>();
     * subject.subscribe(value => {
     * if (value === 'start') subject.next('end');
     * });
     * subject.subscribe(value => { });
     * subject.next('start');
     * ```
     * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
     * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
     * @template T
     */ OrderedSubject = /** @class */ (function (_super) {
        __extends(OrderedSubject, _super);
        function OrderedSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._itemQueue = [];
            _this._busyPushingNext = false;
            return _this;
        }
        /**
         * @param {?=} value
         * @return {?}
         */
        OrderedSubject.prototype.next = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (this._busyPushingNext) {
                    this._itemQueue.unshift(value);
                    return;
                }
                this._busyPushingNext = true;
                _super.prototype.next.call(this, value);
                while (this._itemQueue.length > 0) {
                    /** @type {?} */
                    var nextValue = this._itemQueue.pop();
                    _super.prototype.next.call(this, nextValue);
                }
                this._busyPushingNext = false;
            };
        return OrderedSubject;
    }(rxjs.Subject));
    /**
     * Internal Action stream that is emitted anytime an action is dispatched.
     */
    var InternalActions = /** @class */ (function (_super) {
        __extends(InternalActions, _super);
        function InternalActions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalActions.decorators = [
            { type: core.Injectable }
        ];
        return InternalActions;
    }(OrderedSubject));
    /**
     * Action stream that is emitted anytime an action is dispatched.
     *
     * You can listen to this in services to react without stores.
     */
    var Actions = /** @class */ (function (_super) {
        __extends(Actions, _super);
        function Actions(actions$, ngZone) {
            return _super.call(this, function (observer) {
                actions$
                    .pipe(enterZone(ngZone))
                    .subscribe(function (res) { return observer.next(res); }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
            }) || this;
        }
        Actions.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Actions.ctorParameters = function () {
            return [
                { type: InternalActions },
                { type: core.NgZone }
            ];
        };
        return Actions;
    }(rxjs.Observable));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Composes a array of functions from left to right. Example:
     *
     *      compose([fn, final])(state, action);
     *
     * then the funcs have a signature like:
     *
     *      function fn (state, action, next) {
     *          console.log('here', state, action, next);
     *          return next(state, action);
     *      }
     *
     *      function final (state, action) {
     *          console.log('here', state, action);
     *          return state;
     *      }
     *
     * the last function should not call `next`.
     *
     * @ignore
     * @type {?}
     */
    var compose = function (funcs) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var curr = funcs.shift();
            return curr.apply(void 0, __spread(args, [function () {
                    var nextArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        nextArgs[_i] = arguments[_i];
                    }
                    return compose(funcs).apply(void 0, __spread(nextArgs));
                }]));
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * BehaviorSubject of the entire state.
     * @ignore
     */
    var StateStream = /** @class */ (function (_super) {
        __extends(StateStream, _super);
        function StateStream() {
            return _super.call(this, {}) || this;
        }
        StateStream.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateStream.ctorParameters = function () { return []; };
        return StateStream;
    }(rxjs.BehaviorSubject));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Plugin manager class
     * @ignore
     */
    var PluginManager = /** @class */ (function () {
        function PluginManager(_parentManager, _plugins) {
            this._parentManager = _parentManager;
            this._plugins = _plugins;
            this.plugins = [];
            this.register();
        }
        /**
         * @private
         * @return {?}
         */
        PluginManager.prototype.register = /**
         * @private
         * @return {?}
         */
            function () {
                var _a;
                if (!this._plugins) {
                    return;
                }
                this.plugins = this._plugins.map(function (plugin) {
                    if (plugin.handle) {
                        return plugin.handle.bind(plugin);
                    }
                    else {
                        return plugin;
                    }
                });
                if (this._parentManager) {
                    (_a = this._parentManager.plugins).push.apply(_a, __spread(this.plugins));
                }
            };
        PluginManager.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PluginManager.ctorParameters = function () {
            return [
                { type: PluginManager, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: Array, decorators: [{ type: core.Inject, args: [NGXS_PLUGINS,] }, { type: core.Optional }] }
            ];
        };
        return PluginManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Internal Action result stream that is emitted when an action is completed.
     * This is used as a method of returning the action result to the dispatcher
     * for the observable returned by the dispatch(...) call.
     * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
     */
    var InternalDispatchedActionResults = /** @class */ (function (_super) {
        __extends(InternalDispatchedActionResults, _super);
        function InternalDispatchedActionResults() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InternalDispatchedActionResults.decorators = [
            { type: core.Injectable }
        ];
        return InternalDispatchedActionResults;
    }(rxjs.Subject));
    var InternalDispatcher = /** @class */ (function () {
        function InternalDispatcher(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngZone) {
            this._errorHandler = _errorHandler;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._pluginManager = _pluginManager;
            this._stateStream = _stateStream;
            this._ngZone = _ngZone;
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        InternalDispatcher.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                /** @type {?} */
                var result = this._ngZone.runOutsideAngular(function () {
                    if (Array.isArray(event)) {
                        return rxjs.forkJoin(event.map(function (a) { return _this.dispatchSingle(a); }));
                    }
                    else {
                        return _this.dispatchSingle(event);
                    }
                });
                result.subscribe({
                    error: function (error) { return _this._ngZone.run(function () { return _this._errorHandler.handleError(error); }); }
                });
                return result.pipe(enterZone(this._ngZone));
            };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.dispatchSingle = /**
         * @private
         * @param {?} action
         * @return {?}
         */
            function (action) {
                var _this = this;
                /** @type {?} */
                var prevState = this._stateStream.getValue();
                /** @type {?} */
                var plugins = this._pluginManager.plugins;
                return (( /** @type {?} */(compose(__spread(plugins, [
                    function (nextState, nextAction) {
                        if (nextState !== prevState) {
                            _this._stateStream.next(nextState);
                        }
                        /** @type {?} */
                        var actionResult$ = _this.getActionResultStream(nextAction);
                        actionResult$.subscribe(function (ctx) { return _this._actions.next(ctx); });
                        _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                        return _this.createDispatchObservable(actionResult$);
                    }
                ]))(prevState, action)))).pipe(operators.shareReplay());
            };
        /**
         * @private
         * @param {?} action
         * @return {?}
         */
        InternalDispatcher.prototype.getActionResultStream = /**
         * @private
         * @param {?} action
         * @return {?}
         */
            function (action) {
                return this._actionResults.pipe(operators.filter(function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */; }), operators.take(1), operators.shareReplay());
            };
        /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
        InternalDispatcher.prototype.createDispatchObservable = /**
         * @private
         * @param {?} actionResult$
         * @return {?}
         */
            function (actionResult$) {
                var _this = this;
                return actionResult$
                    .pipe(operators.exhaustMap(function (ctx) {
                    switch (ctx.status) {
                        case "SUCCESSFUL" /* Successful */:
                            return rxjs.of(_this._stateStream.getValue());
                        case "ERRORED" /* Errored */:
                            return rxjs.throwError(ctx.error);
                        default:
                            return rxjs.empty();
                    }
                }))
                    .pipe(operators.shareReplay());
            };
        InternalDispatcher.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalDispatcher.ctorParameters = function () {
            return [
                { type: core.ErrorHandler },
                { type: InternalActions },
                { type: InternalDispatchedActionResults },
                { type: PluginManager },
                { type: StateStream },
                { type: core.NgZone }
            ];
        };
        return InternalDispatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Object freeze code
     * https://github.com/jsdf/deep-freeze
     * @type {?}
     */
    var deepFreeze = function (o) {
        Object.freeze(o);
        /** @type {?} */
        var oIsFunction = typeof o === 'function';
        /** @type {?} */
        var hasOwnProp = Object.prototype.hasOwnProperty;
        Object.getOwnPropertyNames(o).forEach(function (prop) {
            if (hasOwnProp.call(o, prop) &&
                (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
                o[prop] !== null &&
                (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
                !Object.isFrozen(o[prop])) {
                deepFreeze(o[prop]);
            }
        });
        return o;
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var InternalStateOperations = /** @class */ (function () {
        function InternalStateOperations(_stateStream, _dispatcher, _config) {
            this._stateStream = _stateStream;
            this._dispatcher = _dispatcher;
            this._config = _config;
            this.verifyDevMode();
        }
        /**
         * Returns the root state operators.
         */
        /**
         * Returns the root state operators.
         * @return {?}
         */
        InternalStateOperations.prototype.getRootStateOperations = /**
         * Returns the root state operators.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var rootStateOperations = {
                    getState: function () { return _this._stateStream.getValue(); },
                    setState: function (newState) { return _this._stateStream.next(newState); },
                    dispatch: function (actions) { return _this._dispatcher.dispatch(actions); }
                };
                if (this._config.developmentMode) {
                    return this.ensureStateAndActionsAreImmutable(rootStateOperations);
                }
                return rootStateOperations;
            };
        /**
         * @private
         * @return {?}
         */
        InternalStateOperations.prototype.verifyDevMode = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var isNgxsDevMode = this._config.developmentMode;
                /** @type {?} */
                var isNgDevMode = core.isDevMode();
                /** @type {?} */
                var incorrectProduction = !isNgDevMode && isNgxsDevMode;
                /** @type {?} */
                var incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
                /** @type {?} */
                var example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
                if (incorrectProduction) {
                    console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
                }
                else if (incorrectDevelopment) {
                    console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
                }
            };
        /**
         * @private
         * @param {?} root
         * @return {?}
         */
        InternalStateOperations.prototype.ensureStateAndActionsAreImmutable = /**
         * @private
         * @param {?} root
         * @return {?}
         */
            function (root) {
                return {
                    getState: function () { return root.getState(); },
                    setState: function (value) {
                        /** @type {?} */
                        var frozenValue = deepFreeze(value);
                        return root.setState(frozenValue);
                    },
                    dispatch: function (actions) {
                        return root.dispatch(actions);
                    }
                };
            };
        InternalStateOperations.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        InternalStateOperations.ctorParameters = function () {
            return [
                { type: StateStream },
                { type: InternalDispatcher },
                { type: NgxsConfig }
            ];
        };
        return InternalStateOperations;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State Context factory class
     * @ignore
     */
    var StateContextFactory = /** @class */ (function () {
        function StateContextFactory(_internalStateOperations) {
            this._internalStateOperations = _internalStateOperations;
        }
        /**
         * Create the state context
         */
        /**
         * Create the state context
         * @param {?} metadata
         * @return {?}
         */
        StateContextFactory.prototype.createStateContext = /**
         * Create the state context
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                /** @type {?} */
                var root = this._internalStateOperations.getRootStateOperations();
                return {
                    getState: /**
                     * @return {?}
                     */ function () {
                        /** @type {?} */
                        var state = root.getState();
                        return getValue(state, metadata.depth);
                    },
                    patchState: /**
                     * @param {?} val
                     * @return {?}
                     */ function (val) {
                        /** @type {?} */
                        var isArray = Array.isArray(val);
                        /** @type {?} */
                        var isPrimitive = typeof val !== 'object';
                        if (isArray) {
                            throw new Error('Patching arrays is not supported.');
                        }
                        else if (isPrimitive) {
                            throw new Error('Patching primitives is not supported.');
                        }
                        /** @type {?} */
                        var state = root.getState();
                        /** @type {?} */
                        var local = getValue(state, metadata.depth);
                        /** @type {?} */
                        var clone = __assign({}, local);
                        for (var k in val) {
                            clone[k] = val[k];
                        }
                        /** @type {?} */
                        var newState = setValue(state, metadata.depth, clone);
                        root.setState(newState);
                        return newState;
                    },
                    setState: /**
                     * @param {?} val
                     * @return {?}
                     */ function (val) {
                        /** @type {?} */
                        var state = root.getState();
                        state = setValue(state, metadata.depth, val);
                        root.setState(state);
                        return state;
                    },
                    dispatch: /**
                     * @param {?} actions
                     * @return {?}
                     */ function (actions) {
                        return root.dispatch(actions);
                    }
                };
            };
        StateContextFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateContextFactory.ctorParameters = function () {
            return [
                { type: InternalStateOperations }
            ];
        };
        return StateContextFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * State factory class
     * @ignore
     */
    var StateFactory = /** @class */ (function () {
        function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory) {
            this._injector = _injector;
            this._config = _config;
            this._parentFactory = _parentFactory;
            this._actions = _actions;
            this._actionResults = _actionResults;
            this._stateContextFactory = _stateContextFactory;
            this._states = [];
            this._connected = false;
        }
        Object.defineProperty(StateFactory.prototype, "states", {
            get: /**
             * @return {?}
             */ function () {
                return this._parentFactory ? this._parentFactory.states : this._states;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a new state to the global defs.
         */
        /**
         * Add a new state to the global defs.
         * @param {?} oneOrManyStateClasses
         * @return {?}
         */
        StateFactory.prototype.add = /**
         * Add a new state to the global defs.
         * @param {?} oneOrManyStateClasses
         * @return {?}
         */
            function (oneOrManyStateClasses) {
                var e_1, _a, _b;
                /** @type {?} */
                var stateClasses;
                if (!Array.isArray(oneOrManyStateClasses)) {
                    stateClasses = [oneOrManyStateClasses];
                }
                else {
                    stateClasses = oneOrManyStateClasses;
                }
                /** @type {?} */
                var stateGraph = buildGraph(stateClasses);
                /** @type {?} */
                var sortedStates = topologicalSort(stateGraph);
                /** @type {?} */
                var depths = findFullParentPath(stateGraph);
                /** @type {?} */
                var nameGraph = nameToState(stateClasses);
                /** @type {?} */
                var mappedStores = [];
                var _loop_1 = function (name_1) {
                    /** @type {?} */
                    var stateClass = nameGraph[name_1];
                    if (!stateClass[META_KEY]) {
                        throw new Error('States must be decorated with @State() decorator');
                    }
                    /** @type {?} */
                    var depth = depths[name_1];
                    var actions = stateClass[META_KEY].actions;
                    var defaults = stateClass[META_KEY].defaults;
                    stateClass[META_KEY].path = depth;
                    stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this_1._config);
                    // ensure our store hasn't already been added
                    // but dont throw since it could be lazy
                    // loaded from different paths
                    /** @type {?} */
                    var has = this_1.states.find(function (s) { return s.name === name_1; });
                    if (!has) {
                        // create new instance of defaults
                        if (Array.isArray(defaults)) {
                            defaults = __spread(defaults);
                        }
                        else if (isObject(defaults)) {
                            defaults = __assign({}, defaults);
                        }
                        else if (defaults === undefined) {
                            defaults = {};
                        }
                        /** @type {?} */
                        var instance = this_1._injector.get(stateClass);
                        mappedStores.push({
                            actions: actions,
                            instance: instance,
                            defaults: defaults,
                            name: name_1,
                            depth: depth
                        });
                    }
                };
                var this_1 = this;
                try {
                    for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                        var name_1 = sortedStates_1_1.value;
                        _loop_1(name_1);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return))
                            _a.call(sortedStates_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                (_b = this.states).push.apply(_b, __spread(mappedStores));
                return mappedStores;
            };
        /**
         * Add a set of states to the store and return the defaulsts
         */
        /**
         * Add a set of states to the store and return the defaulsts
         * @param {?} stateClasses
         * @return {?}
         */
        StateFactory.prototype.addAndReturnDefaults = /**
         * Add a set of states to the store and return the defaulsts
         * @param {?} stateClasses
         * @return {?}
         */
            function (stateClasses) {
                if (stateClasses) {
                    /** @type {?} */
                    var states = this.add(stateClasses);
                    /** @type {?} */
                    var defaults = states.reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
                    return { defaults: defaults, states: states };
                }
            };
        /**
         * Bind the actions to the handlers
         */
        /**
         * Bind the actions to the handlers
         * @return {?}
         */
        StateFactory.prototype.connectActionHandlers = /**
         * Bind the actions to the handlers
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._connected)
                    return;
                this._actions
                    .pipe(operators.filter(function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; }), operators.mergeMap(function (_a) {
                    var action = _a.action;
                    return _this.invokeActions(_this._actions, action).pipe(operators.map(function () { return ( /** @type {?} */({ action: action, status: "SUCCESSFUL" /* Successful */ })); }), operators.defaultIfEmpty(( /** @type {?} */({ action: action, status: "CANCELED" /* Canceled */ }))), operators.catchError(function (error) { return rxjs.of(( /** @type {?} */({ action: action, status: "ERRORED" /* Errored */, error: error }))); }));
                }))
                    .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
                this._connected = true;
            };
        /**
         * Invoke the init function on the states.
         */
        /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
        StateFactory.prototype.invokeInit = /**
         * Invoke the init function on the states.
         * @param {?} stateMetadatas
         * @return {?}
         */
            function (stateMetadatas) {
                var e_2, _a;
                try {
                    for (var stateMetadatas_1 = __values(stateMetadatas), stateMetadatas_1_1 = stateMetadatas_1.next(); !stateMetadatas_1_1.done; stateMetadatas_1_1 = stateMetadatas_1.next()) {
                        var metadata = stateMetadatas_1_1.value;
                        /** @type {?} */
                        var instance = metadata.instance;
                        if (instance.ngxsOnInit) {
                            /** @type {?} */
                            var stateContext = this.createStateContext(metadata);
                            instance.ngxsOnInit(stateContext);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (stateMetadatas_1_1 && !stateMetadatas_1_1.done && (_a = stateMetadatas_1.return))
                            _a.call(stateMetadatas_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
            };
        /**
         * Invoke actions on the states.
         */
        /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
        StateFactory.prototype.invokeActions = /**
         * Invoke actions on the states.
         * @param {?} actions$
         * @param {?} action
         * @return {?}
         */
            function (actions$, action) {
                var e_3, _a, e_4, _b;
                /** @type {?} */
                var results = [];
                try {
                    for (var _c = __values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var metadata = _d.value;
                        /** @type {?} */
                        var type = getActionTypeFromInstance(action);
                        /** @type {?} */
                        var actionMetas = metadata.actions[type];
                        if (actionMetas) {
                            try {
                                for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                                    var actionMeta = actionMetas_1_1.value;
                                    /** @type {?} */
                                    var stateContext = this.createStateContext(metadata);
                                    try {
                                        /** @type {?} */
                                        var result = metadata.instance[actionMeta.fn](stateContext, action);
                                        if (result instanceof Promise) {
                                            result = rxjs.from(result);
                                        }
                                        if (result instanceof rxjs.Observable) {
                                            result = result.pipe(actionMeta.options.cancelUncompleted
                                                ? operators.takeUntil(actions$.pipe(ofActionDispatched(action)))
                                                : operators.map(function (r) { return r; })); // map acts like a noop
                                        }
                                        else {
                                            result = rxjs.of({}).pipe(operators.shareReplay());
                                        }
                                        results.push(result);
                                    }
                                    catch (e) {
                                        results.push(rxjs.throwError(e));
                                    }
                                }
                            }
                            catch (e_4_1) {
                                e_4 = { error: e_4_1 };
                            }
                            finally {
                                try {
                                    if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return))
                                        _b.call(actionMetas_1);
                                }
                                finally {
                                    if (e_4)
                                        throw e_4.error;
                                }
                            }
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                if (!results.length) {
                    results.push(rxjs.of({}));
                }
                return rxjs.forkJoin(results);
            };
        /**
         * Create the state context
         */
        /**
         * Create the state context
         * @private
         * @param {?} metadata
         * @return {?}
         */
        StateFactory.prototype.createStateContext = /**
         * Create the state context
         * @private
         * @param {?} metadata
         * @return {?}
         */
            function (metadata) {
                return this._stateContextFactory.createStateContext(metadata);
            };
        StateFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        StateFactory.ctorParameters = function () {
            return [
                { type: core.Injector },
                { type: NgxsConfig },
                { type: StateFactory, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: InternalActions },
                { type: InternalDispatchedActionResults },
                { type: StateContextFactory }
            ];
        };
        return StateFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function defaultEqualityCheck(a, b) {
        return a === b;
    }
    /**
     * @param {?} equalityCheck
     * @param {?} prev
     * @param {?} next
     * @return {?}
     */
    function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
            return false;
        }
        // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
        /** @type {?} */
        var length = prev.length;
        for (var i = 0; i < length; i++) {
            if (!equalityCheck(prev[i], next[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Memoize a function on its last inputs only.
     * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
     *
     * @ignore
     * @param {?} func
     * @param {?=} equalityCheck
     * @return {?}
     */
    function memoize(func, equalityCheck) {
        if (equalityCheck === void 0) {
            equalityCheck = defaultEqualityCheck;
        }
        /** @type {?} */
        var lastArgs = null;
        /** @type {?} */
        var lastResult = null;
        // we reference arguments instead of spreading them for performance reasons
        return ( /** @type {?} */(function memoized() {
            if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
                // apply arguments instead of spreading for performance.
                lastResult = func.apply(null, arguments);
            }
            lastArgs = arguments;
            return lastResult;
        }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Function for creating a selector
     * @param {?} selectors The selectors to use to create the arguments of this function
     * @param {?} originalFn The original function being made into a selector
     * @param {?=} creationMetadata
     * @return {?}
     */
    function createSelector(selectors, originalFn, creationMetadata) {
        /** @type {?} */
        var wrappedFn = function wrappedSelectorFn() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var returnValue = originalFn.apply(void 0, __spread(args));
            if (returnValue instanceof Function) {
                /** @type {?} */
                var innerMemoizedFn = memoize.apply(null, [returnValue]);
                return innerMemoizedFn;
            }
            return returnValue;
        };
        /** @type {?} */
        var memoizedFn = memoize(wrappedFn);
        /** @type {?} */
        var containerClass = creationMetadata && creationMetadata.containerClass;
        /** @type {?} */
        var fn = function (state) {
            /** @type {?} */
            var results = [];
            /** @type {?} */
            var selectorsToApply = [];
            if (containerClass) {
                // If we are on a state class, add it as the first selector parameter
                /** @type {?} */
                var metadata = getStoreMetadata(containerClass);
                if (metadata) {
                    selectorsToApply.push(containerClass);
                }
            }
            if (selectors) {
                selectorsToApply.push.apply(selectorsToApply, __spread(selectors));
            }
            // Determine arguments from the app state using the selectors
            if (selectorsToApply) {
                results.push.apply(results, __spread(selectorsToApply.map(function (a) { return getSelectorFn(a)(state); })));
            }
            // if the lambda tries to access a something on the
            // state that doesn't exist, it will throw a TypeError.
            // since this is quite usual behaviour, we simply return undefined if so.
            try {
                return memoizedFn.apply(void 0, __spread(results));
            }
            catch (ex) {
                if (ex instanceof TypeError) {
                    return undefined;
                }
                throw ex;
            }
        };
        /** @type {?} */
        var selectorMetaData = ensureSelectorMetadata(memoizedFn);
        selectorMetaData.originalFn = originalFn;
        selectorMetaData.selectFromAppState = fn;
        if (creationMetadata) {
            selectorMetaData.containerClass = creationMetadata.containerClass;
            selectorMetaData.selectorName = creationMetadata.selectorName;
        }
        return memoizedFn;
    }
    /**
     * This function gets the selector function to be used to get the selected slice from the app state
     * @ignore
     * @param {?} selector
     * @return {?}
     */
    function getSelectorFn(selector) {
        /** @type {?} */
        var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
        return (metadata && metadata.selectFromAppState) || selector;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Store = /** @class */ (function () {
        function Store(_ngZone, _stateStream, _internalStateOperations) {
            this._ngZone = _ngZone;
            this._stateStream = _stateStream;
            this._internalStateOperations = _internalStateOperations;
        }
        /**
         * Dispatches event(s).
         */
        /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
        Store.prototype.dispatch = /**
         * Dispatches event(s).
         * @param {?} event
         * @return {?}
         */
            function (event) {
                return this._internalStateOperations.getRootStateOperations().dispatch(event);
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.select = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                /** @type {?} */
                var selectorFn = getSelectorFn(selector);
                return this._stateStream.pipe(operators.map(selectorFn), operators.catchError(function (err) {
                    // if error is TypeError we swallow it to prevent usual errors with property access
                    if (err instanceof TypeError) {
                        return rxjs.of(undefined);
                    }
                    // rethrow other errors
                    throw err;
                }), operators.distinctUntilChanged(), enterZone(this._ngZone));
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectOnce = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                return this.select(selector).pipe(operators.take(1));
            };
        /**
         * @param {?} selector
         * @return {?}
         */
        Store.prototype.selectSnapshot = /**
         * @param {?} selector
         * @return {?}
         */
            function (selector) {
                /** @type {?} */
                var selectorFn = getSelectorFn(selector);
                return selectorFn(this._stateStream.getValue());
            };
        /**
         * Allow the user to subscribe to the root of the state
         */
        /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
        Store.prototype.subscribe = /**
         * Allow the user to subscribe to the root of the state
         * @param {?=} fn
         * @return {?}
         */
            function (fn) {
                return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);
            };
        /**
         * Return the raw value of the state.
         */
        /**
         * Return the raw value of the state.
         * @return {?}
         */
        Store.prototype.snapshot = /**
         * Return the raw value of the state.
         * @return {?}
         */
            function () {
                return this._internalStateOperations.getRootStateOperations().getState();
            };
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         */
        /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
        Store.prototype.reset = /**
         * Reset the state to a specific point in time. This method is useful
         * for plugin's who need to modify the state directly or unit testing.
         * @param {?} state
         * @return {?}
         */
            function (state) {
                return this._internalStateOperations.getRootStateOperations().setState(state);
            };
        Store.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        Store.ctorParameters = function () {
            return [
                { type: core.NgZone },
                { type: StateStream },
                { type: InternalStateOperations }
            ];
        };
        return Store;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Allows the select decorator to get access to the DI store.
     * @ignore
     */
    var SelectFactory = /** @class */ (function () {
        function SelectFactory(store, config) {
            SelectFactory.store = store;
            SelectFactory.config = config;
        }
        SelectFactory.store = undefined;
        SelectFactory.config = undefined;
        SelectFactory.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SelectFactory.ctorParameters = function () {
            return [
                { type: Store },
                { type: NgxsConfig }
            ];
        };
        return SelectFactory;
    }());
    /**
     * Decorator for selecting a slice of state from the store.
     * @param {?=} selectorOrFeature
     * @param {...?} paths
     * @return {?}
     */
    function Select(selectorOrFeature) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return function (target, name) {
            /** @type {?} */
            var selectorFnName = '__' + name + '__selector';
            if (!selectorOrFeature) {
                // if foo$ => make it just foo
                selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
            }
            /** @type {?} */
            var createSelect = function (fn) {
                /** @type {?} */
                var store = SelectFactory.store;
                if (!store) {
                    throw new Error('SelectFactory not connected to store!');
                }
                return store.select(fn);
            };
            /** @type {?} */
            var createSelector = function () {
                /** @type {?} */
                var config = SelectFactory.config;
                if (typeof selectorOrFeature === 'string') {
                    /** @type {?} */
                    var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
                    return propGetter(propsArray, config);
                }
                else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                    return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);
                }
                else {
                    return selectorOrFeature;
                }
            };
            if (target[selectorFnName]) {
                throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
            }
            if (delete target[name]) {
                Object.defineProperty(target, selectorFnName, {
                    writable: true,
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(target, name, {
                    get: function () {
                        return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Init action
     */
    var /**
     * Init action
     */ InitState = /** @class */ (function () {
        function InitState() {
        }
        Object.defineProperty(InitState, "type", {
            get: /**
             * @return {?}
             */ function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@INIT';
            },
            enumerable: true,
            configurable: true
        });
        return InitState;
    }());
    /**
     * Update action
     */
    var /**
     * Update action
     */ UpdateState = /** @class */ (function () {
        function UpdateState() {
        }
        Object.defineProperty(UpdateState, "type", {
            get: /**
             * @return {?}
             */ function () {
                // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
                return '@@UPDATE_STATE';
            },
            enumerable: true,
            configurable: true
        });
        return UpdateState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Root module
     * @ignore
     */
    var NgxsRootModule = /** @class */ (function () {
        function NgxsRootModule(factory, internalStateOperations, store, select, states) {
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(states);
            /** @type {?} */
            var stateOperations = internalStateOperations.getRootStateOperations();
            if (results) {
                // get our current stream
                /** @type {?} */
                var cur = stateOperations.getState();
                // set the state to the current + new
                stateOperations.setState(__assign({}, cur, results.defaults));
            }
            // connect our actions stream
            factory.connectActionHandlers();
            // dispatch the init action and invoke init function after
            stateOperations.dispatch(new InitState()).subscribe(function () {
                if (results) {
                    factory.invokeInit(results.states);
                }
            });
        }
        NgxsRootModule.decorators = [
            { type: core.NgModule }
        ];
        /** @nocollapse */
        NgxsRootModule.ctorParameters = function () {
            return [
                { type: StateFactory },
                { type: InternalStateOperations },
                { type: Store },
                { type: SelectFactory },
                { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ROOT_STATE_TOKEN,] }] }
            ];
        };
        return NgxsRootModule;
    }());
    /**
     * Feature module
     * @ignore
     */
    var NgxsFeatureModule = /** @class */ (function () {
        function NgxsFeatureModule(store, internalStateOperations, factory, states) {
            // Since FEATURE_STATE_TOKEN is a multi token, we need to
            // flatten it [[Feature1State, Feature2State], [Feature3State]]
            /** @type {?} */
            var flattenedStates = (( /** @type {?} */([]))).concat.apply((( /** @type {?} */([]))), __spread(states));
            // add stores to the state graph and return their defaults
            /** @type {?} */
            var results = factory.addAndReturnDefaults(flattenedStates);
            /** @type {?} */
            var stateOperations = internalStateOperations.getRootStateOperations();
            if (results) {
                // get our current stream
                /** @type {?} */
                var cur = stateOperations.getState();
                // set the state to the current + new
                stateOperations.setState(__assign({}, cur, results.defaults));
            }
            stateOperations.dispatch(new UpdateState()).subscribe(function () {
                if (results) {
                    factory.invokeInit(results.states);
                }
            });
        }
        NgxsFeatureModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        /** @nocollapse */
        NgxsFeatureModule.ctorParameters = function () {
            return [
                { type: Store },
                { type: InternalStateOperations },
                { type: StateFactory },
                { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [FEATURE_STATE_TOKEN,] }] }
            ];
        };
        return NgxsFeatureModule;
    }());
    /**
     * @param {?} options
     * @return {?}
     */
    function ngxsConfigFactory(options) {
        /** @type {?} */
        var config = Object.assign(new NgxsConfig(), options);
        return config;
    }
    /** @type {?} */
    var ROOT_OPTIONS = new core.InjectionToken('ROOT_OPTIONS');
    /**
     * Ngxs Module
     */
    var NgxsModule = /** @class */ (function () {
        function NgxsModule() {
        }
        /**
         * Root module factory
         */
        /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
        NgxsModule.forRoot = /**
         * Root module factory
         * @param {?=} states
         * @param {?=} options
         * @return {?}
         */
            function (states, options) {
                if (states === void 0) {
                    states = [];
                }
                if (options === void 0) {
                    options = {};
                }
                return {
                    ngModule: NgxsRootModule,
                    providers: __spread([
                        StateFactory,
                        StateContextFactory,
                        Actions,
                        InternalActions,
                        InternalDispatcher,
                        InternalDispatchedActionResults,
                        InternalStateOperations,
                        Store,
                        StateStream,
                        SelectFactory,
                        PluginManager
                    ], states, [
                        {
                            provide: ROOT_STATE_TOKEN,
                            useValue: states
                        },
                        {
                            provide: ROOT_OPTIONS,
                            useValue: options
                        },
                        {
                            provide: NgxsConfig,
                            useFactory: ngxsConfigFactory,
                            deps: [ROOT_OPTIONS]
                        }
                    ])
                };
            };
        /**
         * Feature module factory
         */
        /**
         * Feature module factory
         * @param {?} states
         * @return {?}
         */
        NgxsModule.forFeature = /**
         * Feature module factory
         * @param {?} states
         * @return {?}
         */
            function (states) {
                return {
                    ngModule: NgxsFeatureModule,
                    providers: __spread([
                        StateFactory,
                        PluginManager
                    ], states, [
                        {
                            provide: FEATURE_STATE_TOKEN,
                            multi: true,
                            useValue: states
                        }
                    ])
                };
            };
        NgxsModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        return NgxsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorates a method with a action information.
     * @param {?} actions
     * @param {?=} options
     * @return {?}
     */
    function Action(actions, options) {
        return function (target, name, descriptor) {
            var e_1, _a;
            /** @type {?} */
            var meta = ensureStoreMetadata(target.constructor);
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            try {
                for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                    var action = actions_1_1.value;
                    /** @type {?} */
                    var type = action.type;
                    if (!action.type) {
                        throw new Error("Action " + action.name + " is missing a static \"type\" property");
                    }
                    if (!meta.actions[type]) {
                        meta.actions[type] = [];
                    }
                    meta.actions[type].push({
                        fn: name,
                        options: options || {},
                        type: type
                    });
                }
            }
            catch (e_1_1) {
                e_1 = { error: e_1_1 };
            }
            finally {
                try {
                    if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return))
                        _a.call(actions_1);
                }
                finally {
                    if (e_1)
                        throw e_1.error;
                }
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
    /**
     * Error message
     * @ignore
     * @type {?}
     */
    var stateNameErrorMessage = function (name) {
        return name + " is not a valid state name. It needs to be a valid object property name.";
    };
    /**
     * Decorates a class with ngxs state information.
     * @template T
     * @param {?} options
     * @return {?}
     */
    function State(options) {
        return function (target) {
            /** @type {?} */
            var meta = ensureStoreMetadata(target);
            // Handle inheritance
            if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {
                /** @type {?} */
                var parentMeta = Object.getPrototypeOf(target)[META_KEY];
                meta.actions = __assign({}, meta.actions, parentMeta.actions);
            }
            meta.children = options.children;
            meta.defaults = options.defaults;
            meta.name = options.name;
            if (!options.name) {
                throw new Error("States must register a 'name' property");
            }
            if (!stateNameRegex.test(options.name)) {
                throw new Error(stateNameErrorMessage(options.name));
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Decorator for memoizing a state selector.
     * @param {?=} selectors
     * @return {?}
     */
    function Selector(selectors) {
        return function (target, key, descriptor) {
            if (descriptor.value !== null) {
                /** @type {?} */
                var originalFn = descriptor.value;
                /** @type {?} */
                var memoizedFn_1 = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });
                return {
                    configurable: true,
                    get: /**
                     * @return {?}
                     */ function () {
                        return memoizedFn_1;
                    }
                };
            }
            else {
                throw new Error('Selectors only work on methods');
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NgxsModule = NgxsModule;
    exports.Action = Action;
    exports.Store = Store;
    exports.State = State;
    exports.Select = Select;
    exports.Actions = Actions;
    exports.getSelectorMetadata = getSelectorMetadata;
    exports.getStoreMetadata = getStoreMetadata;
    exports.ensureStoreMetadata = ensureStoreMetadata;
    exports.ensureSelectorMetadata = ensureSelectorMetadata;
    exports.ofAction = ofAction;
    exports.ofActionDispatched = ofActionDispatched;
    exports.ofActionSuccessful = ofActionSuccessful;
    exports.ofActionCanceled = ofActionCanceled;
    exports.ofActionErrored = ofActionErrored;
    exports.Selector = Selector;
    exports.getActionTypeFromInstance = getActionTypeFromInstance;
    exports.actionMatcher = actionMatcher;
    exports.createSelector = createSelector;
    exports.NGXS_PLUGINS = NGXS_PLUGINS;
    exports.StateStream = StateStream;
    exports.setValue = setValue;
    exports.getValue = getValue;
    exports.InitState = InitState;
    exports.UpdateState = UpdateState;
    exports.ɵg = InternalActions;
    exports.ɵf = OrderedSubject;
    exports.ɵe = SelectFactory;
    exports.ɵn = InternalDispatchedActionResults;
    exports.ɵo = InternalDispatcher;
    exports.ɵp = StateContextFactory;
    exports.ɵm = StateFactory;
    exports.ɵq = InternalStateOperations;
    exports.ɵb = NgxsFeatureModule;
    exports.ɵa = NgxsRootModule;
    exports.ɵd = ROOT_OPTIONS;
    exports.ɵc = ngxsConfigFactory;
    exports.ɵr = PluginManager;
    exports.ɵi = FEATURE_STATE_TOKEN;
    exports.ɵj = META_KEY;
    exports.ɵl = NgxsConfig;
    exports.ɵh = ROOT_STATE_TOKEN;
    exports.ɵk = SELECTOR_META_KEY;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4cy1zdG9yZS51bWQuanMubWFwIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvc3ltYm9scy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL2ludGVybmFscy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL3V0aWxzL3V0aWxzLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvb3BlcmF0b3JzL29mLWFjdGlvbi50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL29wZXJhdG9ycy96b25lLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvYWN0aW9ucy1zdHJlYW0udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy9jb21wb3NlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvc3RhdGUtc3RyZWFtLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvcGx1Z2luLW1hbmFnZXIudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9pbnRlcm5hbC9kaXNwYXRjaGVyLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvZnJlZXplLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucy50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy91dGlscy9tZW1vaXplLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvdXRpbHMvc2VsZWN0b3ItdXRpbHMudHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9zdG9yZS50cyIsIm5nOi8vQG5neHMvc3RvcmUvc3JjL2RlY29yYXRvcnMvc2VsZWN0LnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvYWN0aW9ucy9hY3Rpb25zLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvbW9kdWxlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9hY3Rpb24udHMiLCJuZzovL0BuZ3hzL3N0b3JlL3NyYy9kZWNvcmF0b3JzL3N0YXRlLnRzIiwibmc6Ly9Abmd4cy9zdG9yZS9zcmMvZGVjb3JhdG9ycy9zZWxlY3Rvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBST09UX1NUQVRFX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuPGFueT4oJ1JPT1RfU1RBVEVfVE9LRU4nKTtcclxuZXhwb3J0IGNvbnN0IEZFQVRVUkVfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignRkVBVFVSRV9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgTUVUQV9LRVkgPSAnTkdYU19NRVRBJztcclxuZXhwb3J0IGNvbnN0IFNFTEVDVE9SX01FVEFfS0VZID0gJ05HWFNfU0VMRUNUT1JfTUVUQSc7XHJcblxyXG5leHBvcnQgY29uc3QgTkdYU19QTFVHSU5TID0gbmV3IEluamVjdGlvblRva2VuKCdOR1hTX1BMVUdJTlMnKTtcclxuZXhwb3J0IHR5cGUgTmd4c1BsdWdpbkNvbnN0cnVjdG9yID0gbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gTmd4c1BsdWdpbjtcclxuZXhwb3J0IHR5cGUgTmd4c1BsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pID0+IGFueTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgTkdYUyBjb25maWcgc2V0dGluZ3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTmd4c0NvbmZpZyB7XHJcbiAgLyoqXHJcbiAgICogUnVuIGluIGRldmVsb3BtZW50IG1vZGUuIFRoaXMgd2lsbCBhZGQgYWRkaXRpb25hbCBkZWJ1Z2dpbmcgZmVhdHVyZXM6XHJcbiAgICogLSBPYmplY3QuZnJlZXplIG9uIHRoZSBzdGF0ZSBhbmQgYWN0aW9ucyB0byBndWFyYW50ZWUgaW1tdXRhYmlsaXR5XHJcbiAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAqL1xyXG4gIGRldmVsb3BtZW50TW9kZTogYm9vbGVhbjtcclxuICBjb21wYXRpYmlsaXR5OiB7XHJcbiAgICAvKipcclxuICAgICAqIFN1cHBvcnQgYSBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXHJcbiAgICAgKiBUaGlzIHdpbGwgY2lydW12ZW50IHNvbWUgb3B0aW1pc2F0aW9ucyB0aGF0IHZpb2xhdGUgYSBzdHJpY3QgQ1NQIHRocm91Z2ggdGhlIHVzZSBvZiBgbmV3IEZ1bmN0aW9uKC4uLilgLlxyXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICovXHJcbiAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGJvb2xlYW47XHJcbiAgfTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNvbXBhdGliaWxpdHkgPSB7XHJcbiAgICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogZmFsc2VcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RhdGUgY29udGV4dCBwcm92aWRlZCB0byB0aGUgYWN0aW9ucyBpbiB0aGUgc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ29udGV4dDxUPiB7XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqL1xyXG4gIGdldFN0YXRlKCk6IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIG5ldyB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRTdGF0ZSh2YWw6IFQpO1xyXG5cclxuICAvKipcclxuICAgKiBQYXRjaCB0aGUgZXhpc3Rpbmcgc3RhdGUgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgcGF0Y2hTdGF0ZSh2YWw6IFBhcnRpYWw8VD4pO1xyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaCBhIG5ldyBhY3Rpb24gYW5kIHJldHVybiB0aGUgZGlzcGF0Y2hlZCBvYnNlcnZhYmxlLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c05leHRQbHVnaW5GbiA9IChzdGF0ZTogYW55LCBtdXRhdGlvbjogYW55KSA9PiBhbnk7XHJcblxyXG4vKipcclxuICogUGx1Z2luIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzUGx1Z2luIHtcclxuICAvKipcclxuICAgKiBIYW5kbGUgdGhlIHN0YXRlL2FjdGlvbiBiZWZvcmUgaXRzIHN1Ym1pdHRlZCB0byB0aGUgc3RhdGUgaGFuZGxlcnMuXHJcbiAgICovXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGFjdGlvbjogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCB0byB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlT3B0aW9uczxUPiB7XHJcbiAgLyoqXHJcbiAgICogTmFtZSBvZiB0aGUgc3RhdGUuIFJlcXVpcmVkLlxyXG4gICAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBkZWZhdWx0cz86IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YiBzdGF0ZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZS5cclxuICAgKi9cclxuICBjaGlsZHJlbj86IGFueVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQWN0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCBpbiBhIGFjdGlvbiBkZWNvcmF0b3IuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbk9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIENhbmNlbCB0aGUgcHJldmlvdXMgdW5jb21wbGV0ZWQgb2JzZXJ2YWJsZShzKS5cclxuICAgKi9cclxuICBjYW5jZWxVbmNvbXBsZXRlZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPbiBpbml0IGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25Jbml0IHtcclxuICBuZ3hzT25Jbml0KGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZCB8IGFueTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c0xpZmVDeWNsZSA9IFBhcnRpYWw8Tmd4c09uSW5pdD47XHJcbiIsImltcG9ydCB7IE1FVEFfS0VZLCBBY3Rpb25PcHRpb25zLCBTRUxFQ1RPUl9NRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9iamVjdEtleU1hcDxUPiB7XHJcbiAgW2tleTogc3RyaW5nXTogVDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUNsYXNzIHtcclxuICBbTUVUQV9LRVldPzogTWV0YURhdGFNb2RlbDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVLZXlHcmFwaCA9IE9iamVjdEtleU1hcDxzdHJpbmdbXT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkhhbmRsZXJNZXRhRGF0YSB7XHJcbiAgZm46IHN0cmluZztcclxuICBvcHRpb25zOiBBY3Rpb25PcHRpb25zO1xyXG4gIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZU9wZXJhdGlvbnM8VD4ge1xyXG4gIGdldFN0YXRlKCk6IFQ7XHJcbiAgc2V0U3RhdGUodmFsOiBUKTtcclxuICBkaXNwYXRjaChhY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0YURhdGFNb2RlbCB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBwYXRoOiBzdHJpbmc7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGU7XHJcbiAgY2hpbGRyZW46IFN0YXRlQ2xhc3NbXTtcclxuICBpbnN0YW5jZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTZWxlY3RGcm9tU3RhdGUgPSAoc3RhdGU6IGFueSkgPT4gYW55O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHNlbGVjdEZyb21BcHBTdGF0ZTogU2VsZWN0RnJvbVN0YXRlO1xyXG4gIG9yaWdpbmFsRm46IEZ1bmN0aW9uO1xyXG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XHJcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwcGVkU3RvcmUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBhY3Rpb25zOiBPYmplY3RLZXlNYXA8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgaW5zdGFuY2U6IGFueTtcclxuICBkZXB0aDogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgY2xhc3MgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldCk6IE1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBhY3Rpb25zOiB7fSxcclxuICAgICAgZGVmYXVsdHM6IHt9LFxyXG4gICAgICBwYXRoOiBudWxsLFxyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgaW5zdGFuY2U6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIGNsYXNzIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTogTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtNRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBhbmQgcmV0dXJucyBpdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShTRUxFQ1RPUl9NRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIG9yaWdpbmFsRm46IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxyXG4gICAgICBzZWxlY3Rvck5hbWU6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgU0VMRUNUT1JfTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogTm90ZTogVGhpcyBpcyBub3QgYXMgZmFzdCBhcyB0aGUgYGZhc3RQcm9wR2V0dGVyYCBidXQgaXMgc3RyaWN0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGNvbXBsaWFudC5cclxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBjb3B5T2ZQYXRocyA9IFsuLi5wYXRoc107XHJcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuOlxyXG4gKiAtIHBsdWNrIChPYnNlcnZhYmxlIG9wZXJhdG9yKVxyXG4gKiAtIG1lbW9pemVcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZmFzdFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGhzO1xyXG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xyXG4gIGxldCBpID0gMDtcclxuICBjb25zdCBsID0gc2VnbWVudHMubGVuZ3RoO1xyXG5cclxuICBsZXQgZXhwciA9IHNlZztcclxuICB3aGlsZSAoKytpIDwgbCkge1xyXG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XHJcblxyXG4gIHJldHVybiA8KHg6IGFueSkgPT4gYW55PmZuO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29tcGF0aWJpbGl0eSAmJiBjb25maWcuY29tcGF0aWJpbGl0eS5zdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3kpIHtcclxuICAgIHJldHVybiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhc3RQcm9wR2V0dGVyKHBhdGhzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxyXG4gKiAgICBjb25zdCBzdGF0ZXMgPSBbXHJcbiAqICAgICAgQ2FydCxcclxuICogICAgICBDYXJ0U2F2ZWQsXHJcbiAqICAgICAgQ2FydFNhdmVkSXRlbXNcclxuICogICAgXVxyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdyYXBoKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdKTogU3RhdGVLZXlHcmFwaCB7XHJcbiAgY29uc3QgZmluZE5hbWUgPSAoc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3Nlcy5maW5kKGcgPT4gZyA9PT0gc3RhdGVDbGFzcyk7XHJcbiAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBzdGF0ZSBub3QgZm91bmQ6ICR7c3RhdGVDbGFzc31gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1ldGFbTUVUQV9LRVldKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGVzIG11c3QgYmUgZGVjb3JhdGVkIHdpdGggQFN0YXRlKCkgZGVjb3JhdG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1ldGFbTUVUQV9LRVldLm5hbWU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgaWYgKCFzdGF0ZUNsYXNzW01FVEFfS0VZXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlcyBtdXN0IGJlIGRlY29yYXRlZCB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldO1xyXG4gICAgcmVzdWx0W25hbWVdID0gKGNoaWxkcmVuIHx8IFtdKS5tYXAoZmluZE5hbWUpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LCB7fSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcclxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NbXSk6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiB7XHJcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2U8T2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+PigocmVzdWx0OiBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4sIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgIGlmICghc3RhdGVDbGFzc1tNRVRBX0tFWV0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICByZXN1bHRbbWV0YS5uYW1lXSA9IHN0YXRlQ2xhc3M7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHIgPSB7XHJcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcclxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcclxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChvYmo6IFN0YXRlS2V5R3JhcGgsIG5ld09iajogT2JqZWN0S2V5TWFwPHN0cmluZz4gPSB7fSk6IE9iamVjdEtleU1hcDxzdHJpbmc+IHtcclxuICBjb25zdCB2aXNpdCA9IChjaGlsZDogU3RhdGVLZXlHcmFwaCwga2V5VG9GaW5kOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGQpIHtcclxuICAgICAgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KGtleSkgJiYgY2hpbGRba2V5XS5pbmRleE9mKGtleVRvRmluZCkgPj0gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcclxuICAgICAgbmV3T2JqW2tleV0gPSBwYXJlbnQgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByZXN1bHRzID0gW1xyXG4gKiAgICAnaXRlbXMnLFxyXG4gKiAgICAnc2F2ZWQnLFxyXG4gKiAgICAnY2FydCdcclxuICogIF07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XHJcbiAgY29uc3Qgc29ydGVkOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGNvbnN0IHZpc2l0ZWQ6IE9iamVjdEtleU1hcDxib29sZWFuPiA9IHt9O1xyXG5cclxuICBjb25zdCB2aXNpdCA9IChuYW1lOiBzdHJpbmcsIGFuY2VzdG9yczogc3RyaW5nW10gPSBbXSkgPT4ge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFuY2VzdG9ycykpIHtcclxuICAgICAgYW5jZXN0b3JzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYW5jZXN0b3JzLnB1c2gobmFtZSk7XHJcbiAgICB2aXNpdGVkW25hbWVdID0gdHJ1ZTtcclxuXHJcbiAgICBncmFwaFtuYW1lXS5mb3JFYWNoKChkZXA6IHN0cmluZykgPT4ge1xyXG4gICAgICBpZiAoYW5jZXN0b3JzLmluZGV4T2YoZGVwKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XHJcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xyXG5cclxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4iLCIvKipcclxuICogUmV0dXJucyB0aGUgdHlwZSBmcm9tIGFuIGFjdGlvbiBpbnN0YW5jZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gIGlmIChhY3Rpb24uY29uc3RydWN0b3IgJiYgYWN0aW9uLmNvbnN0cnVjdG9yLnR5cGUpIHtcclxuICAgIHJldHVybiBhY3Rpb24uY29uc3RydWN0b3IudHlwZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhY3Rpb24udHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hdGNoZXMgYSBhY3Rpb25cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbk1hdGNoZXIoYWN0aW9uMTogYW55KSB7XHJcbiAgY29uc3QgdHlwZTEgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbjEpO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uMjogYW55KSB7XHJcbiAgICByZXR1cm4gdHlwZTEgPT09IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoYWN0aW9uMik7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgc2V0VmFsdWUoeyBmb286IHsgYmFyOiB7IGVhdDogZmFsc2UgfSB9IH0sXHJcbiAqICAgICAgJ2Zvby5iYXIuZWF0JywgdHJ1ZSkgLy89PiB7IGZvbzogeyBiYXI6IHsgZWF0OiB0cnVlIH0gfSB9XHJcbiAqXHJcbiAqIFdoaWxlIGl0IHRyYXZlcnNlcyBpdCBhbHNvIGNyZWF0ZXMgbmV3IG9iamVjdHMgZnJvbSB0b3AgZG93bi5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcsIHZhbDogYW55KSA9PiB7XHJcbiAgb2JqID0geyAuLi5vYmogfTtcclxuXHJcbiAgY29uc3Qgc3BsaXQgPSBwcm9wLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgbGFzdEluZGV4ID0gc3BsaXQubGVuZ3RoIC0gMTtcclxuXHJcbiAgc3BsaXQucmVkdWNlKChhY2MsIHBhcnQsIGluZGV4KSA9PiB7XHJcbiAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICBhY2NbcGFydF0gPSB2YWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhY2NbcGFydF0gPSBBcnJheS5pc0FycmF5KGFjY1twYXJ0XSkgPyBbLi4uYWNjW3BhcnRdXSA6IHsgLi4uYWNjW3BhcnRdIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjYyAmJiBhY2NbcGFydF07XHJcbiAgfSwgb2JqKTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFZhbHVlID0gKG9iajogYW55LCBwcm9wOiBzdHJpbmcpID0+XHJcbiAgcHJvcC5zcGxpdCgnLicpLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxuIiwiaW1wb3J0IHsgT3BlcmF0b3JGdW5jdGlvbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uPFQ+KGFsbG93ZWRUeXBlKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+O1xyXG5leHBvcnQgZnVuY3Rpb24gb2ZBY3Rpb248VD4oLi4uYWxsb3dlZFR5cGVzKTogT3BlcmF0b3JGdW5jdGlvbjxhbnksIFQ+O1xyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIGRpc3BhdGNoZWQgYXMgd2VsbCBhcyBhY3Rpb25zIHRoYXQgaGF2ZSBjb21wbGV0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvbiguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IGJlZW4gZGlzcGF0Y2hlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uRGlzcGF0Y2hlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTIG9wZXJhdG9yIGZvciBzZWxlY3Rpbmcgb3V0IHNwZWNpZmljIGFjdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBPTkxZIGdyYWIgYWN0aW9ucyB0aGF0IGhhdmUganVzdCBiZWVuIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvZkFjdGlvblN1Y2Nlc3NmdWwoLi4uYWxsb3dlZFR5cGVzOiBhbnlbXSkge1xyXG4gIHJldHVybiBvZkFjdGlvbk9wZXJhdG9yKGFsbG93ZWRUeXBlcywgQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwpO1xyXG59XHJcblxyXG4vKipcclxuICogUnhKUyBvcGVyYXRvciBmb3Igc2VsZWN0aW5nIG91dCBzcGVjaWZpYyBhY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGlzIHdpbGwgT05MWSBncmFiIGFjdGlvbnMgdGhhdCBoYXZlIGp1c3QgYmVlbiBjYW5jZWxlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uQ2FuY2VsZWQoLi4uYWxsb3dlZFR5cGVzOiBhbnlbXSkge1xyXG4gIHJldHVybiBvZkFjdGlvbk9wZXJhdG9yKGFsbG93ZWRUeXBlcywgQWN0aW9uU3RhdHVzLkNhbmNlbGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ4SlMgb3BlcmF0b3IgZm9yIHNlbGVjdGluZyBvdXQgc3BlY2lmaWMgYWN0aW9ucy5cclxuICpcclxuICogVGhpcyB3aWxsIE9OTFkgZ3JhYiBhY3Rpb25zIHRoYXQgaGF2ZSBqdXN0IHRocm93biBhbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9mQWN0aW9uRXJyb3JlZCguLi5hbGxvd2VkVHlwZXM6IGFueVtdKSB7XHJcbiAgcmV0dXJuIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzLCBBY3Rpb25TdGF0dXMuRXJyb3JlZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9mQWN0aW9uT3BlcmF0b3IoYWxsb3dlZFR5cGVzOiBhbnlbXSwgc3RhdHVzPzogQWN0aW9uU3RhdHVzKSB7XHJcbiAgY29uc3QgYWxsb3dlZE1hcCA9IGNyZWF0ZUFsbG93ZWRNYXAoYWxsb3dlZFR5cGVzKTtcclxuICByZXR1cm4gZnVuY3Rpb24obzogT2JzZXJ2YWJsZTxhbnk+KSB7XHJcbiAgICByZXR1cm4gby5waXBlKFxyXG4gICAgICBmaWx0ZXJTdGF0dXMoYWxsb3dlZE1hcCwgc3RhdHVzKSxcclxuICAgICAgbWFwQWN0aW9uKClcclxuICAgICk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyU3RhdHVzKGFsbG93ZWRUeXBlczogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0sIHN0YXR1cz86IEFjdGlvblN0YXR1cykge1xyXG4gIHJldHVybiBmaWx0ZXIoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgYWN0aW9uVHlwZSA9IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UoY3R4LmFjdGlvbik7XHJcbiAgICBjb25zdCB0eXBlID0gYWxsb3dlZFR5cGVzW2FjdGlvblR5cGVdO1xyXG4gICAgcmV0dXJuIHN0YXR1cyA/IHR5cGUgJiYgY3R4LnN0YXR1cyA9PT0gc3RhdHVzIDogdHlwZTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwQWN0aW9uKCkge1xyXG4gIHJldHVybiBtYXAoKGN0eDogQWN0aW9uQ29udGV4dCkgPT4gY3R4LmFjdGlvbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFsbG93ZWRNYXAodHlwZXM6IGFueVtdKTogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0ge1xyXG4gIHJldHVybiB0eXBlcy5yZWR1Y2UoKGFjYzogYW55LCBrbGFzczogYW55KSA9PiB7XHJcbiAgICBhY2NbZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShrbGFzcyldID0gdHJ1ZTtcclxuICAgIHJldHVybiBhY2M7XHJcbiAgfSwge30pO1xyXG59XHJcbiIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuLyoqXHJcbiAqIE9wZXJhdG9yIHRvIHJ1biB0aGUgYHN1YnNjcmliZWAgaW4gYSBBbmd1bGFyIHpvbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJab25lPFQ+KHpvbmU6IE5nWm9uZSkge1xyXG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHNpbms6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHtcclxuICAgICAgICBuZXh0KHgpIHtcclxuICAgICAgICAgIHpvbmUucnVuKCgpID0+IHNpbmsubmV4dCh4KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcihlKSB7XHJcbiAgICAgICAgICB6b25lLnJ1bigoKSA9PiBzaW5rLmVycm9yKGUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBsZXRlKCkge1xyXG4gICAgICAgICAgem9uZS5ydW4oKCkgPT4gc2luay5jb21wbGV0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgZW50ZXJab25lIH0gZnJvbSAnLi9vcGVyYXRvcnMvem9uZSc7XHJcblxyXG4vKipcclxuICogU3RhdHVzIG9mIGEgZGlzcGF0Y2hlZCBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnVtIEFjdGlvblN0YXR1cyB7XHJcbiAgRGlzcGF0Y2hlZCA9ICdESVNQQVRDSEVEJyxcclxuICBTdWNjZXNzZnVsID0gJ1NVQ0NFU1NGVUwnLFxyXG4gIENhbmNlbGVkID0gJ0NBTkNFTEVEJyxcclxuICBFcnJvcmVkID0gJ0VSUk9SRUQnXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ29udGV4dCB7XHJcbiAgc3RhdHVzOiBBY3Rpb25TdGF0dXM7XHJcbiAgYWN0aW9uOiBhbnk7XHJcbiAgZXJyb3I/OiBFcnJvcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSBTdWJqZWN0IHRoYXQgZW5zdXJlcyB0aGF0IHN1YnNjcmliZXJzIGFyZSBub3RpZmllZCBvZiB2YWx1ZXMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcnJpdmVkLlxyXG4gKiBBIHN0YW5kYXJkIFN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGlzIGd1YXJhbnRlZS5cclxuICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgY29kZTpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiAgIGNvbnN0IHN1YmplY3QgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG4gICAgICAgaWYgKHZhbHVlID09PSAnc3RhcnQnKSBzdWJqZWN0Lm5leHQoJ2VuZCcpO1xyXG4gICAgIH0pO1xyXG4gICAgIHN1YmplY3Quc3Vic2NyaWJlKHZhbHVlID0+IHsgfSk7XHJcbiAgICAgc3ViamVjdC5uZXh0KCdzdGFydCcpO1xyXG4gKiBgYGBcclxuICogV2hlbiBgc3ViamVjdGAgaXMgYSBzdGFuZGFyZCBgU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYGVuZGAgYW5kIHRoZW4gYHN0YXJ0YC5cclxuICogV2hlbiBgc3ViamVjdGAgaXMgYSBgT3JkZXJlZFN1YmplY3Q8VD5gIHRoZSBzZWNvbmQgc3Vic2NyaWJlciB3b3VsZCByZWNpZXZlIGBzdGFydGAgYW5kIHRoZW4gYGVuZGAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgT3JkZXJlZFN1YmplY3Q8VD4gZXh0ZW5kcyBTdWJqZWN0PFQ+IHtcclxuICBwcml2YXRlIF9pdGVtUXVldWU6IFRbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xyXG5cclxuICBuZXh0KHZhbHVlPzogVCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2J1c3lQdXNoaW5nTmV4dCkge1xyXG4gICAgICB0aGlzLl9pdGVtUXVldWUudW5zaGlmdCh2YWx1ZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IHRydWU7XHJcbiAgICBzdXBlci5uZXh0KHZhbHVlKTtcclxuICAgIHdoaWxlICh0aGlzLl9pdGVtUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLl9pdGVtUXVldWUucG9wKCk7XHJcbiAgICAgIHN1cGVyLm5leHQobmV4dFZhbHVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbEFjdGlvbnMgZXh0ZW5kcyBPcmRlcmVkU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuLyoqXHJcbiAqIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqXHJcbiAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoaXMgaW4gc2VydmljZXMgdG8gcmVhY3Qgd2l0aG91dCBzdG9yZXMuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBY3Rpb25zIGV4dGVuZHMgT2JzZXJ2YWJsZTxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcihhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBuZ1pvbmU6IE5nWm9uZSkge1xyXG4gICAgc3VwZXIob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBhY3Rpb25zJFxyXG4gICAgICAgIC5waXBlKGVudGVyWm9uZShuZ1pvbmUpKVxyXG4gICAgICAgIC5zdWJzY3JpYmUocmVzID0+IG9ic2VydmVyLm5leHQocmVzKSwgZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb21wb3NlcyBhIGFycmF5IG9mIGZ1bmN0aW9ucyBmcm9tIGxlZnQgdG8gcmlnaHQuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgICAgY29tcG9zZShbZm4sIGZpbmFsXSkoc3RhdGUsIGFjdGlvbik7XHJcbiAqXHJcbiAqIHRoZW4gdGhlIGZ1bmNzIGhhdmUgYSBzaWduYXR1cmUgbGlrZTpcclxuICpcclxuICogICAgICBmdW5jdGlvbiBmbiAoc3RhdGUsIGFjdGlvbiwgbmV4dCkge1xyXG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnaGVyZScsIHN0YXRlLCBhY3Rpb24sIG5leHQpO1xyXG4gKiAgICAgICAgICByZXR1cm4gbmV4dChzdGF0ZSwgYWN0aW9uKTtcclxuICogICAgICB9XHJcbiAqXHJcbiAqICAgICAgZnVuY3Rpb24gZmluYWwgKHN0YXRlLCBhY3Rpb24pIHtcclxuICogICAgICAgICAgY29uc29sZS5sb2coJ2hlcmUnLCBzdGF0ZSwgYWN0aW9uKTtcclxuICogICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gKiAgICAgIH1cclxuICpcclxuICogdGhlIGxhc3QgZnVuY3Rpb24gc2hvdWxkIG5vdCBjYWxsIGBuZXh0YC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbXBvc2UgPSBmdW5jcyA9PiAoLi4uYXJncykgPT4ge1xyXG4gIGNvbnN0IGN1cnIgPSBmdW5jcy5zaGlmdCgpO1xyXG4gIHJldHVybiBjdXJyKC4uLmFyZ3MsICguLi5uZXh0QXJncykgPT4gY29tcG9zZShmdW5jcykoLi4ubmV4dEFyZ3MpKTtcclxufTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbi8qKlxyXG4gKiBCZWhhdmlvclN1YmplY3Qgb2YgdGhlIGVudGlyZSBzdGF0ZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVTdHJlYW0gZXh0ZW5kcyBCZWhhdmlvclN1YmplY3Q8YW55PiB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcih7fSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5neHNQbHVnaW5GbiwgTkdYU19QTFVHSU5TLCBOZ3hzUGx1Z2luIH0gZnJvbSAnLi9zeW1ib2xzJztcclxuXHJcbi8qKlxyXG4gKiBQbHVnaW4gbWFuYWdlciBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBQbHVnaW5NYW5hZ2VyIHtcclxuICBwbHVnaW5zOiBOZ3hzUGx1Z2luRm5bXSA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50TWFuYWdlcjogUGx1Z2luTWFuYWdlcixcclxuICAgIEBJbmplY3QoTkdYU19QTFVHSU5TKVxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIHByaXZhdGUgX3BsdWdpbnM6IE5neHNQbHVnaW5bXVxyXG4gICkge1xyXG4gICAgdGhpcy5yZWdpc3RlcigpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWdpc3RlcigpIHtcclxuICAgIGlmICghdGhpcy5fcGx1Z2lucykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucy5tYXAocGx1Z2luID0+IHtcclxuICAgICAgaWYgKHBsdWdpbi5oYW5kbGUpIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luLmhhbmRsZS5iaW5kKHBsdWdpbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BhcmVudE1hbmFnZXIpIHtcclxuICAgICAgdGhpcy5fcGFyZW50TWFuYWdlci5wbHVnaW5zLnB1c2goLi4udGhpcy5wbHVnaW5zKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgRXJyb3JIYW5kbGVyLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZvcmtKb2luLCBlbXB0eSwgU3ViamVjdCwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzaGFyZVJlcGxheSwgZmlsdGVyLCBleGhhdXN0TWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gJy4uL3V0aWxzL2NvbXBvc2UnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbEFjdGlvbnMsIEFjdGlvblN0YXR1cywgQWN0aW9uQ29udGV4dCB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgU3RhdGVTdHJlYW0gfSBmcm9tICcuL3N0YXRlLXN0cmVhbSc7XHJcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi9wbHVnaW4tbWFuYWdlcic7XHJcbmltcG9ydCB7IGVudGVyWm9uZSB9IGZyb20gJy4uL29wZXJhdG9ycy96b25lJztcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBY3Rpb24gcmVzdWx0IHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhbiBhY3Rpb24gaXMgY29tcGxldGVkLlxyXG4gKiBUaGlzIGlzIHVzZWQgYXMgYSBtZXRob2Qgb2YgcmV0dXJuaW5nIHRoZSBhY3Rpb24gcmVzdWx0IHRvIHRoZSBkaXNwYXRjaGVyXHJcbiAqIGZvciB0aGUgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGUgZGlzcGF0Y2goLi4uKSBjYWxsLlxyXG4gKiBUaGUgZGlzcGF0Y2hlciB0aGVuIGFzeW5jaHJvbm91c2x5IHB1c2hlcyB0aGUgcmVzdWx0IGZyb20gdGhpcyBzdHJlYW0gb250byB0aGUgbWFpbiBhY3Rpb24gc3RyZWFtIGFzIGEgcmVzdWx0LlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyBleHRlbmRzIFN1YmplY3Q8QWN0aW9uQ29udGV4dD4ge31cclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEludGVybmFsRGlzcGF0Y2hlciB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9lcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlcixcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9wbHVnaW5NYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLFxyXG4gICAgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmVcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgZXZlbnQocykuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2goZXZlbnQ6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIGNvbnN0IHJlc3VsdDogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmtKb2luKGV2ZW50Lm1hcChhID0+IHRoaXMuZGlzcGF0Y2hTaW5nbGUoYSkpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaFNpbmdsZShldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJlc3VsdC5zdWJzY3JpYmUoe1xyXG4gICAgICBlcnJvcjogZXJyb3IgPT4gdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLl9lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdC5waXBlKGVudGVyWm9uZSh0aGlzLl9uZ1pvbmUpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGlzcGF0Y2hTaW5nbGUoYWN0aW9uOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKTtcclxuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5NYW5hZ2VyLnBsdWdpbnM7XHJcblxyXG4gICAgcmV0dXJuIChjb21wb3NlKFtcclxuICAgICAgLi4ucGx1Z2lucyxcclxuICAgICAgKG5leHRTdGF0ZSwgbmV4dEFjdGlvbikgPT4ge1xyXG4gICAgICAgIGlmIChuZXh0U3RhdGUgIT09IHByZXZTdGF0ZSkge1xyXG4gICAgICAgICAgdGhpcy5fc3RhdGVTdHJlYW0ubmV4dChuZXh0U3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY3Rpb25SZXN1bHQkID0gdGhpcy5nZXRBY3Rpb25SZXN1bHRTdHJlYW0obmV4dEFjdGlvbik7XHJcbiAgICAgICAgYWN0aW9uUmVzdWx0JC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvbnMubmV4dChjdHgpKTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zLm5leHQoeyBhY3Rpb246IG5leHRBY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlzcGF0Y2hPYnNlcnZhYmxlKGFjdGlvblJlc3VsdCQpO1xyXG4gICAgICB9XHJcbiAgICBdKShwcmV2U3RhdGUsIGFjdGlvbikgYXMgT2JzZXJ2YWJsZTxhbnk+KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRBY3Rpb25SZXN1bHRTdHJlYW0oYWN0aW9uOiBhbnkpOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9hY3Rpb25SZXN1bHRzLnBpcGUoXHJcbiAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguYWN0aW9uID09PSBhY3Rpb24gJiYgY3R4LnN0YXR1cyAhPT0gQWN0aW9uU3RhdHVzLkRpc3BhdGNoZWQpLFxyXG4gICAgICB0YWtlKDEpLFxyXG4gICAgICBzaGFyZVJlcGxheSgpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVEaXNwYXRjaE9ic2VydmFibGUoYWN0aW9uUmVzdWx0JDogT2JzZXJ2YWJsZTxBY3Rpb25Db250ZXh0Pik6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gYWN0aW9uUmVzdWx0JFxyXG4gICAgICAucGlwZShcclxuICAgICAgICBleGhhdXN0TWFwKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IHtcclxuICAgICAgICAgIHN3aXRjaCAoY3R4LnN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlIEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsOlxyXG4gICAgICAgICAgICAgIHJldHVybiBvZih0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgY2FzZSBBY3Rpb25TdGF0dXMuRXJyb3JlZDpcclxuICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihjdHguZXJyb3IpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIClcclxuICAgICAgLnBpcGUoc2hhcmVSZXBsYXkoKSk7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBPYmplY3QgZnJlZXplIGNvZGVcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzZGYvZGVlcC1mcmVlemVcclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWVwRnJlZXplID0gbyA9PiB7XHJcbiAgT2JqZWN0LmZyZWV6ZShvKTtcclxuXHJcbiAgY29uc3Qgb0lzRnVuY3Rpb24gPSB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJztcclxuICBjb25zdCBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIGhhc093blByb3AuY2FsbChvLCBwcm9wKSAmJlxyXG4gICAgICAob0lzRnVuY3Rpb24gPyBwcm9wICE9PSAnY2FsbGVyJyAmJiBwcm9wICE9PSAnY2FsbGVlJyAmJiBwcm9wICE9PSAnYXJndW1lbnRzJyA6IHRydWUpICYmXHJcbiAgICAgIG9bcHJvcF0gIT09IG51bGwgJiZcclxuICAgICAgKHR5cGVvZiBvW3Byb3BdID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykgJiZcclxuICAgICAgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKVxyXG4gICAgKSB7XHJcbiAgICAgIGRlZXBGcmVlemUob1twcm9wXSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBvO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IEludGVybmFsRGlzcGF0Y2hlciB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vc3RhdGUtc3RyZWFtJztcclxuaW1wb3J0IHsgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBkZWVwRnJlZXplIH0gZnJvbSAnLi4vdXRpbHMvZnJlZXplJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBDb250ZXh0IGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3N0YXRlU3RyZWFtOiBTdGF0ZVN0cmVhbSwgcHJpdmF0ZSBfZGlzcGF0Y2hlcjogSW50ZXJuYWxEaXNwYXRjaGVyLCBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcpIHtcclxuICAgIHRoaXMudmVyaWZ5RGV2TW9kZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcm9vdCBzdGF0ZSBvcGVyYXRvcnMuXHJcbiAgICovXHJcbiAgZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpOiBTdGF0ZU9wZXJhdGlvbnM8YW55PiB7XHJcbiAgICBjb25zdCByb290U3RhdGVPcGVyYXRpb25zID0ge1xyXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gdGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKSxcclxuICAgICAgc2V0U3RhdGU6IG5ld1N0YXRlID0+IHRoaXMuX3N0YXRlU3RyZWFtLm5leHQobmV3U3RhdGUpLFxyXG4gICAgICBkaXNwYXRjaDogYWN0aW9ucyA9PiB0aGlzLl9kaXNwYXRjaGVyLmRpc3BhdGNoKGFjdGlvbnMpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLl9jb25maWcuZGV2ZWxvcG1lbnRNb2RlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVuc3VyZVN0YXRlQW5kQWN0aW9uc0FyZUltbXV0YWJsZShyb290U3RhdGVPcGVyYXRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdFN0YXRlT3BlcmF0aW9ucztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgdmVyaWZ5RGV2TW9kZSgpIHtcclxuICAgIGNvbnN0IGlzTmd4c0Rldk1vZGUgPSB0aGlzLl9jb25maWcuZGV2ZWxvcG1lbnRNb2RlO1xyXG4gICAgY29uc3QgaXNOZ0Rldk1vZGUgPSBpc0Rldk1vZGUoKTtcclxuICAgIGNvbnN0IGluY29ycmVjdFByb2R1Y3Rpb24gPSAhaXNOZ0Rldk1vZGUgJiYgaXNOZ3hzRGV2TW9kZTtcclxuICAgIGNvbnN0IGluY29ycmVjdERldmVsb3BtZW50ID0gaXNOZ0Rldk1vZGUgJiYgIWlzTmd4c0Rldk1vZGU7XHJcbiAgICBjb25zdCBleGFtcGxlID0gJ05neHNNb2R1bGUuZm9yUm9vdChzdGF0ZXMsIHsgZGV2ZWxvcG1lbnRNb2RlOiAhZW52aXJvbm1lbnQucHJvZHVjdGlvbiB9KSc7XHJcblxyXG4gICAgaWYgKGluY29ycmVjdFByb2R1Y3Rpb24pIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlIGJ1dCBOR1hTIGlzIHN0aWxsIHJ1bm5pbmcgaW4gdGhlIGRldmVsb3BtZW50IG1vZGUhXFxuJyxcclxuICAgICAgICAnUGxlYXNlIHNldCBkZXZlbG9wbWVudE1vZGUgdG8gZmFsc2Ugb24gdGhlIE5neHNNb2R1bGUgb3B0aW9ucyB3aGVuIGluIHByb2R1Y3Rpb24gbW9kZS5cXG4nLFxyXG4gICAgICAgIGV4YW1wbGVcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoaW5jb3JyZWN0RGV2ZWxvcG1lbnQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdSRUNPTU1FTkRBVElPTjogU2V0IGRldmVsb3BtZW50TW9kZSB0byB0cnVlIG9uIHRoZSBOZ3hzTW9kdWxlIHdoZW4gQW5ndWxhciBpcyBydW5uaW5nIGluIGRldmVsb3BtZW50IG1vZGUuXFxuJyxcclxuICAgICAgICBleGFtcGxlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGVuc3VyZVN0YXRlQW5kQWN0aW9uc0FyZUltbXV0YWJsZShyb290OiBTdGF0ZU9wZXJhdGlvbnM8YW55Pik6IFN0YXRlT3BlcmF0aW9uczxhbnk+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdldFN0YXRlOiAoKSA9PiByb290LmdldFN0YXRlKCksXHJcbiAgICAgIHNldFN0YXRlOiB2YWx1ZSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJvemVuVmFsdWUgPSBkZWVwRnJlZXplKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcm9vdC5zZXRTdGF0ZShmcm96ZW5WYWx1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGRpc3BhdGNoOiBhY3Rpb25zID0+IHtcclxuICAgICAgICByZXR1cm4gcm9vdC5kaXNwYXRjaChhY3Rpb25zKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHQgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgTWFwcGVkU3RvcmUgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBzZXRWYWx1ZSwgZ2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcblxyXG4vKipcclxuICogU3RhdGUgQ29udGV4dCBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YXRlQ29udGV4dEZhY3Rvcnkge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2ludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucykge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBzdGF0ZSBjb250ZXh0XHJcbiAgICovXHJcbiAgY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhOiBNYXBwZWRTdG9yZSk6IFN0YXRlQ29udGV4dDxhbnk+IHtcclxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnZXRTdGF0ZSgpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiBnZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgpO1xyXG4gICAgICB9LFxyXG4gICAgICBwYXRjaFN0YXRlKHZhbDogYW55KTogYW55IHtcclxuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWwpO1xyXG4gICAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gdHlwZW9mIHZhbCAhPT0gJ29iamVjdCc7XHJcblxyXG4gICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGNoaW5nIGFycmF5cyBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0Y2hpbmcgcHJpbWl0aXZlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSByb290LmdldFN0YXRlKCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWwgPSBnZXRWYWx1ZShzdGF0ZSwgbWV0YWRhdGEuZGVwdGgpO1xyXG4gICAgICAgIGNvbnN0IGNsb25lID0geyAuLi5sb2NhbCB9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsKSB7XHJcbiAgICAgICAgICBjbG9uZVtrXSA9IHZhbFtrXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoLCBjbG9uZSk7XHJcbiAgICAgICAgcm9vdC5zZXRTdGF0ZShuZXdTdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXRTdGF0ZSh2YWw6IGFueSk6IGFueSB7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHN0YXRlID0gc2V0VmFsdWUoc3RhdGUsIG1ldGFkYXRhLmRlcHRoLCB2YWwpO1xyXG4gICAgICAgIHJvb3Quc2V0U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgfSxcclxuICAgICAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiByb290LmRpc3BhdGNoKGFjdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RvciwgSW5qZWN0YWJsZSwgU2tpcFNlbGYsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmb3JrSm9pbiwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzaGFyZVJlcGxheSwgdGFrZVVudGlsLCBtYXAsIGNhdGNoRXJyb3IsIGZpbHRlciwgbWVyZ2VNYXAsIGRlZmF1bHRJZkVtcHR5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNMaWZlQ3ljbGUsIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHtcclxuICB0b3BvbG9naWNhbFNvcnQsXHJcbiAgYnVpbGRHcmFwaCxcclxuICBmaW5kRnVsbFBhcmVudFBhdGgsXHJcbiAgbmFtZVRvU3RhdGUsXHJcbiAgcHJvcEdldHRlcixcclxuICBpc09iamVjdCxcclxuICBTdGF0ZUNsYXNzLFxyXG4gIE1hcHBlZFN0b3JlXHJcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aW9ucywgQWN0aW9uU3RhdHVzLCBBY3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5cclxuLyoqXHJcbiAqIFN0YXRlIGZhY3RvcnkgY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IHtcclxuICBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG4gIHByaXZhdGUgX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcclxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBAU2tpcFNlbGYoKVxyXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uczogSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnlcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXHJcbiAgICovXHJcbiAgYWRkKG9uZU9yTWFueVN0YXRlQ2xhc3NlczogU3RhdGVDbGFzcyB8IFN0YXRlQ2xhc3NbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgbGV0IHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9uZU9yTWFueVN0YXRlQ2xhc3NlcykpIHtcclxuICAgICAgc3RhdGVDbGFzc2VzID0gW29uZU9yTWFueVN0YXRlQ2xhc3Nlc107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0ZUNsYXNzZXMgPSBvbmVPck1hbnlTdGF0ZUNsYXNzZXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3RhdGVHcmFwaCA9IGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHNvcnRlZFN0YXRlcyA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IGRlcHRocyA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IG5hbWVHcmFwaCA9IG5hbWVUb1N0YXRlKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3MgPSBuYW1lR3JhcGhbbmFtZV07XHJcblxyXG4gICAgICBpZiAoIXN0YXRlQ2xhc3NbTUVUQV9LRVldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZXMgbXVzdCBiZSBkZWNvcmF0ZWQgd2l0aCBAU3RhdGUoKSBkZWNvcmF0b3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGVwdGggPSBkZXB0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IHsgYWN0aW9ucyB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV07XHJcbiAgICAgIGxldCB7IGRlZmF1bHRzIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXTtcclxuXHJcbiAgICAgIHN0YXRlQ2xhc3NbTUVUQV9LRVldLnBhdGggPSBkZXB0aDtcclxuICAgICAgc3RhdGVDbGFzc1tNRVRBX0tFWV0uc2VsZWN0RnJvbUFwcFN0YXRlID0gcHJvcEdldHRlcihkZXB0aC5zcGxpdCgnLicpLCB0aGlzLl9jb25maWcpO1xyXG5cclxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgIC8vIGJ1dCBkb250IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcclxuICAgICAgLy8gbG9hZGVkIGZyb20gZGlmZmVyZW50IHBhdGhzXHJcbiAgICAgIGNvbnN0IGhhcyA9IHRoaXMuc3RhdGVzLmZpbmQocyA9PiBzLm5hbWUgPT09IG5hbWUpO1xyXG4gICAgICBpZiAoIWhhcykge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgZGVmYXVsdHNcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcclxuICAgICAgICAgIGRlZmF1bHRzID0gWy4uLmRlZmF1bHRzXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xyXG4gICAgICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzIH07XHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBkZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9pbmplY3Rvci5nZXQoc3RhdGVDbGFzcyk7XHJcblxyXG4gICAgICAgIG1hcHBlZFN0b3Jlcy5wdXNoKHtcclxuICAgICAgICAgIGFjdGlvbnMsXHJcbiAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgIGRlZmF1bHRzLFxyXG4gICAgICAgICAgbmFtZSxcclxuICAgICAgICAgIGRlcHRoXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0YXRlcy5wdXNoKC4uLm1hcHBlZFN0b3Jlcyk7XHJcblxyXG4gICAgcmV0dXJuIG1hcHBlZFN0b3JlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHN0c1xyXG4gICAqL1xyXG4gIGFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlQ2xhc3NlczogYW55W10pOiB7IGRlZmF1bHRzOiBhbnk7IHN0YXRlczogTWFwcGVkU3RvcmVbXSB9IHtcclxuICAgIGlmIChzdGF0ZUNsYXNzZXMpIHtcclxuICAgICAgY29uc3Qgc3RhdGVzID0gdGhpcy5hZGQoc3RhdGVDbGFzc2VzKTtcclxuICAgICAgY29uc3QgZGVmYXVsdHMgPSBzdGF0ZXMucmVkdWNlKFxyXG4gICAgICAgIChyZXN1bHQ6IGFueSwgbWV0YTogTWFwcGVkU3RvcmUpID0+IHNldFZhbHVlKHJlc3VsdCwgbWV0YS5kZXB0aCwgbWV0YS5kZWZhdWx0cyksXHJcbiAgICAgICAge31cclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlcyB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcclxuICAgKi9cclxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSByZXR1cm47XHJcbiAgICB0aGlzLl9hY3Rpb25zXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XHJcbiAgICAgICAgICB0aGlzLmludm9rZUFjdGlvbnModGhpcy5fYWN0aW9ucywgYWN0aW9uKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXHJcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcclxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSkpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcclxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgdGhlIGluaXQgZnVuY3Rpb24gb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VJbml0KHN0YXRlTWV0YWRhdGFzOiBNYXBwZWRTdG9yZVtdKSB7XHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHN0YXRlTWV0YWRhdGFzKSB7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBOZ3hzTGlmZUN5Y2xlID0gbWV0YWRhdGEuaW5zdGFuY2U7XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2Uubmd4c09uSW5pdCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICBpbnN0YW5jZS5uZ3hzT25Jbml0KHN0YXRlQ29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXHJcbiAgICovXHJcbiAgaW52b2tlQWN0aW9ucyhhY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLCBhY3Rpb24pIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbik7XHJcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xyXG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uTWV0YS5vcHRpb25zLmNhbmNlbFVuY29tcGxldGVkXHJcbiAgICAgICAgICAgICAgICAgID8gdGFrZVVudGlsKGFjdGlvbnMkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbikpKVxyXG4gICAgICAgICAgICAgICAgICA6IG1hcChyID0+IHIpXHJcbiAgICAgICAgICAgICAgKTsgLy8gbWFwIGFjdHMgbGlrZSBhIG5vb3BcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgc3RhdGUgY29udGV4dFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhOiBNYXBwZWRTdG9yZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICB9XHJcbn1cclxuIiwiZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xyXG4gIHJldHVybiBhID09PSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChlcXVhbGl0eUNoZWNrLCBwcmV2LCBuZXh0KSB7XHJcbiAgaWYgKHByZXYgPT09IG51bGwgfHwgbmV4dCA9PT0gbnVsbCB8fCBwcmV2Lmxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXHJcbiAgY29uc3QgbGVuZ3RoID0gcHJldi5sZW5ndGg7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogTWVtb2l6ZSBhIGZ1bmN0aW9uIG9uIGl0cyBsYXN0IGlucHV0cyBvbmx5LlxyXG4gKiBPcmluZ2luYWxseSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZXNlbGVjdC9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVjayA9IGRlZmF1bHRFcXVhbGl0eUNoZWNrKSB7XHJcbiAgbGV0IGxhc3RBcmdzID0gbnVsbDtcclxuICBsZXQgbGFzdFJlc3VsdCA9IG51bGw7XHJcbiAgLy8gd2UgcmVmZXJlbmNlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXHJcbiAgcmV0dXJuIDwoLi4uYXJncykgPT4gYW55PmZ1bmN0aW9uIG1lbW9pemVkKCkge1xyXG4gICAgaWYgKCFhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChlcXVhbGl0eUNoZWNrLCBsYXN0QXJncywgYXJndW1lbnRzKSkge1xyXG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxyXG4gICAgICBsYXN0UmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xyXG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBTZWxlY3RGcm9tU3RhdGUsIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEsIGdldFNlbGVjdG9yTWV0YWRhdGEsIGdldFN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbHMvbWVtb2l6ZSc7XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgc2VsZWN0b3JcclxuICogQHBhcmFtIHNlbGVjdG9ycyBUaGUgc2VsZWN0b3JzIHRvIHVzZSB0byBjcmVhdGUgdGhlIGFyZ3VtZW50cyBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBiZWluZyBtYWRlIGludG8gYSBzZWxlY3RvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKFxyXG4gIHNlbGVjdG9yczogYW55W10sXHJcbiAgb3JpZ2luYWxGbjogYW55LFxyXG4gIGNyZWF0aW9uTWV0YWRhdGE/OiB7IGNvbnRhaW5lckNsYXNzOiBhbnk7IHNlbGVjdG9yTmFtZTogc3RyaW5nIH1cclxuKSB7XHJcbiAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZFNlbGVjdG9yRm4oLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcmlnaW5hbEZuKC4uLmFyZ3MpO1xyXG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgY29uc3QgaW5uZXJNZW1vaXplZEZuID0gbWVtb2l6ZS5hcHBseShudWxsLCBbcmV0dXJuVmFsdWVdKTtcclxuICAgICAgcmV0dXJuIGlubmVyTWVtb2l6ZWRGbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICB9O1xyXG4gIGNvbnN0IG1lbW9pemVkRm4gPSBtZW1vaXplKHdyYXBwZWRGbik7XHJcbiAgY29uc3QgY29udGFpbmVyQ2xhc3MgPSBjcmVhdGlvbk1ldGFkYXRhICYmIGNyZWF0aW9uTWV0YWRhdGEuY29udGFpbmVyQ2xhc3M7XHJcblxyXG4gIGNvbnN0IGZuID0gc3RhdGUgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdG9yc1RvQXBwbHkgPSBbXTtcclxuXHJcbiAgICBpZiAoY29udGFpbmVyQ2xhc3MpIHtcclxuICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhdGUgY2xhc3MsIGFkZCBpdCBhcyB0aGUgZmlyc3Qgc2VsZWN0b3IgcGFyYW1ldGVyXHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0U3RvcmVNZXRhZGF0YShjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaChjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZWxlY3RvcnMpIHtcclxuICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKC4uLnNlbGVjdG9ycyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlcm1pbmUgYXJndW1lbnRzIGZyb20gdGhlIGFwcCBzdGF0ZSB1c2luZyB0aGUgc2VsZWN0b3JzXHJcbiAgICBpZiAoc2VsZWN0b3JzVG9BcHBseSkge1xyXG4gICAgICByZXN1bHRzLnB1c2goLi4uc2VsZWN0b3JzVG9BcHBseS5tYXAoYSA9PiBnZXRTZWxlY3RvckZuKGEpKHN0YXRlKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmIHRoZSBsYW1iZGEgdHJpZXMgdG8gYWNjZXNzIGEgc29tZXRoaW5nIG9uIHRoZVxyXG4gICAgLy8gc3RhdGUgdGhhdCBkb2Vzbid0IGV4aXN0LCBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxyXG4gICAgLy8gc2luY2UgdGhpcyBpcyBxdWl0ZSB1c3VhbCBiZWhhdmlvdXIsIHdlIHNpbXBseSByZXR1cm4gdW5kZWZpbmVkIGlmIHNvLlxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIG1lbW9pemVkRm4oLi4ucmVzdWx0cyk7XHJcbiAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGV4O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yTWV0YURhdGEgPSBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKG1lbW9pemVkRm4pO1xyXG4gIHNlbGVjdG9yTWV0YURhdGEub3JpZ2luYWxGbiA9IG9yaWdpbmFsRm47XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUgPSBmbjtcclxuICBpZiAoY3JlYXRpb25NZXRhZGF0YSkge1xyXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5jb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEuY29udGFpbmVyQ2xhc3M7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdG9yTmFtZSA9IGNyZWF0aW9uTWV0YWRhdGEuc2VsZWN0b3JOYW1lO1xyXG4gIH1cclxuICByZXR1cm4gbWVtb2l6ZWRGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZ2V0cyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdG8gYmUgdXNlZCB0byBnZXQgdGhlIHNlbGVjdGVkIHNsaWNlIGZyb20gdGhlIGFwcCBzdGF0ZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0b3JGbihzZWxlY3RvcjogYW55KTogU2VsZWN0RnJvbVN0YXRlIHtcclxuICBjb25zdCBtZXRhZGF0YSA9IGdldFNlbGVjdG9yTWV0YWRhdGEoc2VsZWN0b3IpIHx8IGdldFN0b3JlTWV0YWRhdGEoc2VsZWN0b3IpO1xyXG4gIHJldHVybiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuc2VsZWN0RnJvbUFwcFN0YXRlKSB8fCBzZWxlY3RvcjtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgZ2V0U2VsZWN0b3JGbiB9IGZyb20gJy4vdXRpbHMvc2VsZWN0b3ItdXRpbHMnO1xyXG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBlbnRlclpvbmUgfSBmcm9tICcuL29wZXJhdG9ycy96b25lJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0b3JlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVTdHJlYW06IFN0YXRlU3RyZWFtLFxyXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zXHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVzIGV2ZW50KHMpLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKGV2ZW50OiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLmRpc3BhdGNoKGV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdHMgYSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxyXG4gICAqL1xyXG4gIHNlbGVjdDxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBPYnNlcnZhYmxlPFQ+O1xyXG4gIHNlbGVjdChzZWxlY3Rvcjogc3RyaW5nIHwgYW55KTogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gIHNlbGVjdChzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSBnZXRTZWxlY3RvckZuKHNlbGVjdG9yKTtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0cmVhbS5waXBlKFxyXG4gICAgICBtYXAoc2VsZWN0b3JGbiksXHJcbiAgICAgIGNhdGNoRXJyb3IoZXJyID0+IHtcclxuICAgICAgICAvLyBpZiBlcnJvciBpcyBUeXBlRXJyb3Igd2Ugc3dhbGxvdyBpdCB0byBwcmV2ZW50IHVzdWFsIGVycm9ycyB3aXRoIHByb3BlcnR5IGFjY2Vzc1xyXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmV0aHJvdyBvdGhlciBlcnJvcnNcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH0pLFxyXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxyXG4gICAgICBlbnRlclpvbmUodGhpcy5fbmdab25lKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBvbmUgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSBzdG9yZS5cclxuICAgKi9cclxuICBzZWxlY3RPbmNlPFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XHJcbiAgc2VsZWN0T25jZShzZWxlY3Rvcjogc3RyaW5nIHwgYW55KTogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gIHNlbGVjdE9uY2Uoc2VsZWN0b3I6IGFueSk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLnBpcGUodGFrZSgxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgYSBzbmFwc2hvdCBmcm9tIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBzZWxlY3RTbmFwc2hvdDxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBUO1xyXG4gIHNlbGVjdFNuYXBzaG90KHNlbGVjdG9yOiBzdHJpbmcgfCBhbnkpOiBhbnk7XHJcbiAgc2VsZWN0U25hcHNob3Qoc2VsZWN0b3I6IGFueSk6IGFueSB7XHJcbiAgICBjb25zdCBzZWxlY3RvckZuID0gZ2V0U2VsZWN0b3JGbihzZWxlY3Rvcik7XHJcbiAgICByZXR1cm4gc2VsZWN0b3JGbih0aGlzLl9zdGF0ZVN0cmVhbS5nZXRWYWx1ZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbG93IHRoZSB1c2VyIHRvIHN1YnNjcmliZSB0byB0aGUgcm9vdCBvZiB0aGUgc3RhdGVcclxuICAgKi9cclxuICBzdWJzY3JpYmUoZm4/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RyZWFtLnBpcGUoZW50ZXJab25lKHRoaXMuX25nWm9uZSkpLnN1YnNjcmliZShmbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHJhdyB2YWx1ZSBvZiB0aGUgc3RhdGUuXHJcbiAgICovXHJcbiAgc25hcHNob3QoKTogYW55IHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5nZXRSb290U3RhdGVPcGVyYXRpb25zKCkuZ2V0U3RhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxyXG4gICAqIGZvciBwbHVnaW4ncyB3aG8gbmVlZCB0byBtb2RpZnkgdGhlIHN0YXRlIGRpcmVjdGx5IG9yIHVuaXQgdGVzdGluZy5cclxuICAgKi9cclxuICByZXNldChzdGF0ZTogYW55KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLnNldFN0YXRlKHN0YXRlKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcuLi9zdG9yZSc7XHJcbmltcG9ydCB7IHByb3BHZXR0ZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB0aGUgc2VsZWN0IGRlY29yYXRvciB0byBnZXQgYWNjZXNzIHRvIHRoZSBESSBzdG9yZS5cclxuICogQGlnbm9yZVxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0RmFjdG9yeSB7XHJcbiAgc3RhdGljIHN0b3JlOiBTdG9yZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICBzdGF0aWMgY29uZmlnOiBOZ3hzQ29uZmlnIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIGNvbnN0cnVjdG9yKHN0b3JlOiBTdG9yZSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XHJcbiAgICBTZWxlY3RGYWN0b3J5LnN0b3JlID0gc3RvcmU7XHJcbiAgICBTZWxlY3RGYWN0b3J5LmNvbmZpZyA9IGNvbmZpZztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZm9yIHNlbGVjdGluZyBhIHNsaWNlIG9mIHN0YXRlIGZyb20gdGhlIHN0b3JlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdChzZWxlY3Rvck9yRmVhdHVyZT8sIC4uLnBhdGhzOiBzdHJpbmdbXSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzZWxlY3RvckZuTmFtZSA9ICdfXycgKyBuYW1lICsgJ19fc2VsZWN0b3InO1xyXG5cclxuICAgIGlmICghc2VsZWN0b3JPckZlYXR1cmUpIHtcclxuICAgICAgLy8gaWYgZm9vJCA9PiBtYWtlIGl0IGp1c3QgZm9vXHJcbiAgICAgIHNlbGVjdG9yT3JGZWF0dXJlID0gbmFtZS5sYXN0SW5kZXhPZignJCcpID09PSBuYW1lLmxlbmd0aCAtIDEgPyBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpIDogbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjcmVhdGVTZWxlY3QgPSBmbiA9PiB7XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gU2VsZWN0RmFjdG9yeS5zdG9yZTtcclxuXHJcbiAgICAgIGlmICghc3RvcmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdEZhY3Rvcnkgbm90IGNvbm5lY3RlZCB0byBzdG9yZSEnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0b3JlLnNlbGVjdChmbik7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWcgPSBTZWxlY3RGYWN0b3J5LmNvbmZpZztcclxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yRmVhdHVyZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zdCBwcm9wc0FycmF5ID0gcGF0aHMubGVuZ3RoID8gW3NlbGVjdG9yT3JGZWF0dXJlLCAuLi5wYXRoc10gOiBzZWxlY3Rvck9yRmVhdHVyZS5zcGxpdCgnLicpO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJvcEdldHRlcihwcm9wc0FycmF5LCBjb25maWcpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXSAmJiBzZWxlY3Rvck9yRmVhdHVyZVtNRVRBX0tFWV0ucGF0aCkge1xyXG4gICAgICAgIHJldHVybiBwcm9wR2V0dGVyKHNlbGVjdG9yT3JGZWF0dXJlW01FVEFfS0VZXS5wYXRoLnNwbGl0KCcuJyksIGNvbmZpZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yT3JGZWF0dXJlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0YXJnZXRbc2VsZWN0b3JGbk5hbWVdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgQFNlbGVjdCBkZWNvcmF0b3IgYW5kIGEgJyArIHNlbGVjdG9yRm5OYW1lICsgJyBwcm9wZXJ0eS4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGVsZXRlIHRhcmdldFtuYW1lXSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBzZWxlY3RvckZuTmFtZSwge1xyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXNbc2VsZWN0b3JGbk5hbWVdIHx8ICh0aGlzW3NlbGVjdG9yRm5OYW1lXSA9IGNyZWF0ZVNlbGVjdC5hcHBseSh0aGlzLCBbY3JlYXRlU2VsZWN0b3IoKV0pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuIiwiLyoqXHJcbiAqIEluaXQgYWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW5pdFN0YXRlIHtcclxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcbiAgICAvLyBOT1RFOiBOb3QgbmVjZXNzYXJ5IHRvIGRlY2xhcmUgdGhlIHR5cGUgaW4gdGhpcyB3YXkgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvcHVsbC82NDQjaXNzdWVjb21tZW50LTQzNjAwMzEzOFxyXG4gICAgcmV0dXJuICdAQElOSVQnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBhY3Rpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBVcGRhdGVTdGF0ZSB7XHJcbiAgc3RhdGljIGdldCB0eXBlKCkge1xyXG4gICAgLy8gTk9URTogTm90IG5lY2Vzc2FyeSB0byBkZWNsYXJlIHRoZSB0eXBlIGluIHRoaXMgd2F5IGluIHlvdXIgY29kZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL3B1bGwvNjQ0I2lzc3VlY29tbWVudC00MzYwMDMxMzhcclxuICAgIHJldHVybiAnQEBVUERBVEVfU1RBVEUnO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBOZ01vZHVsZSwgTW9kdWxlV2l0aFByb3ZpZGVycywgT3B0aW9uYWwsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IFJPT1RfU1RBVEVfVE9LRU4sIEZFQVRVUkVfU1RBVEVfVE9LRU4sIE5neHNDb25maWcgfSBmcm9tICcuL3N5bWJvbHMnO1xyXG5pbXBvcnQgeyBTdGF0ZUZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWZhY3RvcnknO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5pbXBvcnQgeyBBY3Rpb25zLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyLCBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4vc3RvcmUnO1xyXG5pbXBvcnQgeyBTZWxlY3RGYWN0b3J5IH0gZnJvbSAnLi9kZWNvcmF0b3JzL3NlbGVjdCc7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBQbHVnaW5NYW5hZ2VyIH0gZnJvbSAnLi9wbHVnaW4tbWFuYWdlcic7XHJcbmltcG9ydCB7IEluaXRTdGF0ZSwgVXBkYXRlU3RhdGUgfSBmcm9tICcuL2FjdGlvbnMvYWN0aW9ucyc7XHJcblxyXG4vKipcclxuICogUm9vdCBtb2R1bGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuQE5nTW9kdWxlKClcclxuZXhwb3J0IGNsYXNzIE5neHNSb290TW9kdWxlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIGludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgIHN0b3JlOiBTdG9yZSxcclxuICAgIHNlbGVjdDogU2VsZWN0RmFjdG9yeSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KFJPT1RfU1RBVEVfVE9LRU4pXHJcbiAgICBzdGF0ZXM6IGFueVtdXHJcbiAgKSB7XHJcbiAgICAvLyBhZGQgc3RvcmVzIHRvIHRoZSBzdGF0ZSBncmFwaCBhbmQgcmV0dXJuIHRoZWlyIGRlZmF1bHRzXHJcbiAgICBjb25zdCByZXN1bHRzID0gZmFjdG9yeS5hZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZXMpO1xyXG5cclxuICAgIGNvbnN0IHN0YXRlT3BlcmF0aW9ucyA9IGludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKTtcclxuICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgIC8vIGdldCBvdXIgY3VycmVudCBzdHJlYW1cclxuICAgICAgY29uc3QgY3VyID0gc3RhdGVPcGVyYXRpb25zLmdldFN0YXRlKCk7XHJcblxyXG4gICAgICAvLyBzZXQgdGhlIHN0YXRlIHRvIHRoZSBjdXJyZW50ICsgbmV3XHJcbiAgICAgIHN0YXRlT3BlcmF0aW9ucy5zZXRTdGF0ZSh7IC4uLmN1ciwgLi4ucmVzdWx0cy5kZWZhdWx0cyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25uZWN0IG91ciBhY3Rpb25zIHN0cmVhbVxyXG4gICAgZmFjdG9yeS5jb25uZWN0QWN0aW9uSGFuZGxlcnMoKTtcclxuXHJcbiAgICAvLyBkaXNwYXRjaCB0aGUgaW5pdCBhY3Rpb24gYW5kIGludm9rZSBpbml0IGZ1bmN0aW9uIGFmdGVyXHJcbiAgICBzdGF0ZU9wZXJhdGlvbnMuZGlzcGF0Y2gobmV3IEluaXRTdGF0ZSgpKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICBpZiAocmVzdWx0cykge1xyXG4gICAgICAgIGZhY3RvcnkuaW52b2tlSW5pdChyZXN1bHRzLnN0YXRlcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZlYXR1cmUgbW9kdWxlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBOZ01vZHVsZSh7fSlcclxuZXhwb3J0IGNsYXNzIE5neHNGZWF0dXJlTW9kdWxlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHN0b3JlOiBTdG9yZSxcclxuICAgIGludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgIGZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KEZFQVRVUkVfU1RBVEVfVE9LRU4pXHJcbiAgICBzdGF0ZXM6IGFueVtdW11cclxuICApIHtcclxuICAgIC8vIFNpbmNlIEZFQVRVUkVfU1RBVEVfVE9LRU4gaXMgYSBtdWx0aSB0b2tlbiwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZmxhdHRlbiBpdCBbW0ZlYXR1cmUxU3RhdGUsIEZlYXR1cmUyU3RhdGVdLCBbRmVhdHVyZTNTdGF0ZV1dXHJcbiAgICBjb25zdCBmbGF0dGVuZWRTdGF0ZXMgPSAoW10gYXMgYW55W10pLmNvbmNhdCguLi5zdGF0ZXMpO1xyXG5cclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKGZsYXR0ZW5lZFN0YXRlcyk7XHJcblxyXG4gICAgY29uc3Qgc3RhdGVPcGVyYXRpb25zID0gaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xyXG4gICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgLy8gZ2V0IG91ciBjdXJyZW50IHN0cmVhbVxyXG4gICAgICBjb25zdCBjdXIgPSBzdGF0ZU9wZXJhdGlvbnMuZ2V0U3RhdGUoKTtcclxuXHJcbiAgICAgIC8vIHNldCB0aGUgc3RhdGUgdG8gdGhlIGN1cnJlbnQgKyBuZXdcclxuICAgICAgc3RhdGVPcGVyYXRpb25zLnNldFN0YXRlKHsgLi4uY3VyLCAuLi5yZXN1bHRzLmRlZmF1bHRzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlT3BlcmF0aW9ucy5kaXNwYXRjaChuZXcgVXBkYXRlU3RhdGUoKSkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgaWYgKHJlc3VsdHMpIHtcclxuICAgICAgICBmYWN0b3J5Lmludm9rZUluaXQocmVzdWx0cy5zdGF0ZXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1vZHVsZU9wdGlvbnMgPSBQYXJ0aWFsPE5neHNDb25maWc+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5neHNDb25maWdGYWN0b3J5KG9wdGlvbnM6IE1vZHVsZU9wdGlvbnMpOiBOZ3hzQ29uZmlnIHtcclxuICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKG5ldyBOZ3hzQ29uZmlnKCksIG9wdGlvbnMpO1xyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBST09UX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TW9kdWxlT3B0aW9ucz4oJ1JPT1RfT1BUSU9OUycpO1xyXG5cclxuLyoqXHJcbiAqIE5neHMgTW9kdWxlXHJcbiAqL1xyXG5ATmdNb2R1bGUoe30pXHJcbmV4cG9ydCBjbGFzcyBOZ3hzTW9kdWxlIHtcclxuICAvKipcclxuICAgKiBSb290IG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvclJvb3Qoc3RhdGVzOiBhbnlbXSA9IFtdLCBvcHRpb25zOiBNb2R1bGVPcHRpb25zID0ge30pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBOZ3hzUm9vdE1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU3RhdGVGYWN0b3J5LFxyXG4gICAgICAgIFN0YXRlQ29udGV4dEZhY3RvcnksXHJcbiAgICAgICAgQWN0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVyLFxyXG4gICAgICAgIEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICAgICAgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMsXHJcbiAgICAgICAgU3RvcmUsXHJcbiAgICAgICAgU3RhdGVTdHJlYW0sXHJcbiAgICAgICAgU2VsZWN0RmFjdG9yeSxcclxuICAgICAgICBQbHVnaW5NYW5hZ2VyLFxyXG4gICAgICAgIC4uLnN0YXRlcyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBST09UX1NUQVRFX1RPS0VOLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IHN0YXRlc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogUk9PVF9PUFRJT05TLFxyXG4gICAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IE5neHNDb25maWcsXHJcbiAgICAgICAgICB1c2VGYWN0b3J5OiBuZ3hzQ29uZmlnRmFjdG9yeSxcclxuICAgICAgICAgIGRlcHM6IFtST09UX09QVElPTlNdXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmVhdHVyZSBtb2R1bGUgZmFjdG9yeVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JGZWF0dXJlKHN0YXRlczogYW55W10pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBOZ3hzRmVhdHVyZU1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU3RhdGVGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IEZFQVRVUkVfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICAgIHVzZVZhbHVlOiBzdGF0ZXNcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGVuc3VyZVN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBBY3Rpb25PcHRpb25zIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGEgbWV0aG9kIHdpdGggYSBhY3Rpb24gaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQWN0aW9uKGFjdGlvbnM6IGFueSB8IGFueVtdLCBvcHRpb25zPzogQWN0aW9uT3B0aW9ucykge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgbmFtZTogc3RyaW5nLCBkZXNjcmlwdG9yOiBUeXBlZFByb3BlcnR5RGVzY3JpcHRvcjxhbnk+KSB7XHJcbiAgICBjb25zdCBtZXRhID0gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhY3Rpb25zKSkge1xyXG4gICAgICBhY3Rpb25zID0gW2FjdGlvbnNdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgYWN0aW9uIG9mIGFjdGlvbnMpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IGFjdGlvbi50eXBlO1xyXG5cclxuICAgICAgaWYgKCFhY3Rpb24udHlwZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uICR7YWN0aW9uLm5hbWV9IGlzIG1pc3NpbmcgYSBzdGF0aWMgXCJ0eXBlXCIgcHJvcGVydHlgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFtZXRhLmFjdGlvbnNbdHlwZV0pIHtcclxuICAgICAgICBtZXRhLmFjdGlvbnNbdHlwZV0gPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbWV0YS5hY3Rpb25zW3R5cGVdLnB1c2goe1xyXG4gICAgICAgIGZuOiBuYW1lLFxyXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXHJcbiAgICAgICAgdHlwZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGVuc3VyZVN0b3JlTWV0YWRhdGEgfSBmcm9tICcuLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBTdG9yZU9wdGlvbnMsIE1FVEFfS0VZIH0gZnJvbSAnLi4vc3ltYm9scyc7XHJcblxyXG5jb25zdCBzdGF0ZU5hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ15bYS16QS1aMC05X10rJCcpO1xyXG5cclxuLyoqXHJcbiAqIEVycm9yIG1lc3NhZ2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0YXRlTmFtZUVycm9yTWVzc2FnZSA9IG5hbWUgPT5cclxuICBgJHtuYW1lfSBpcyBub3QgYSB2YWxpZCBzdGF0ZSBuYW1lLiBJdCBuZWVkcyB0byBiZSBhIHZhbGlkIG9iamVjdCBwcm9wZXJ0eSBuYW1lLmA7XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGEgY2xhc3Mgd2l0aCBuZ3hzIHN0YXRlIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFN0YXRlPFQ+KG9wdGlvbnM6IFN0b3JlT3B0aW9uczxUPikge1xyXG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6IGFueSkge1xyXG4gICAgY29uc3QgbWV0YSA9IGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgaW5oZXJpdGFuY2VcclxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KS5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50TWV0YSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpW01FVEFfS0VZXTtcclxuXHJcbiAgICAgIG1ldGEuYWN0aW9ucyA9IHtcclxuICAgICAgICAuLi5tZXRhLmFjdGlvbnMsXHJcbiAgICAgICAgLi4ucGFyZW50TWV0YS5hY3Rpb25zXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbWV0YS5jaGlsZHJlbiA9IG9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICBtZXRhLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcclxuICAgIG1ldGEubmFtZSA9IG9wdGlvbnMubmFtZTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlcyBtdXN0IHJlZ2lzdGVyIGEgJ25hbWUnIHByb3BlcnR5YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzdGF0ZU5hbWVSZWdleC50ZXN0KG9wdGlvbnMubmFtZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0YXRlTmFtZUVycm9yTWVzc2FnZShvcHRpb25zLm5hbWUpKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAnLi4vdXRpbHMvc2VsZWN0b3ItdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIERlY29yYXRvciBmb3IgbWVtb2l6aW5nIGEgc3RhdGUgc2VsZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3JzPzogYW55W10pIHtcclxuICByZXR1cm4gKHRhcmdldDogYW55LCBrZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XHJcbiAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBvcmlnaW5hbEZuID0gZGVzY3JpcHRvci52YWx1ZTtcclxuXHJcbiAgICAgIGNvbnN0IG1lbW9pemVkRm4gPSBjcmVhdGVTZWxlY3RvcihcclxuICAgICAgICBzZWxlY3RvcnMsXHJcbiAgICAgICAgb3JpZ2luYWxGbixcclxuICAgICAgICB7IGNvbnRhaW5lckNsYXNzOiB0YXJnZXQsIHNlbGVjdG9yTmFtZToga2V5IH1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiBtZW1vaXplZEZuO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3JzIG9ubHkgd29yayBvbiBtZXRob2RzJyk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiSW5qZWN0aW9uVG9rZW4iLCJmaWx0ZXIiLCJtYXAiLCJPYnNlcnZhYmxlIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJTdWJqZWN0IiwiSW5qZWN0YWJsZSIsIk5nWm9uZSIsIkJlaGF2aW9yU3ViamVjdCIsIk9wdGlvbmFsIiwiU2tpcFNlbGYiLCJJbmplY3QiLCJmb3JrSm9pbiIsInNoYXJlUmVwbGF5IiwidGFrZSIsImV4aGF1c3RNYXAiLCJvZiIsInRocm93RXJyb3IiLCJlbXB0eSIsIkVycm9ySGFuZGxlciIsImlzRGV2TW9kZSIsInRzbGliXzEuX192YWx1ZXMiLCJtZXJnZU1hcCIsImRlZmF1bHRJZkVtcHR5IiwiY2F0Y2hFcnJvciIsImZyb20iLCJ0YWtlVW50aWwiLCJJbmplY3RvciIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwiTmdNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7OztJQWNBO0lBRUEsSUFBSSxhQUFhLEdBQUcsVUFBUyxDQUFDLEVBQUUsQ0FBQztRQUM3QixhQUFhLEdBQUcsTUFB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