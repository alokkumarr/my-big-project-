{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@ngxs/store/src/symbols.ts","ng://@ngxs/store/src/internal/internals.ts","ng://@ngxs/store/src/utils/utils.ts","ng://@ngxs/store/src/operators/of-action.ts","ng://@ngxs/store/src/operators/zone.ts","ng://@ngxs/store/src/actions-stream.ts","ng://@ngxs/store/src/utils/compose.ts","ng://@ngxs/store/src/internal/state-stream.ts","ng://@ngxs/store/src/plugin-manager.ts","ng://@ngxs/store/src/internal/dispatcher.ts","ng://@ngxs/store/src/utils/freeze.ts","ng://@ngxs/store/src/internal/state-operations.ts","ng://@ngxs/store/src/internal/state-context-factory.ts","ng://@ngxs/store/src/internal/state-factory.ts","ng://@ngxs/store/src/utils/memoize.ts","ng://@ngxs/store/src/utils/selector-utils.ts","ng://@ngxs/store/src/store.ts","ng://@ngxs/store/src/decorators/select.ts","ng://@ngxs/store/src/actions/actions.ts","ng://@ngxs/store/src/module.ts","ng://@ngxs/store/src/decorators/state.ts","ng://@ngxs/store/src/decorators/action.ts","ng://@ngxs/store/src/decorators/selector.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","__spread","concat","ROOT_STATE_TOKEN","InjectionToken","FEATURE_STATE_TOKEN","META_KEY","SELECTOR_META_KEY","NGXS_PLUGINS","NgxsConfig","compatibility","strictContentSecurityPolicy","ensureStoreMetadata","target","defineProperty","name","actions","defaults","path","selectFromAppState","children","instance","getStoreMetadata","ensureSelectorMetadata","originalFn","containerClass","selectorName","getSelectorMetadata","propGetter","paths","config","compliantPropGetter","copyOfPaths","obj","reduce","acc","part","fastPropGetter","segments","seg","l","expr","Function","getActionTypeFromInstance","action","type","setValue","prop","val","split","lastIndex","index","isArray","getValue","ofActionDispatched","allowedTypes","_i","ofActionOperator","status","allowedMap","createAllowedMap","types","klass","pipe","filterStatus","filter","ctx","actionType","mapAction","map","enterZone","zone","source","Observable","sink","subscribe","x","run","complete","OrderedSubject","_this","_super","_itemQueue","_busyPushingNext","tslib_1.__extends","unshift","nextValue","pop","Subject","InternalActions","Injectable","Actions","actions$","ngZone","observer","res","err","NgZone","compose","funcs","args","shift","nextArgs","StateStream","BehaviorSubject","PluginManager","_parentManager","_plugins","plugins","register","plugin","handle","bind","_a","decorators","Optional","SkipSelf","Inject","InternalDispatchedActionResults","InternalDispatcher","_errorHandler","_actions","_actionResults","_pluginManager","_stateStream","_ngZone","dispatch","event","result","runOutsideAngular","forkJoin","a","dispatchSingle","handleError","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","shareReplay","take","exhaustMap","of","throwError","empty","ErrorHandler","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","isFrozen","InternalStateOperations","_dispatcher","_config","verifyDevMode","getRootStateOperations","rootStateOperations","getState","setState","newState","developmentMode","ensureStateAndActionsAreImmutable","isNgxsDevMode","isNgDevMode","isDevMode","incorrectDevelopment","example","console","warn","root","frozenValue","StateContextFactory","_internalStateOperations","createStateContext","metadata","state","depth","patchState","isPrimitive","Error","local","clone","k","StateFactory","_injector","_parentFactory","_stateContextFactory","_states","_connected","states","add","oneOrManyStateClasses","stateClasses","stateGraph","buildGraph","findName","stateClass","meta","find","g","sortedStates","topologicalSort","graph","sorted","visited","visit","ancestors","dep","indexOf","join","slice","keys","reverse","depths","findFullParentPath","newObj","child","keyToFind","key","parent_1","parent_2","nameGraph","nameToState","mappedStores","name_1","this_1","isObject","undefined","get","sortedStates_1","tslib_1.__values","sortedStates_1_1","_b","addAndReturnDefaults","connectActionHandlers","mergeMap","invokeActions","defaultIfEmpty","catchError","invokeInit","stateMetadatas","stateMetadatas_1","stateMetadatas_1_1","ngxsOnInit","stateContext","results","_c","_d","actionMetas","actionMetas_1","actionMetas_1_1","actionMeta","fn","Promise","from","options","cancelUncompleted","takeUntil","Injector","defaultEqualityCheck","memoize","func","equalityCheck","lastArgs","lastResult","areArgumentsShallowlyEqual","prev","createSelector","selectors","creationMetadata","memoizedFn","returnValue","selectorMetaData","selectorsToApply","getSelectorFn","ex","TypeError","selector","Store","select","selectorFn","distinctUntilChanged","selectOnce","selectSnapshot","snapshot","reset","SelectFactory","store","InitState","UpdateState","NgxsRootModule","factory","internalStateOperations","stateOperations","cur","NgModule","NgxsFeatureModule","flattenedStates","ngxsConfigFactory","ROOT_OPTIONS","NgxsModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","forFeature","multi","stateNameRegex","RegExp","Action","descriptor","actions_1","actions_1_1","State","getPrototypeOf","parentMeta","test","Select","selectorOrFeature","selectorFnName","lastIndexOf","substring","writable","enumerable","configurable","ofAction","ofActionSuccessful","ofActionCanceled","ofActionErrored","Selector","memoizedFn_1","actionMatcher","action1","type1","action2"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\nexport const ROOT_STATE_TOKEN = new InjectionToken<any>('ROOT_STATE_TOKEN');\r\nexport const FEATURE_STATE_TOKEN = new InjectionToken<any>('FEATURE_STATE_TOKEN');\r\nexport const META_KEY = 'NGXS_META';\r\nexport const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\r\n\r\nexport const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\r\nexport type NgxsPluginConstructor = new (...args: any[]) => NgxsPlugin;\r\nexport type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\r\n\r\n/**\r\n * The NGXS config settings.\r\n */\r\nexport class NgxsConfig {\r\n  /**\r\n   * Run in development mode. This will add additional debugging features:\r\n   * - Object.freeze on the state and actions to guarantee immutability\r\n   * (default: false)\r\n   */\r\n  developmentMode: boolean;\r\n  compatibility: {\r\n    /**\r\n     * Support a strict Content Security Policy.\r\n     * This will cirumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.\r\n     * (default: false)\r\n     */\r\n    strictContentSecurityPolicy: boolean;\r\n  };\r\n\r\n  constructor() {\r\n    this.compatibility = {\r\n      strictContentSecurityPolicy: false\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * State context provided to the actions in the state.\r\n */\r\nexport interface StateContext<T> {\r\n  /**\r\n   * Get the current state.\r\n   */\r\n  getState(): T;\r\n\r\n  /**\r\n   * Reset the state to a new value.\r\n   */\r\n  setState(val: T);\r\n\r\n  /**\r\n   * Patch the existing state with the provided value.\r\n   */\r\n  patchState(val: Partial<T>);\r\n\r\n  /**\r\n   * Dispatch a new action and return the dispatched observable.\r\n   */\r\n  dispatch(actions: any | any[]): Observable<void>;\r\n}\r\n\r\nexport type NgxsNextPluginFn = (state: any, mutation: any) => any;\r\n\r\n/**\r\n * Plugin interface\r\n */\r\nexport interface NgxsPlugin {\r\n  /**\r\n   * Handle the state/action before its submitted to the state handlers.\r\n   */\r\n  handle(state: any, action: any, next: NgxsNextPluginFn): any;\r\n}\r\n\r\n/**\r\n * Options that can be provided to the store.\r\n */\r\nexport interface StoreOptions<T> {\r\n  /**\r\n   * Name of the state. Required.\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Default values for the state. If not provided, uses empty object.\r\n   */\r\n  defaults?: T;\r\n\r\n  /**\r\n   * Sub states for the given state.\r\n   */\r\n  children?: any[];\r\n}\r\n\r\n/**\r\n * Actions that can be provided in a action decorator.\r\n */\r\nexport interface ActionOptions {\r\n  /**\r\n   * Cancel the previous uncompleted observable(s).\r\n   */\r\n  cancelUncompleted?: boolean;\r\n}\r\n\r\n/**\r\n * On init interface\r\n */\r\nexport interface NgxsOnInit {\r\n  ngxsOnInit(ctx?: StateContext<any>): void | any;\r\n}\r\n\r\nexport type NgxsLifeCycle = Partial<NgxsOnInit>;\r\n","import { META_KEY, ActionOptions, SELECTOR_META_KEY, NgxsConfig } from '../symbols';\r\nimport { Observable } from 'rxjs';\r\n\r\nexport interface ObjectKeyMap<T> {\r\n  [key: string]: T;\r\n}\r\n\r\nexport interface StateClass {\r\n  [META_KEY]?: MetaDataModel;\r\n}\r\n\r\nexport type StateKeyGraph = ObjectKeyMap<string[]>;\r\n\r\nexport interface ActionHandlerMetaData {\r\n  fn: string;\r\n  options: ActionOptions;\r\n  type: string;\r\n}\r\n\r\nexport interface StateOperations<T> {\r\n  getState(): T;\r\n  setState(val: T);\r\n  dispatch(actions: any | any[]): Observable<void>;\r\n}\r\n\r\nexport interface MetaDataModel {\r\n  name: string;\r\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\r\n  defaults: any;\r\n  path: string;\r\n  selectFromAppState: SelectFromState;\r\n  children: StateClass[];\r\n  instance: any;\r\n}\r\n\r\nexport type SelectFromState = (state: any) => any;\r\n\r\nexport interface SelectorMetaDataModel {\r\n  selectFromAppState: SelectFromState;\r\n  originalFn: Function;\r\n  containerClass: any;\r\n  selectorName: string;\r\n}\r\n\r\nexport interface MappedStore {\r\n  name: string;\r\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\r\n  defaults: any;\r\n  instance: any;\r\n  depth: string;\r\n}\r\n\r\n/**\r\n * Ensures metadata is attached to the class and returns it.\r\n *\r\n * @ignore\r\n */\r\nexport function ensureStoreMetadata(target): MetaDataModel {\r\n  if (!target.hasOwnProperty(META_KEY)) {\r\n    const defaultMetadata: MetaDataModel = {\r\n      name: null,\r\n      actions: {},\r\n      defaults: {},\r\n      path: null,\r\n      selectFromAppState: null,\r\n      children: [],\r\n      instance: null\r\n    };\r\n\r\n    Object.defineProperty(target, META_KEY, { value: defaultMetadata });\r\n  }\r\n  return getStoreMetadata(target);\r\n}\r\n\r\n/**\r\n * Get the metadata attached to the class if it exists.\r\n *\r\n * @ignore\r\n */\r\nexport function getStoreMetadata(target): MetaDataModel {\r\n  return target[META_KEY];\r\n}\r\n\r\n/**\r\n * Ensures metadata is attached to the selector and returns it.\r\n *\r\n * @ignore\r\n */\r\nexport function ensureSelectorMetadata(target): SelectorMetaDataModel {\r\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\r\n    const defaultMetadata: SelectorMetaDataModel = {\r\n      selectFromAppState: null,\r\n      originalFn: null,\r\n      containerClass: null,\r\n      selectorName: null\r\n    };\r\n\r\n    Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\r\n  }\r\n\r\n  return getSelectorMetadata(target);\r\n}\r\n\r\n/**\r\n * Get the metadata attached to the selector if it exists.\r\n *\r\n * @ignore\r\n */\r\nexport function getSelectorMetadata(target): SelectorMetaDataModel {\r\n  return target[SELECTOR_META_KEY];\r\n}\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\r\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\r\n *\r\n * @ignore\r\n */\r\nfunction compliantPropGetter(paths: string[]): (x: any) => any {\r\n  const copyOfPaths = [...paths];\r\n  return obj => copyOfPaths.reduce((acc: any, part: string) => acc && acc[part], obj);\r\n}\r\n\r\n/**\r\n * The generated function is faster than:\r\n * - pluck (Observable operator)\r\n * - memoize\r\n *\r\n * @ignore\r\n */\r\nfunction fastPropGetter(paths: string[]): (x: any) => any {\r\n  const segments = paths;\r\n  let seg = 'store.' + segments[0];\r\n  let i = 0;\r\n  const l = segments.length;\r\n\r\n  let expr = seg;\r\n  while (++i < l) {\r\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\r\n  }\r\n\r\n  const fn = new Function('store', 'return ' + expr + ';');\r\n\r\n  return <(x: any) => any>fn;\r\n}\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * @ignore\r\n */\r\nexport function propGetter(paths: string[], config: NgxsConfig) {\r\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\r\n    return compliantPropGetter(paths);\r\n  } else {\r\n    return fastPropGetter(paths);\r\n  }\r\n}\r\n\r\n/**\r\n * Given an array of states, it will return a object graph. Example:\r\n *    const states = [\r\n *      Cart,\r\n *      CartSaved,\r\n *      CartSavedItems\r\n *    ]\r\n *\r\n * would return:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function buildGraph(stateClasses: StateClass[]): StateKeyGraph {\r\n  const findName = (stateClass: StateClass) => {\r\n    const meta = stateClasses.find(g => g === stateClass);\r\n    if (!meta) {\r\n      throw new Error(`Child state not found: ${stateClass}`);\r\n    }\r\n\r\n    if (!meta[META_KEY]) {\r\n      throw new Error('States must be decorated with @State() decorator');\r\n    }\r\n\r\n    return meta[META_KEY].name;\r\n  };\r\n\r\n  return stateClasses.reduce<StateKeyGraph>((result: StateKeyGraph, stateClass: StateClass) => {\r\n    if (!stateClass[META_KEY]) {\r\n      throw new Error('States must be decorated with @State() decorator');\r\n    }\r\n\r\n    const { name, children } = stateClass[META_KEY];\r\n    result[name] = (children || []).map(findName);\r\n    return result;\r\n  }, {});\r\n}\r\n\r\n/**\r\n * Given a states array, returns object graph\r\n * returning the name and state metadata. Example:\r\n *\r\n *  const graph = {\r\n *    cart: { metadata }\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function nameToState(states: StateClass[]): ObjectKeyMap<StateClass> {\r\n  return states.reduce<ObjectKeyMap<StateClass>>((result: ObjectKeyMap<StateClass>, stateClass: StateClass) => {\r\n    if (!stateClass[META_KEY]) {\r\n      throw new Error('States must be decorated with @State() decorator');\r\n    }\r\n\r\n    const meta = stateClass[META_KEY];\r\n    result[meta.name] = stateClass;\r\n    return result;\r\n  }, {});\r\n}\r\n\r\n/**\r\n * Given a object relationship graph will return the full path\r\n * for the child items. Example:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * would return:\r\n *\r\n *  const r = {\r\n *    cart: 'cart',\r\n *    saved: 'cart.saved',\r\n *    items: 'cart.saved.items'\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function findFullParentPath(obj: StateKeyGraph, newObj: ObjectKeyMap<string> = {}): ObjectKeyMap<string> {\r\n  const visit = (child: StateKeyGraph, keyToFind: string): string => {\r\n    for (const key in child) {\r\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\r\n        const parent = visit(child, key);\r\n        return parent !== null ? `${parent}.${key}` : key;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  for (const key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      const parent = visit(obj, key);\r\n      newObj[key] = parent ? `${parent}.${key}` : key;\r\n    }\r\n  }\r\n\r\n  return newObj;\r\n}\r\n\r\n/**\r\n * Given a object graph, it will return the items topologically sorted Example:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * would return:\r\n *\r\n *  const results = [\r\n *    'items',\r\n *    'saved',\r\n *    'cart'\r\n *  ];\r\n *\r\n * @ignore\r\n */\r\nexport function topologicalSort(graph: StateKeyGraph): string[] {\r\n  const sorted: string[] = [];\r\n  const visited: ObjectKeyMap<boolean> = {};\r\n\r\n  const visit = (name: string, ancestors: string[] = []) => {\r\n    if (!Array.isArray(ancestors)) {\r\n      ancestors = [];\r\n    }\r\n\r\n    ancestors.push(name);\r\n    visited[name] = true;\r\n\r\n    graph[name].forEach((dep: string) => {\r\n      if (ancestors.indexOf(dep) >= 0) {\r\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\r\n      }\r\n\r\n      if (visited[dep]) {\r\n        return;\r\n      }\r\n\r\n      visit(dep, ancestors.slice(0));\r\n    });\r\n\r\n    if (sorted.indexOf(name) < 0) {\r\n      sorted.push(name);\r\n    }\r\n  };\r\n\r\n  Object.keys(graph).forEach(k => visit(k));\r\n\r\n  return sorted.reverse();\r\n}\r\n\r\n/**\r\n * Returns if the parameter is a object or not.\r\n *\r\n * @ignore\r\n */\r\nexport function isObject(obj) {\r\n  return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\r\n}\r\n","/**\r\n * Returns the type from an action instance.\r\n * @ignore\r\n */\r\nexport function getActionTypeFromInstance(action: any): string {\r\n  if (action.constructor && action.constructor.type) {\r\n    return action.constructor.type;\r\n  }\r\n\r\n  return action.type;\r\n}\r\n\r\n/**\r\n * Matches a action\r\n * @ignore\r\n */\r\nexport function actionMatcher(action1: any) {\r\n  const type1 = getActionTypeFromInstance(action1);\r\n\r\n  return function(action2: any) {\r\n    return type1 === getActionTypeFromInstance(action2);\r\n  };\r\n}\r\n\r\n/**\r\n * Set a deeply nested value. Example:\r\n *\r\n *   setValue({ foo: { bar: { eat: false } } },\r\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\r\n *\r\n * While it traverses it also creates new objects from top down.\r\n *\r\n * @ignore\r\n */\r\nexport const setValue = (obj: any, prop: string, val: any) => {\r\n  obj = { ...obj };\r\n\r\n  const split = prop.split('.');\r\n  const lastIndex = split.length - 1;\r\n\r\n  split.reduce((acc, part, index) => {\r\n    if (index === lastIndex) {\r\n      acc[part] = val;\r\n    } else {\r\n      acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : { ...acc[part] };\r\n    }\r\n\r\n    return acc && acc[part];\r\n  }, obj);\r\n\r\n  return obj;\r\n};\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * @ignore\r\n */\r\nexport const getValue = (obj: any, prop: string) =>\r\n  prop.split('.').reduce((acc: any, part: string) => acc && acc[part], obj);\r\n","import { OperatorFunction, Observable } from 'rxjs';\r\nimport { map, filter } from 'rxjs/operators';\r\nimport { getActionTypeFromInstance } from '../utils/utils';\r\nimport { ActionContext, ActionStatus } from '../actions-stream';\r\n\r\nexport function ofAction<T>(allowedType): OperatorFunction<any, T>;\r\nexport function ofAction<T>(...allowedTypes): OperatorFunction<any, T>;\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will grab actions that have just been dispatched as well as actions that have completed\r\n */\r\nexport function ofAction(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been dispatched\r\n */\r\nexport function ofActionDispatched(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, ActionStatus.Dispatched);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been successfully completed\r\n */\r\nexport function ofActionSuccessful(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, ActionStatus.Successful);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been canceled\r\n */\r\nexport function ofActionCanceled(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, ActionStatus.Canceled);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just thrown an error\r\n */\r\nexport function ofActionErrored(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, ActionStatus.Errored);\r\n}\r\n\r\nfunction ofActionOperator(allowedTypes: any[], status?: ActionStatus) {\r\n  const allowedMap = createAllowedMap(allowedTypes);\r\n  return function(o: Observable<any>) {\r\n    return o.pipe(\r\n      filterStatus(allowedMap, status),\r\n      mapAction()\r\n    );\r\n  };\r\n}\r\n\r\nfunction filterStatus(allowedTypes: { [key: string]: boolean }, status?: ActionStatus) {\r\n  return filter((ctx: ActionContext) => {\r\n    const actionType = getActionTypeFromInstance(ctx.action);\r\n    const type = allowedTypes[actionType];\r\n    return status ? type && ctx.status === status : type;\r\n  });\r\n}\r\n\r\nfunction mapAction() {\r\n  return map((ctx: ActionContext) => ctx.action);\r\n}\r\n\r\nfunction createAllowedMap(types: any[]): { [key: string]: boolean } {\r\n  return types.reduce((acc: any, klass: any) => {\r\n    acc[getActionTypeFromInstance(klass)] = true;\r\n    return acc;\r\n  }, {});\r\n}\r\n","import { Observable, Observer } from 'rxjs';\r\nimport { NgZone } from '@angular/core';\r\n\r\n/**\r\n * Operator to run the `subscribe` in a Angular zone.\r\n */\r\nexport function enterZone<T>(zone: NgZone) {\r\n  return (source: Observable<T>) => {\r\n    return new Observable((sink: Observer<T>) => {\r\n      return source.subscribe({\r\n        next(x) {\r\n          zone.run(() => sink.next(x));\r\n        },\r\n        error(e) {\r\n          zone.run(() => sink.error(e));\r\n        },\r\n        complete() {\r\n          zone.run(() => sink.complete());\r\n        }\r\n      });\r\n    });\r\n  };\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\n\r\nimport { enterZone } from './operators/zone';\r\n\r\n/**\r\n * Status of a dispatched action\r\n */\r\nexport const enum ActionStatus {\r\n  Dispatched = 'DISPATCHED',\r\n  Successful = 'SUCCESSFUL',\r\n  Canceled = 'CANCELED',\r\n  Errored = 'ERRORED'\r\n}\r\n\r\nexport interface ActionContext {\r\n  status: ActionStatus;\r\n  action: any;\r\n  error?: Error;\r\n}\r\n\r\n/**\r\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\r\n * A standard Subject does not have this guarantee.\r\n * For example, given the following code:\r\n * ```typescript\r\n *   const subject = new Subject<string>();\r\n     subject.subscribe(value => {\r\n       if (value === 'start') subject.next('end');\r\n     });\r\n     subject.subscribe(value => { });\r\n     subject.next('start');\r\n * ```\r\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\r\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\r\n */\r\nexport class OrderedSubject<T> extends Subject<T> {\r\n  private _itemQueue: T[] = [];\r\n  private _busyPushingNext = false;\r\n\r\n  next(value?: T): void {\r\n    if (this._busyPushingNext) {\r\n      this._itemQueue.unshift(value);\r\n      return;\r\n    }\r\n    this._busyPushingNext = true;\r\n    super.next(value);\r\n    while (this._itemQueue.length > 0) {\r\n      const nextValue = this._itemQueue.pop();\r\n      super.next(nextValue);\r\n    }\r\n    this._busyPushingNext = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Internal Action stream that is emitted anytime an action is dispatched.\r\n */\r\n@Injectable()\r\nexport class InternalActions extends OrderedSubject<ActionContext> {}\r\n\r\n/**\r\n * Action stream that is emitted anytime an action is dispatched.\r\n *\r\n * You can listen to this in services to react without stores.\r\n */\r\n@Injectable()\r\nexport class Actions extends Observable<any> {\r\n  constructor(actions$: InternalActions, ngZone: NgZone) {\r\n    super(observer => {\r\n      actions$\r\n        .pipe(enterZone(ngZone))\r\n        .subscribe(res => observer.next(res), err => observer.error(err), () => observer.complete());\r\n    });\r\n  }\r\n}\r\n","/**\r\n * Composes a array of functions from left to right. Example:\r\n *\r\n *      compose([fn, final])(state, action);\r\n *\r\n * then the funcs have a signature like:\r\n *\r\n *      function fn (state, action, next) {\r\n *          console.log('here', state, action, next);\r\n *          return next(state, action);\r\n *      }\r\n *\r\n *      function final (state, action) {\r\n *          console.log('here', state, action);\r\n *          return state;\r\n *      }\r\n *\r\n * the last function should not call `next`.\r\n *\r\n * @ignore\r\n */\r\nexport const compose = funcs => (...args) => {\r\n  const curr = funcs.shift();\r\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\r\n};\r\n","import { Injectable } from '@angular/core';\r\nimport { BehaviorSubject } from 'rxjs';\r\n\r\n/**\r\n * BehaviorSubject of the entire state.\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateStream extends BehaviorSubject<any> {\r\n  constructor() {\r\n    super({});\r\n  }\r\n}\r\n","import { Injectable, Optional, SkipSelf, Inject } from '@angular/core';\r\nimport { NgxsPluginFn, NGXS_PLUGINS, NgxsPlugin } from './symbols';\r\n\r\n/**\r\n * Plugin manager class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class PluginManager {\r\n  plugins: NgxsPluginFn[] = [];\r\n\r\n  constructor(\r\n    @Optional()\r\n    @SkipSelf()\r\n    private _parentManager: PluginManager,\r\n    @Inject(NGXS_PLUGINS)\r\n    @Optional()\r\n    private _plugins: NgxsPlugin[]\r\n  ) {\r\n    this.register();\r\n  }\r\n\r\n  private register() {\r\n    if (!this._plugins) {\r\n      return;\r\n    }\r\n\r\n    this.plugins = this._plugins.map(plugin => {\r\n      if (plugin.handle) {\r\n        return plugin.handle.bind(plugin);\r\n      } else {\r\n        return plugin;\r\n      }\r\n    });\r\n\r\n    if (this._parentManager) {\r\n      this._parentManager.plugins.push(...this.plugins);\r\n    }\r\n  }\r\n}\r\n","import { Injectable, ErrorHandler, NgZone } from '@angular/core';\r\nimport { Observable, of, forkJoin, empty, Subject, throwError } from 'rxjs';\r\nimport { shareReplay, filter, exhaustMap, take } from 'rxjs/operators';\r\n\r\nimport { compose } from '../utils/compose';\r\nimport { InternalActions, ActionStatus, ActionContext } from '../actions-stream';\r\nimport { StateStream } from './state-stream';\r\nimport { PluginManager } from '../plugin-manager';\r\nimport { enterZone } from '../operators/zone';\r\n\r\n/**\r\n * Internal Action result stream that is emitted when an action is completed.\r\n * This is used as a method of returning the action result to the dispatcher\r\n * for the observable returned by the dispatch(...) call.\r\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\r\n */\r\n@Injectable()\r\nexport class InternalDispatchedActionResults extends Subject<ActionContext> {}\r\n\r\n@Injectable()\r\nexport class InternalDispatcher {\r\n  constructor(\r\n    private _errorHandler: ErrorHandler,\r\n    private _actions: InternalActions,\r\n    private _actionResults: InternalDispatchedActionResults,\r\n    private _pluginManager: PluginManager,\r\n    private _stateStream: StateStream,\r\n    private _ngZone: NgZone\r\n  ) {}\r\n\r\n  /**\r\n   * Dispatches event(s).\r\n   */\r\n  dispatch(event: any | any[]): Observable<any> {\r\n    const result: Observable<any> = this._ngZone.runOutsideAngular(() => {\r\n      if (Array.isArray(event)) {\r\n        return forkJoin(event.map(a => this.dispatchSingle(a)));\r\n      } else {\r\n        return this.dispatchSingle(event);\r\n      }\r\n    });\r\n\r\n    result.subscribe({\r\n      error: error => this._ngZone.run(() => this._errorHandler.handleError(error))\r\n    });\r\n\r\n    return result.pipe(enterZone(this._ngZone));\r\n  }\r\n\r\n  private dispatchSingle(action: any): Observable<any> {\r\n    const prevState = this._stateStream.getValue();\r\n    const plugins = this._pluginManager.plugins;\r\n\r\n    return (compose([\r\n      ...plugins,\r\n      (nextState, nextAction) => {\r\n        if (nextState !== prevState) {\r\n          this._stateStream.next(nextState);\r\n        }\r\n        const actionResult$ = this.getActionResultStream(nextAction);\r\n        actionResult$.subscribe(ctx => this._actions.next(ctx));\r\n        this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });\r\n        return this.createDispatchObservable(actionResult$);\r\n      }\r\n    ])(prevState, action) as Observable<any>).pipe(shareReplay());\r\n  }\r\n\r\n  private getActionResultStream(action: any): Observable<ActionContext> {\r\n    return this._actionResults.pipe(\r\n      filter((ctx: ActionContext) => ctx.action === action && ctx.status !== ActionStatus.Dispatched),\r\n      take(1),\r\n      shareReplay()\r\n    );\r\n  }\r\n\r\n  private createDispatchObservable(actionResult$: Observable<ActionContext>): Observable<any> {\r\n    return actionResult$\r\n      .pipe(\r\n        exhaustMap((ctx: ActionContext) => {\r\n          switch (ctx.status) {\r\n            case ActionStatus.Successful:\r\n              return of(this._stateStream.getValue());\r\n            case ActionStatus.Errored:\r\n              return throwError(ctx.error);\r\n            default:\r\n              return empty();\r\n          }\r\n        })\r\n      )\r\n      .pipe(shareReplay());\r\n  }\r\n}\r\n","/**\r\n * Object freeze code\r\n * https://github.com/jsdf/deep-freeze\r\n */\r\nexport const deepFreeze = o => {\r\n  Object.freeze(o);\r\n\r\n  const oIsFunction = typeof o === 'function';\r\n  const hasOwnProp = Object.prototype.hasOwnProperty;\r\n\r\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\r\n    if (\r\n      hasOwnProp.call(o, prop) &&\r\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\r\n      o[prop] !== null &&\r\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\r\n      !Object.isFrozen(o[prop])\r\n    ) {\r\n      deepFreeze(o[prop]);\r\n    }\r\n  });\r\n\r\n  return o;\r\n};\r\n","import { Injectable, isDevMode } from '@angular/core';\r\n\r\nimport { StateOperations } from '../internal/internals';\r\nimport { InternalDispatcher } from '../internal/dispatcher';\r\nimport { StateStream } from './state-stream';\r\nimport { NgxsConfig } from '../symbols';\r\nimport { deepFreeze } from '../utils/freeze';\r\n\r\n/**\r\n * State Context factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class InternalStateOperations {\r\n  constructor(private _stateStream: StateStream, private _dispatcher: InternalDispatcher, private _config: NgxsConfig) {\r\n    this.verifyDevMode();\r\n  }\r\n\r\n  /**\r\n   * Returns the root state operators.\r\n   */\r\n  getRootStateOperations(): StateOperations<any> {\r\n    const rootStateOperations = {\r\n      getState: () => this._stateStream.getValue(),\r\n      setState: newState => this._stateStream.next(newState),\r\n      dispatch: actions => this._dispatcher.dispatch(actions)\r\n    };\r\n\r\n    if (this._config.developmentMode) {\r\n      return this.ensureStateAndActionsAreImmutable(rootStateOperations);\r\n    }\r\n\r\n    return rootStateOperations;\r\n  }\r\n\r\n  private verifyDevMode() {\r\n    const isNgxsDevMode = this._config.developmentMode;\r\n    const isNgDevMode = isDevMode();\r\n    const incorrectProduction = !isNgDevMode && isNgxsDevMode;\r\n    const incorrectDevelopment = isNgDevMode && !isNgxsDevMode;\r\n    const example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';\r\n\r\n    if (incorrectProduction) {\r\n      console.warn(\r\n        'Angular is running in production mode but NGXS is still running in the development mode!\\n',\r\n        'Please set developmentMode to false on the NgxsModule options when in production mode.\\n',\r\n        example\r\n      );\r\n    } else if (incorrectDevelopment) {\r\n      console.warn(\r\n        'RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\\n',\r\n        example\r\n      );\r\n    }\r\n  }\r\n\r\n  private ensureStateAndActionsAreImmutable(root: StateOperations<any>): StateOperations<any> {\r\n    return {\r\n      getState: () => root.getState(),\r\n      setState: value => {\r\n        const frozenValue = deepFreeze(value);\r\n        return root.setState(frozenValue);\r\n      },\r\n      dispatch: actions => {\r\n        return root.dispatch(actions);\r\n      }\r\n    };\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { StateContext } from '../symbols';\r\nimport { MappedStore } from '../internal/internals';\r\nimport { setValue, getValue } from '../utils/utils';\r\nimport { InternalStateOperations } from '../internal/state-operations';\r\n\r\n/**\r\n * State Context factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateContextFactory {\r\n  constructor(private _internalStateOperations: InternalStateOperations) {}\r\n\r\n  /**\r\n   * Create the state context\r\n   */\r\n  createStateContext(metadata: MappedStore): StateContext<any> {\r\n    const root = this._internalStateOperations.getRootStateOperations();\r\n    return {\r\n      getState(): any {\r\n        const state = root.getState();\r\n        return getValue(state, metadata.depth);\r\n      },\r\n      patchState(val: any): any {\r\n        const isArray = Array.isArray(val);\r\n        const isPrimitive = typeof val !== 'object';\r\n\r\n        if (isArray) {\r\n          throw new Error('Patching arrays is not supported.');\r\n        } else if (isPrimitive) {\r\n          throw new Error('Patching primitives is not supported.');\r\n        }\r\n\r\n        const state = root.getState();\r\n        const local = getValue(state, metadata.depth);\r\n        const clone = { ...local };\r\n\r\n        for (const k in val) {\r\n          clone[k] = val[k];\r\n        }\r\n\r\n        const newState = setValue(state, metadata.depth, clone);\r\n        root.setState(newState);\r\n        return newState;\r\n      },\r\n      setState(val: any): any {\r\n        let state = root.getState();\r\n        state = setValue(state, metadata.depth, val);\r\n        root.setState(state);\r\n        return state;\r\n      },\r\n      dispatch(actions: any | any[]): Observable<any> {\r\n        return root.dispatch(actions);\r\n      }\r\n    };\r\n  }\r\n}\r\n","import { Injector, Injectable, SkipSelf, Optional } from '@angular/core';\r\nimport { Observable, of, forkJoin, from, throwError } from 'rxjs';\r\nimport { shareReplay, takeUntil, map, catchError, filter, mergeMap, defaultIfEmpty } from 'rxjs/operators';\r\n\r\nimport { META_KEY, NgxsLifeCycle, NgxsConfig } from '../symbols';\r\nimport {\r\n  topologicalSort,\r\n  buildGraph,\r\n  findFullParentPath,\r\n  nameToState,\r\n  propGetter,\r\n  isObject,\r\n  StateClass,\r\n  MappedStore\r\n} from './internals';\r\nimport { getActionTypeFromInstance, setValue } from '../utils/utils';\r\nimport { ofActionDispatched } from '../operators/of-action';\r\nimport { InternalActions, ActionStatus, ActionContext } from '../actions-stream';\r\nimport { InternalDispatchedActionResults } from '../internal/dispatcher';\r\nimport { StateContextFactory } from '../internal/state-context-factory';\r\n\r\n/**\r\n * State factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateFactory {\r\n  get states(): MappedStore[] {\r\n    return this._parentFactory ? this._parentFactory.states : this._states;\r\n  }\r\n\r\n  private _states: MappedStore[] = [];\r\n  private _connected = false;\r\n\r\n  constructor(\r\n    private _injector: Injector,\r\n    private _config: NgxsConfig,\r\n    @Optional()\r\n    @SkipSelf()\r\n    private _parentFactory: StateFactory,\r\n    private _actions: InternalActions,\r\n    private _actionResults: InternalDispatchedActionResults,\r\n    private _stateContextFactory: StateContextFactory\r\n  ) {}\r\n\r\n  /**\r\n   * Add a new state to the global defs.\r\n   */\r\n  add(oneOrManyStateClasses: StateClass | StateClass[]): MappedStore[] {\r\n    let stateClasses: StateClass[];\r\n    if (!Array.isArray(oneOrManyStateClasses)) {\r\n      stateClasses = [oneOrManyStateClasses];\r\n    } else {\r\n      stateClasses = oneOrManyStateClasses;\r\n    }\r\n\r\n    const stateGraph = buildGraph(stateClasses);\r\n    const sortedStates = topologicalSort(stateGraph);\r\n    const depths = findFullParentPath(stateGraph);\r\n    const nameGraph = nameToState(stateClasses);\r\n    const mappedStores: MappedStore[] = [];\r\n\r\n    for (const name of sortedStates) {\r\n      const stateClass = nameGraph[name];\r\n\r\n      if (!stateClass[META_KEY]) {\r\n        throw new Error('States must be decorated with @State() decorator');\r\n      }\r\n\r\n      const depth = depths[name];\r\n      const { actions } = stateClass[META_KEY];\r\n      let { defaults } = stateClass[META_KEY];\r\n\r\n      stateClass[META_KEY].path = depth;\r\n      stateClass[META_KEY].selectFromAppState = propGetter(depth.split('.'), this._config);\r\n\r\n      // ensure our store hasn't already been added\r\n      // but dont throw since it could be lazy\r\n      // loaded from different paths\r\n      const has = this.states.find(s => s.name === name);\r\n      if (!has) {\r\n        // create new instance of defaults\r\n        if (Array.isArray(defaults)) {\r\n          defaults = [...defaults];\r\n        } else if (isObject(defaults)) {\r\n          defaults = { ...defaults };\r\n        } else if (defaults === undefined) {\r\n          defaults = {};\r\n        }\r\n\r\n        const instance = this._injector.get(stateClass);\r\n\r\n        mappedStores.push({\r\n          actions,\r\n          instance,\r\n          defaults,\r\n          name,\r\n          depth\r\n        });\r\n      }\r\n    }\r\n\r\n    this.states.push(...mappedStores);\r\n\r\n    return mappedStores;\r\n  }\r\n\r\n  /**\r\n   * Add a set of states to the store and return the defaulsts\r\n   */\r\n  addAndReturnDefaults(stateClasses: any[]): { defaults: any; states: MappedStore[] } {\r\n    if (stateClasses) {\r\n      const states = this.add(stateClasses);\r\n      const defaults = states.reduce(\r\n        (result: any, meta: MappedStore) => setValue(result, meta.depth, meta.defaults),\r\n        {}\r\n      );\r\n      return { defaults, states };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind the actions to the handlers\r\n   */\r\n  connectActionHandlers() {\r\n    if (this._connected) return;\r\n    this._actions\r\n      .pipe(\r\n        filter((ctx: ActionContext) => ctx.status === ActionStatus.Dispatched),\r\n        mergeMap(({ action }) =>\r\n          this.invokeActions(this._actions, action).pipe(\r\n            map(() => <ActionContext>{ action, status: ActionStatus.Successful }),\r\n            defaultIfEmpty(<ActionContext>{ action, status: ActionStatus.Canceled }),\r\n            catchError(error => of(<ActionContext>{ action, status: ActionStatus.Errored, error }))\r\n          )\r\n        )\r\n      )\r\n      .subscribe(ctx => this._actionResults.next(ctx));\r\n    this._connected = true;\r\n  }\r\n\r\n  /**\r\n   * Invoke the init function on the states.\r\n   */\r\n  invokeInit(stateMetadatas: MappedStore[]) {\r\n    for (const metadata of stateMetadatas) {\r\n      const instance: NgxsLifeCycle = metadata.instance;\r\n\r\n      if (instance.ngxsOnInit) {\r\n        const stateContext = this.createStateContext(metadata);\r\n        instance.ngxsOnInit(stateContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invoke actions on the states.\r\n   */\r\n  invokeActions(actions$: InternalActions, action) {\r\n    const results = [];\r\n\r\n    for (const metadata of this.states) {\r\n      const type = getActionTypeFromInstance(action);\r\n      const actionMetas = metadata.actions[type];\r\n\r\n      if (actionMetas) {\r\n        for (const actionMeta of actionMetas) {\r\n          const stateContext = this.createStateContext(metadata);\r\n          try {\r\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\r\n\r\n            if (result instanceof Promise) {\r\n              result = from(result);\r\n            }\r\n\r\n            if (result instanceof Observable) {\r\n              result = result.pipe(\r\n                actionMeta.options.cancelUncompleted\r\n                  ? takeUntil(actions$.pipe(ofActionDispatched(action)))\r\n                  : map(r => r)\r\n              ); // map acts like a noop\r\n            } else {\r\n              result = of({}).pipe(shareReplay());\r\n            }\r\n\r\n            results.push(result);\r\n          } catch (e) {\r\n            results.push(throwError(e));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!results.length) {\r\n      results.push(of({}));\r\n    }\r\n\r\n    return forkJoin(results);\r\n  }\r\n\r\n  /**\r\n   * Create the state context\r\n   */\r\n  private createStateContext(metadata: MappedStore) {\r\n    return this._stateContextFactory.createStateContext(metadata);\r\n  }\r\n}\r\n","function defaultEqualityCheck(a, b) {\r\n  return a === b;\r\n}\r\n\r\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\r\n  if (prev === null || next === null || prev.length !== next.length) {\r\n    return false;\r\n  }\r\n\r\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n  const length = prev.length;\r\n  for (let i = 0; i < length; i++) {\r\n    if (!equalityCheck(prev[i], next[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Memoize a function on its last inputs only.\r\n * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n */\r\nexport function memoize(func, equalityCheck = defaultEqualityCheck) {\r\n  let lastArgs = null;\r\n  let lastResult = null;\r\n  // we reference arguments instead of spreading them for performance reasons\r\n  return <(...args) => any>function memoized() {\r\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\r\n      // apply arguments instead of spreading for performance.\r\n      lastResult = func.apply(null, arguments);\r\n    }\r\n\r\n    lastArgs = arguments;\r\n    return lastResult;\r\n  };\r\n}\r\n","import { SelectFromState, ensureSelectorMetadata, getSelectorMetadata, getStoreMetadata } from '../internal/internals';\r\nimport { memoize } from '../utils/memoize';\r\n\r\n/**\r\n * Function for creating a selector\r\n * @param selectors The selectors to use to create the arguments of this function\r\n * @param originalFn The original function being made into a selector\r\n */\r\nexport function createSelector(\r\n  selectors: any[],\r\n  originalFn: any,\r\n  creationMetadata?: { containerClass: any; selectorName: string }\r\n) {\r\n  const wrappedFn = function wrappedSelectorFn(...args) {\r\n    const returnValue = originalFn(...args);\r\n    if (returnValue instanceof Function) {\r\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\r\n      return innerMemoizedFn;\r\n    }\r\n    return returnValue;\r\n  };\r\n  const memoizedFn = memoize(wrappedFn);\r\n  const containerClass = creationMetadata && creationMetadata.containerClass;\r\n\r\n  const fn = state => {\r\n    const results = [];\r\n\r\n    const selectorsToApply = [];\r\n\r\n    if (containerClass) {\r\n      // If we are on a state class, add it as the first selector parameter\r\n      const metadata = getStoreMetadata(containerClass);\r\n      if (metadata) {\r\n        selectorsToApply.push(containerClass);\r\n      }\r\n    }\r\n    if (selectors) {\r\n      selectorsToApply.push(...selectors);\r\n    }\r\n    // Determine arguments from the app state using the selectors\r\n    if (selectorsToApply) {\r\n      results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));\r\n    }\r\n\r\n    // if the lambda tries to access a something on the\r\n    // state that doesn't exist, it will throw a TypeError.\r\n    // since this is quite usual behaviour, we simply return undefined if so.\r\n    try {\r\n      return memoizedFn(...results);\r\n    } catch (ex) {\r\n      if (ex instanceof TypeError) {\r\n        return undefined;\r\n      }\r\n      throw ex;\r\n    }\r\n  };\r\n\r\n  const selectorMetaData = ensureSelectorMetadata(memoizedFn);\r\n  selectorMetaData.originalFn = originalFn;\r\n  selectorMetaData.selectFromAppState = fn;\r\n  if (creationMetadata) {\r\n    selectorMetaData.containerClass = creationMetadata.containerClass;\r\n    selectorMetaData.selectorName = creationMetadata.selectorName;\r\n  }\r\n  return memoizedFn;\r\n}\r\n\r\n/**\r\n * This function gets the selector function to be used to get the selected slice from the app state\r\n * @ignore\r\n */\r\nexport function getSelectorFn(selector: any): SelectFromState {\r\n  const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);\r\n  return (metadata && metadata.selectFromAppState) || selector;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, of, Subscription } from 'rxjs';\r\nimport { catchError, distinctUntilChanged, map, take } from 'rxjs/operators';\r\n\r\nimport { getSelectorFn } from './utils/selector-utils';\r\nimport { InternalStateOperations } from './internal/state-operations';\r\nimport { StateStream } from './internal/state-stream';\r\nimport { enterZone } from './operators/zone';\r\n\r\n@Injectable()\r\nexport class Store {\r\n  constructor(\r\n    private _ngZone: NgZone,\r\n    private _stateStream: StateStream,\r\n    private _internalStateOperations: InternalStateOperations\r\n  ) {}\r\n\r\n  /**\r\n   * Dispatches event(s).\r\n   */\r\n  dispatch(event: any | any[]): Observable<any> {\r\n    return this._internalStateOperations.getRootStateOperations().dispatch(event);\r\n  }\r\n\r\n  /**\r\n   * Selects a slice of data from the store.\r\n   */\r\n  select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\r\n  select(selector: string | any): Observable<any>;\r\n  select(selector: any): Observable<any> {\r\n    const selectorFn = getSelectorFn(selector);\r\n    return this._stateStream.pipe(\r\n      map(selectorFn),\r\n      catchError(err => {\r\n        // if error is TypeError we swallow it to prevent usual errors with property access\r\n        if (err instanceof TypeError) {\r\n          return of(undefined);\r\n        }\r\n\r\n        // rethrow other errors\r\n        throw err;\r\n      }),\r\n      distinctUntilChanged(),\r\n      enterZone(this._ngZone)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Select one slice of data from the store.\r\n   */\r\n  selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\r\n  selectOnce(selector: string | any): Observable<any>;\r\n  selectOnce(selector: any): Observable<any> {\r\n    return this.select(selector).pipe(take(1));\r\n  }\r\n\r\n  /**\r\n   * Select a snapshot from the state.\r\n   */\r\n  selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;\r\n  selectSnapshot(selector: string | any): any;\r\n  selectSnapshot(selector: any): any {\r\n    const selectorFn = getSelectorFn(selector);\r\n    return selectorFn(this._stateStream.getValue());\r\n  }\r\n\r\n  /**\r\n   * Allow the user to subscribe to the root of the state\r\n   */\r\n  subscribe(fn?: any): Subscription {\r\n    return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);\r\n  }\r\n\r\n  /**\r\n   * Return the raw value of the state.\r\n   */\r\n  snapshot(): any {\r\n    return this._internalStateOperations.getRootStateOperations().getState();\r\n  }\r\n\r\n  /**\r\n   * Reset the state to a specific point in time. This method is useful\r\n   * for plugin's who need to modify the state directly or unit testing.\r\n   */\r\n  reset(state: any) {\r\n    return this._internalStateOperations.getRootStateOperations().setState(state);\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { Store } from '../store';\r\nimport { propGetter } from '../internal/internals';\r\nimport { META_KEY, NgxsConfig } from '../symbols';\r\n\r\n/**\r\n * Allows the select decorator to get access to the DI store.\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class SelectFactory {\r\n  static store: Store | undefined = undefined;\r\n  static config: NgxsConfig | undefined = undefined;\r\n  constructor(store: Store, config: NgxsConfig) {\r\n    SelectFactory.store = store;\r\n    SelectFactory.config = config;\r\n  }\r\n}\r\n\r\n/**\r\n * Decorator for selecting a slice of state from the store.\r\n */\r\nexport function Select(selectorOrFeature?, ...paths: string[]) {\r\n  return function(target: any, name: string) {\r\n    const selectorFnName = '__' + name + '__selector';\r\n\r\n    if (!selectorOrFeature) {\r\n      // if foo$ => make it just foo\r\n      selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;\r\n    }\r\n\r\n    const createSelect = fn => {\r\n      const store = SelectFactory.store;\r\n\r\n      if (!store) {\r\n        throw new Error('SelectFactory not connected to store!');\r\n      }\r\n\r\n      return store.select(fn);\r\n    };\r\n\r\n    const createSelector = () => {\r\n      const config = SelectFactory.config;\r\n      if (typeof selectorOrFeature === 'string') {\r\n        const propsArray = paths.length ? [selectorOrFeature, ...paths] : selectorOrFeature.split('.');\r\n\r\n        return propGetter(propsArray, config);\r\n      } else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {\r\n        return propGetter(selectorOrFeature[META_KEY].path.split('.'), config);\r\n      } else {\r\n        return selectorOrFeature;\r\n      }\r\n    };\r\n\r\n    if (target[selectorFnName]) {\r\n      throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');\r\n    }\r\n\r\n    if (delete target[name]) {\r\n      Object.defineProperty(target, selectorFnName, {\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n\r\n      Object.defineProperty(target, name, {\r\n        get: function() {\r\n          return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Init action\r\n */\r\nexport class InitState {\r\n  static get type() {\r\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\r\n    return '@@INIT';\r\n  }\r\n}\r\n\r\n/**\r\n * Update action\r\n */\r\nexport class UpdateState {\r\n  static get type() {\r\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\r\n    return '@@UPDATE_STATE';\r\n  }\r\n}\r\n","import { NgModule, ModuleWithProviders, Optional, Inject, InjectionToken } from '@angular/core';\r\n\r\nimport { ROOT_STATE_TOKEN, FEATURE_STATE_TOKEN, NgxsConfig } from './symbols';\r\nimport { StateFactory } from './internal/state-factory';\r\nimport { StateContextFactory } from './internal/state-context-factory';\r\nimport { Actions, InternalActions } from './actions-stream';\r\nimport { InternalDispatcher, InternalDispatchedActionResults } from './internal/dispatcher';\r\nimport { InternalStateOperations } from './internal/state-operations';\r\nimport { Store } from './store';\r\nimport { SelectFactory } from './decorators/select';\r\nimport { StateStream } from './internal/state-stream';\r\nimport { PluginManager } from './plugin-manager';\r\nimport { InitState, UpdateState } from './actions/actions';\r\n\r\n/**\r\n * Root module\r\n * @ignore\r\n */\r\n@NgModule()\r\nexport class NgxsRootModule {\r\n  constructor(\r\n    factory: StateFactory,\r\n    internalStateOperations: InternalStateOperations,\r\n    store: Store,\r\n    select: SelectFactory,\r\n    @Optional()\r\n    @Inject(ROOT_STATE_TOKEN)\r\n    states: any[]\r\n  ) {\r\n    // add stores to the state graph and return their defaults\r\n    const results = factory.addAndReturnDefaults(states);\r\n\r\n    const stateOperations = internalStateOperations.getRootStateOperations();\r\n    if (results) {\r\n      // get our current stream\r\n      const cur = stateOperations.getState();\r\n\r\n      // set the state to the current + new\r\n      stateOperations.setState({ ...cur, ...results.defaults });\r\n    }\r\n\r\n    // connect our actions stream\r\n    factory.connectActionHandlers();\r\n\r\n    // dispatch the init action and invoke init function after\r\n    stateOperations.dispatch(new InitState()).subscribe(() => {\r\n      if (results) {\r\n        factory.invokeInit(results.states);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Feature module\r\n * @ignore\r\n */\r\n@NgModule({})\r\nexport class NgxsFeatureModule {\r\n  constructor(\r\n    store: Store,\r\n    internalStateOperations: InternalStateOperations,\r\n    factory: StateFactory,\r\n    @Optional()\r\n    @Inject(FEATURE_STATE_TOKEN)\r\n    states: any[][]\r\n  ) {\r\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\r\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\r\n    const flattenedStates = ([] as any[]).concat(...states);\r\n\r\n    // add stores to the state graph and return their defaults\r\n    const results = factory.addAndReturnDefaults(flattenedStates);\r\n\r\n    const stateOperations = internalStateOperations.getRootStateOperations();\r\n    if (results) {\r\n      // get our current stream\r\n      const cur = stateOperations.getState();\r\n\r\n      // set the state to the current + new\r\n      stateOperations.setState({ ...cur, ...results.defaults });\r\n    }\r\n\r\n    stateOperations.dispatch(new UpdateState()).subscribe(() => {\r\n      if (results) {\r\n        factory.invokeInit(results.states);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport type ModuleOptions = Partial<NgxsConfig>;\r\n\r\nexport function ngxsConfigFactory(options: ModuleOptions): NgxsConfig {\r\n  const config = Object.assign(new NgxsConfig(), options);\r\n  return config;\r\n}\r\n\r\nexport const ROOT_OPTIONS = new InjectionToken<ModuleOptions>('ROOT_OPTIONS');\r\n\r\n/**\r\n * Ngxs Module\r\n */\r\n@NgModule({})\r\nexport class NgxsModule {\r\n  /**\r\n   * Root module factory\r\n   */\r\n  static forRoot(states: any[] = [], options: ModuleOptions = {}): ModuleWithProviders {\r\n    return {\r\n      ngModule: NgxsRootModule,\r\n      providers: [\r\n        StateFactory,\r\n        StateContextFactory,\r\n        Actions,\r\n        InternalActions,\r\n        InternalDispatcher,\r\n        InternalDispatchedActionResults,\r\n        InternalStateOperations,\r\n        Store,\r\n        StateStream,\r\n        SelectFactory,\r\n        PluginManager,\r\n        ...states,\r\n        {\r\n          provide: ROOT_STATE_TOKEN,\r\n          useValue: states\r\n        },\r\n        {\r\n          provide: ROOT_OPTIONS,\r\n          useValue: options\r\n        },\r\n        {\r\n          provide: NgxsConfig,\r\n          useFactory: ngxsConfigFactory,\r\n          deps: [ROOT_OPTIONS]\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Feature module factory\r\n   */\r\n  static forFeature(states: any[]): ModuleWithProviders {\r\n    return {\r\n      ngModule: NgxsFeatureModule,\r\n      providers: [\r\n        StateFactory,\r\n        PluginManager,\r\n        ...states,\r\n        {\r\n          provide: FEATURE_STATE_TOKEN,\r\n          multi: true,\r\n          useValue: states\r\n        }\r\n      ]\r\n    };\r\n  }\r\n}\r\n","import { ensureStoreMetadata } from '../internal/internals';\r\nimport { StoreOptions, META_KEY } from '../symbols';\r\n\r\nconst stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\r\n\r\n/**\r\n * Error message\r\n * @ignore\r\n */\r\nexport const stateNameErrorMessage = name =>\r\n  `${name} is not a valid state name. It needs to be a valid object property name.`;\r\n\r\n/**\r\n * Decorates a class with ngxs state information.\r\n */\r\nexport function State<T>(options: StoreOptions<T>) {\r\n  return function(target: any) {\r\n    const meta = ensureStoreMetadata(target);\r\n\r\n    // Handle inheritance\r\n    if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {\r\n      const parentMeta = Object.getPrototypeOf(target)[META_KEY];\r\n\r\n      meta.actions = {\r\n        ...meta.actions,\r\n        ...parentMeta.actions\r\n      };\r\n    }\r\n\r\n    meta.children = options.children;\r\n    meta.defaults = options.defaults;\r\n    meta.name = options.name;\r\n\r\n    if (!options.name) {\r\n      throw new Error(`States must register a 'name' property`);\r\n    }\r\n\r\n    if (!stateNameRegex.test(options.name)) {\r\n      throw new Error(stateNameErrorMessage(options.name));\r\n    }\r\n  };\r\n}\r\n","import { ensureStoreMetadata } from '../internal/internals';\r\nimport { ActionOptions } from '../symbols';\r\n\r\n/**\r\n * Decorates a method with a action information.\r\n */\r\nexport function Action(actions: any | any[], options?: ActionOptions) {\r\n  return function(target: any, name: string, descriptor: TypedPropertyDescriptor<any>) {\r\n    const meta = ensureStoreMetadata(target.constructor);\r\n\r\n    if (!Array.isArray(actions)) {\r\n      actions = [actions];\r\n    }\r\n\r\n    for (const action of actions) {\r\n      const type = action.type;\r\n\r\n      if (!action.type) {\r\n        throw new Error(`Action ${action.name} is missing a static \"type\" property`);\r\n      }\r\n\r\n      if (!meta.actions[type]) {\r\n        meta.actions[type] = [];\r\n      }\r\n\r\n      meta.actions[type].push({\r\n        fn: name,\r\n        options: options || {},\r\n        type\r\n      });\r\n    }\r\n  };\r\n}\r\n","import { createSelector } from '../utils/selector-utils';\r\n\r\n/**\r\n * Decorator for memoizing a state selector.\r\n */\r\nexport function Selector(selectors?: any[]) {\r\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\r\n    if (descriptor.value !== null) {\r\n      const originalFn = descriptor.value;\r\n\r\n      const memoizedFn = createSelector(\r\n        selectors,\r\n        originalFn,\r\n        { containerClass: target, selectorName: key }\r\n      );\r\n\r\n      return {\r\n        configurable: true,\r\n        get() {\r\n          return memoizedFn;\r\n        }\r\n      };\r\n    } else {\r\n      throw new Error('Selectors only work on methods');\r\n    }\r\n  };\r\n}\r\n"]}