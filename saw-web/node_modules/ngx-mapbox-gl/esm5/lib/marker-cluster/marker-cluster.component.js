/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, EventEmitter, Input, NgZone, Output, TemplateRef } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { startWith } from 'rxjs/operators';
import supercluster from 'supercluster';
import { MapService } from '../map/map.service';
var PointDirective = /** @class */ (function () {
    function PointDirective() {
    }
    PointDirective.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[mglPoint]' },] }
    ];
    return PointDirective;
}());
export { PointDirective };
var ClusterPointDirective = /** @class */ (function () {
    function ClusterPointDirective() {
    }
    ClusterPointDirective.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[mglClusterPoint]' },] }
    ];
    return ClusterPointDirective;
}());
export { ClusterPointDirective };
var MarkerClusterComponent = /** @class */ (function () {
    function MarkerClusterComponent(MapService, ChangeDetectorRef, zone) {
        var _this = this;
        this.MapService = MapService;
        this.ChangeDetectorRef = ChangeDetectorRef;
        this.zone = zone;
        this.load = new EventEmitter();
        this.sub = new Subscription();
        this.getLeavesFn = function (feature) {
            return function (limit, offset) { return ((/** @type {?} */ (_this.supercluster.getLeaves)))((/** @type {?} */ (feature.properties.cluster_id)), limit, offset); };
        };
        this.getChildrenFn = function (feature) {
            return function () { return ((/** @type {?} */ (_this.supercluster.getChildren)))((/** @type {?} */ (feature.properties.cluster_id))); };
        };
        this.getClusterExpansionZoomFn = function (feature) {
            return function () { return ((/** @type {?} */ (_this.supercluster.getClusterExpansionZoom)))((/** @type {?} */ (feature.properties.cluster_id))); };
        };
    }
    /**
     * @return {?}
     */
    MarkerClusterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var options = {
            radius: this.radius,
            maxZoom: this.maxZoom,
            minZoom: this.minZoom,
            extent: this.extent,
            nodeSize: this.nodeSize,
            log: this.log,
            reduce: this.reduce,
            initial: this.initial,
            map: this.map
        };
        Object.keys(options)
            .forEach(function (key) {
            /** @type {?} */
            var tkey = (/** @type {?} */ (key));
            if (options[tkey] === undefined) {
                delete options[tkey];
            }
        });
        this.supercluster = supercluster(options);
        this.supercluster.load(this.data.features);
        this.load.emit(this.supercluster);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MarkerClusterComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.data && !changes.data.isFirstChange()) {
            this.supercluster.load(this.data.features);
        }
    };
    /**
     * @return {?}
     */
    MarkerClusterComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.MapService.mapCreated$.subscribe(function () {
            /** @type {?} */
            var mapMove$ = merge(fromEvent((/** @type {?} */ (_this.MapService.mapInstance)), 'zoomChange'), fromEvent((/** @type {?} */ (_this.MapService.mapInstance)), 'move'));
            /** @type {?} */
            var sub = mapMove$.pipe(startWith(undefined)).subscribe(function () {
                _this.zone.run(function () {
                    _this.updateCluster();
                });
            });
            _this.sub.add(sub);
        });
    };
    /**
     * @return {?}
     */
    MarkerClusterComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.sub.unsubscribe();
    };
    /**
     * @return {?}
     */
    MarkerClusterComponent.prototype.updateCluster = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var bbox = this.MapService.getCurrentViewportBbox();
        /** @type {?} */
        var currentZoom = Math.round(this.MapService.mapInstance.getZoom());
        this.clusterPoints = this.supercluster.getClusters(bbox, currentZoom);
        this.ChangeDetectorRef.markForCheck();
    };
    MarkerClusterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mgl-marker-cluster',
                    template: "\n    <ng-container *ngFor=\"let feature of clusterPoints\">\n      <ng-container *ngIf=\"feature.properties.cluster; else point\">\n        <mgl-marker\n          [feature]=\"feature\"\n        >\n          <ng-container *ngTemplateOutlet=\"clusterPointTpl; context: {\n            $implicit: feature,\n            getLeavesFn: getLeavesFn(feature),\n            getChildrenFn: getChildrenFn(feature),\n            getClusterExpansionZoomFn: getClusterExpansionZoomFn(feature)\n          }\"></ng-container>\n        </mgl-marker>\n      </ng-container>\n      <ng-template #point>\n        <mgl-marker\n          [feature]=\"feature\"\n        >\n          <ng-container *ngTemplateOutlet=\"pointTpl; context: { $implicit: feature }\"></ng-container>\n        </mgl-marker>\n      </ng-template>\n    </ng-container>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                }] }
    ];
    MarkerClusterComponent.ctorParameters = function () { return [
        { type: MapService },
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    MarkerClusterComponent.propDecorators = {
        radius: [{ type: Input }],
        maxZoom: [{ type: Input }],
        minZoom: [{ type: Input }],
        extent: [{ type: Input }],
        nodeSize: [{ type: Input }],
        log: [{ type: Input }],
        reduce: [{ type: Input }],
        initial: [{ type: Input }],
        map: [{ type: Input }],
        data: [{ type: Input }],
        load: [{ type: Output }],
        pointTpl: [{ type: ContentChild, args: [PointDirective, { read: TemplateRef },] }],
        clusterPointTpl: [{ type: ContentChild, args: [ClusterPointDirective, { read: TemplateRef },] }]
    };
    return MarkerClusterComponent;
}());
export { MarkerClusterComponent };
if (false) {
    /** @type {?} */
    MarkerClusterComponent.prototype.radius;
    /** @type {?} */
    MarkerClusterComponent.prototype.maxZoom;
    /** @type {?} */
    MarkerClusterComponent.prototype.minZoom;
    /** @type {?} */
    MarkerClusterComponent.prototype.extent;
    /** @type {?} */
    MarkerClusterComponent.prototype.nodeSize;
    /** @type {?} */
    MarkerClusterComponent.prototype.log;
    /** @type {?} */
    MarkerClusterComponent.prototype.reduce;
    /** @type {?} */
    MarkerClusterComponent.prototype.initial;
    /** @type {?} */
    MarkerClusterComponent.prototype.map;
    /** @type {?} */
    MarkerClusterComponent.prototype.data;
    /** @type {?} */
    MarkerClusterComponent.prototype.load;
    /** @type {?} */
    MarkerClusterComponent.prototype.pointTpl;
    /** @type {?} */
    MarkerClusterComponent.prototype.clusterPointTpl;
    /** @type {?} */
    MarkerClusterComponent.prototype.clusterPoints;
    /** @type {?} */
    MarkerClusterComponent.prototype.supercluster;
    /** @type {?} */
    MarkerClusterComponent.prototype.sub;
    /** @type {?} */
    MarkerClusterComponent.prototype.getLeavesFn;
    /** @type {?} */
    MarkerClusterComponent.prototype.getChildrenFn;
    /** @type {?} */
    MarkerClusterComponent.prototype.getClusterExpansionZoomFn;
    /** @type {?} */
    MarkerClusterComponent.prototype.MapService;
    /** @type {?} */
    MarkerClusterComponent.prototype.ChangeDetectorRef;
    /** @type {?} */
    MarkerClusterComponent.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2VyLWNsdXN0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LW1hcGJveC1nbC8iLCJzb3VyY2VzIjpbImxpYi9tYXJrZXItY2x1c3Rlci9tYXJrZXItY2x1c3Rlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUlOLE1BQU0sRUFFTixXQUFXLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLFlBQXVFLE1BQU0sY0FBYyxDQUFDO0FBQ25HLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVoRDtJQUFBO0lBQzhCLENBQUM7O2dCQUQ5QixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsdUJBQXVCLEVBQUU7O0lBQ2xCLHFCQUFDO0NBQUEsQUFEL0IsSUFDK0I7U0FBbEIsY0FBYztBQUUzQjtJQUFBO0lBQ3FDLENBQUM7O2dCQURyQyxTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsOEJBQThCLEVBQUU7O0lBQ2xCLDRCQUFDO0NBQUEsQUFEdEMsSUFDc0M7U0FBekIscUJBQXFCO0FBRWxDO0lBcURFLGdDQUNVLFVBQXNCLEVBQ3RCLGlCQUFvQyxFQUNwQyxJQUFZO1FBSHRCLGlCQUlLO1FBSEssZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLFNBQUksR0FBSixJQUFJLENBQVE7UUFiWixTQUFJLEdBQUcsSUFBSSxZQUFZLEVBQWdCLENBQUM7UUFRMUMsUUFBRyxHQUFH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SSxFQUFFLFdBQVcsRUFBRTtrQ0FDbEQsWUFBWSxTQUFDLHFCQUFxQixFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRTs7SUFrRjVELDZCQUFDO0NBQUEsQUFoSUQsSUFnSUM7U0FwR1ksc0JBQXNCOzs7SUFFakMsd0NBQXlCOztJQUN6Qix5Q0FBMEI7O0lBQzFCLHlDQUEwQjs7SUFDMUIsd0NBQXlCOztJQUN6QiwwQ0FBMkI7O0lBQzNCLHFDQUF1Qjs7SUFDdkIsd0NBQXlEOztJQUN6RCx5Q0FBNkI7O0lBQzdCLHFDQUFtQzs7SUFHbkMsc0NBQXdEOztJQUV4RCxzQ0FBa0Q7O0lBRWxELDBDQUFnRjs7SUFDaEYsaURBQThGOztJQUU5RiwrQ0FBZ0Q7O0lBRWhELDhDQUFtQzs7SUFDbkMscUNBQWlDOztJQTJEakMsNkNBRUM7O0lBRUQsK0NBRUM7O0lBRUQsMkRBRUM7O0lBbEVDLDRDQUE4Qjs7SUFDOUIsbURBQTRDOztJQUM1QyxzQ0FBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBEaXJlY3RpdmUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHN1cGVyY2x1c3RlciwgeyBDbHVzdGVyLCBPcHRpb25zIGFzIFN1cGVyY2x1c3Rlck9wdGlvbnMsIFN1cGVyY2x1c3RlciB9IGZyb20gJ3N1cGVyY2x1c3Rlcic7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwL21hcC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbWdsUG9pbnRdJyB9KVxuZXhwb3J0IGNsYXNzIFBvaW50RGlyZWN0aXZlIHsgfVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVttZ2xDbHVzdGVyUG9pbnRdJyB9KVxuZXhwb3J0IGNsYXNzIENsdXN0ZXJQb2ludERpcmVjdGl2ZSB7IH1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWdsLW1hcmtlci1jbHVzdGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBmZWF0dXJlIG9mIGNsdXN0ZXJQb2ludHNcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3RlcjsgZWxzZSBwb2ludFwiPlxuICAgICAgICA8bWdsLW1hcmtlclxuICAgICAgICAgIFtmZWF0dXJlXT1cImZlYXR1cmVcIlxuICAgICAgICA+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNsdXN0ZXJQb2ludFRwbDsgY29udGV4dDoge1xuICAgICAgICAgICAgJGltcGxpY2l0OiBmZWF0dXJlLFxuICAgICAgICAgICAgZ2V0TGVhdmVzRm46IGdldExlYXZlc0ZuKGZlYXR1cmUpLFxuICAgICAgICAgICAgZ2V0Q2hpbGRyZW5GbjogZ2V0Q2hpbGRyZW5GbihmZWF0dXJlKSxcbiAgICAgICAgICAgIGdldENsdXN0ZXJFeHBhbnNpb25ab29tRm46IGdldENsdXN0ZXJFeHBhbnNpb25ab29tRm4oZmVhdHVyZSlcbiAgICAgICAgICB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLXRlbXBsYXRlICNwb2ludD5cbiAgICAgICAgPG1nbC1tYXJrZXJcbiAgICAgICAgICBbZmVhdHVyZV09XCJmZWF0dXJlXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwb2ludFRwbDsgY29udGV4dDogeyAkaW1wbGljaXQ6IGZlYXR1cmUgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L21nbC1tYXJrZXI+XG4gICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgTWFya2VyQ2x1c3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBPbkluaXQge1xuICAvKiBJbml0IGlucHV0ICovXG4gIEBJbnB1dCgpIHJhZGl1cz86IG51bWJlcjtcbiAgQElucHV0KCkgbWF4Wm9vbT86IG51bWJlcjtcbiAgQElucHV0KCkgbWluWm9vbT86IG51bWJlcjtcbiAgQElucHV0KCkgZXh0ZW50PzogbnVtYmVyO1xuICBASW5wdXQoKSBub2RlU2l6ZT86IG51bWJlcjtcbiAgQElucHV0KCkgbG9nPzogYm9vbGVhbjtcbiAgQElucHV0KCkgcmVkdWNlPzogKGFjY3VtdWxhdGVkOiBhbnksIHByb3BzOiBhbnkpID0+IHZvaWQ7XG4gIEBJbnB1dCgpIGluaXRpYWw/OiAoKSA9PiBhbnk7XG4gIEBJbnB1dCgpIG1hcD86IChwcm9wczogYW55KSA9PiBhbnk7XG5cbiAgLyogRHluYW1pYyBpbnB1dCAqL1xuICBASW5wdXQoKSBkYXRhOiBHZW9KU09OLkZlYXR1cmVDb2xsZWN0aW9uPEdlb0pTT04uUG9pbnQ+O1xuXG4gIEBPdXRwdXQoKSBsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxTdXBlcmNsdXN0ZXI+KCk7XG5cbiAgQENvbnRlbnRDaGlsZChQb2ludERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBwb2ludFRwbDogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZChDbHVzdGVyUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY2x1c3RlclBvaW50VHBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNsdXN0ZXJQb2ludHM6IEdlb0pTT04uRmVhdHVyZTxHZW9KU09OLlBvaW50PltdO1xuXG4gIHByaXZhdGUgc3VwZXJjbHVzdGVyOiBTdXBlcmNsdXN0ZXI7XG4gIHByaXZhdGUgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgTWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICBwcml2YXRlIENoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZVxuICApIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IG9wdGlvbnM6IFN1cGVyY2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tLFxuICAgICAgbWluWm9vbTogdGhpcy5taW5ab29tLFxuICAgICAgZXh0ZW50OiB0aGlzLmV4dGVudCxcbiAgICAgIG5vZGVTaXplOiB0aGlzLm5vZGVTaXplLFxuICAgICAgbG9nOiB0aGlzLmxvZyxcbiAgICAgIHJlZHVjZTogdGhpcy5yZWR1Y2UsXG4gICAgICBpbml0aWFsOiB0aGlzLmluaXRpYWwsXG4gICAgICBtYXA6IHRoaXMubWFwXG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgICAgLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHRrZXkgPSA8a2V5b2YgU3VwZXJjbHVzdGVyT3B0aW9ucz5rZXk7XG4gICAgICAgIGlmIChvcHRpb25zW3RrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9uc1t0a2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgdGhpcy5zdXBlcmNsdXN0ZXIgPSBzdXBlcmNsdXN0ZXIob3B0aW9ucyk7XG4gICAgdGhpcy5zdXBlcmNsdXN0ZXIubG9hZCh0aGlzLmRhdGEuZmVhdHVyZXMpO1xuICAgIHRoaXMubG9hZC5lbWl0KHRoaXMuc3VwZXJjbHVzdGVyKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcy5kYXRhICYmICFjaGFuZ2VzLmRhdGEuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICB0aGlzLnN1cGVyY2x1c3Rlci5sb2FkKHRoaXMuZGF0YS5mZWF0dXJlcyk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuTWFwU2VydmljZS5tYXBDcmVhdGVkJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgbWFwTW92ZSQgPSBtZXJnZShcbiAgICAgICAgZnJvbUV2ZW50KDxhbnk+dGhpcy5NYXBTZXJ2aWNlLm1hcEluc3RhbmNlLCAnem9vbUNoYW5nZScpLFxuICAgICAgICBmcm9tRXZlbnQoPGFueT50aGlzLk1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdtb3ZlJylcbiAgICAgICk7XG4gICAgICBjb25zdCBzdWIgPSBtYXBNb3ZlJC5waXBlKFxuICAgICAgICBzdGFydFdpdGg8YW55Pih1bmRlZmluZWQpXG4gICAgICApLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2x1c3RlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdWIuYWRkKHN1Yik7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1Yi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgZ2V0TGVhdmVzRm4gPSAoZmVhdHVyZTogQ2x1c3RlcikgPT4ge1xuICAgIHJldHVybiAobGltaXQ/OiBudW1iZXIsIG9mZnNldD86IG51bWJlcikgPT4gKDxhbnk+dGhpcy5zdXBlcmNsdXN0ZXIuZ2V0TGVhdmVzKShmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3Rlcl9pZCEsIGxpbWl0LCBvZmZzZXQpO1xuICB9XG5cbiAgZ2V0Q2hpbGRyZW5GbiA9IChmZWF0dXJlOiBDbHVzdGVyKSA9PiB7XG4gICAgcmV0dXJuICgpID0+ICg8YW55PnRoaXMuc3VwZXJjbHVzdGVyLmdldENoaWxkcmVuKShmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3Rlcl9pZCEpO1xuICB9XG5cbiAgZ2V0Q2x1c3RlckV4cGFuc2lvblpvb21GbiA9IChmZWF0dXJlOiBDbHVzdGVyKSA9PiB7XG4gICAgcmV0dXJuICgpID0+ICg8YW55PnRoaXMuc3VwZXJjbHVzdGVyLmdldENsdXN0ZXJFeHBhbnNpb25ab29tKShmZWF0dXJlLnByb3BlcnRpZXMuY2x1c3Rlcl9pZCEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDbHVzdGVyKCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLk1hcFNlcnZpY2UuZ2V0Q3VycmVudFZpZXdwb3J0QmJveCgpO1xuICAgIGNvbnN0IGN1cnJlbnRab29tID0gTWF0aC5yb3VuZCh0aGlzLk1hcFNlcnZpY2UubWFwSW5zdGFuY2UuZ2V0Wm9vbSgpKTtcbiAgICB0aGlzLmNsdXN0ZXJQb2ludHMgPSB0aGlzLnN1cGVyY2x1c3Rlci5nZXRDbHVzdGVycyhiYm94LCBjdXJyZW50Wm9vbSk7XG4gICAgdGhpcy5DaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufVxuIl19